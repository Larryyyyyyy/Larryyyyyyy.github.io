<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Larry's garden</title>
        <link href="static\css\mainpage.css" rel="stylesheet"></link>
        <link href="static\plugins\bootstrap-5.3.3-dist\css\bootstrap.min.css" rel="stylesheet"></link>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet"></link>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown-dark.min.css">
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
        <script src="static\plugins\bootstrap-5.3.3-dist\js\bootstrap.bundle.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
        <style>
            @media (max-width: 767px) { body { padding: 15px; } }
            :root {
                --bs-body-bg: #1a1a1a;
                --bs-body-color: #e0e0e0;
                --bs-card-bg: #2d2d2d;
                --bs-border-color: #444;
            }
            body { 
                box-sizing: border-box;
                margin: 0 auto;
                color: black;
            }
            .text-muted {
                color: #bbb7b7 !important;
                opacity: 0.8;
            }
            ::placeholder {
                color: #918d8d !important;
            }
            :-ms-input-placeholder {
                color: #918d8d !important; /* IE兼容 */
            }
            ::-ms-input-placeholder {
                color: #918d8d !important; /* Edge兼容 */
            }
            html, body {
                background-color: #0d1117;
                color: #c9d1d9;
            }
            .markdown-body {
                background-color: transparent;
                min-width: 200px;
                max-width: 980px;
                padding: 40px;
                position: relative;
                left: 120px;
            }
            html {
                scroll-behavior: smooth;
            }
            #toc a:hover {
                color: #c9d1d9;
                font-weight: bold;
            }
            .content {
                margin-right: 280px;
            }
            #toc a {
                color: white;
            }
            #toc a:hover {
                color: #ffc107; /* 黄色悬停高亮 */
                font-weight: bold;
            }
            #toc .list-group-item {
                background-color: #333;
                border: none;
            }
            #toc .list-group-item:hover {
                background-color: #444;
            }
            .player {
                position: fixed;
                bottom: -100px;
                left: 0;
                width: 100%;
                background-color: #333;
                padding: 15px;
                border-radius: 10px;
                transition: bottom 0.3s ease;
            }
            .player.active {
                bottom: 0;
            }
            .player .control-button {
                color: white;
                border: none;
                background: transparent;
            }
            .player .control-button:hover {
                color: #f39c12;
            }
        </style>
        <script>
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']],
                    displayMath: [['$$', '$$'], ['\\[', '\\]']]
                },
                svg: {
                    fontCache: 'global'
                }
            };
        </script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
    </head>
    <body>
        <div class="stars"></div>
        <nav class="navbar navbar-expand-lg bg-body-tertiary" data-bs-theme="dark" style="width: -100px;">
            <div class="container-fluid">
                <a class="navbar-brand" href="#">Larry的小花园</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse justify-content-between" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a class="nav-link" aria-current="page" href="index.html">首页</a>
                        </li>
                    <li class="nav-item">
                        <a class="nav-link" href="chat.html">聊天</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle active" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">资源</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="advanced_programing.html">高等程序设计A</a></li>
                            <li><a class="dropdown-item" href="computer_basic.html">计算机系统基础</a></li>
                            <li><a class="dropdown-item" href="data_structure.html">数据结构A</a></li>
                            <li><a class="dropdown-item" href="computer_organization_and_architecture.html">计算机组成与体系结构A</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="more_resources.html">更多...</a></li>
                        </ul>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">游戏</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="pac_man.html">吃豆人</a></li>
                            <li><a class="dropdown-item" href="2048.html">2048</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="#">更多...</a></li>
                        </ul>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link disabled" aria-disabled="true"></a>
                    </li>
                    </ul>
                </div>
            </div>
        </nav>
        <form class="d-flex ms-auto" role="search">
            <input class="form-control me-2" type="search" placeholder="搜索" aria-label="search" style="position: relative; left: 150px; width: 920px;"></input>
            <button class="btn btn-outline-success me-3" type="submit" style="position: relative; left: 150px;">
			    <img src="static\img\search.png" alt="Search" style="width: 20px; height: 20px; background-color: dark;">
			</button>
        </form>
        <script>
            const form = document.querySelector("form[role='search']");
            const input = form.querySelector("input[type='search']");
            form.addEventListener("submit", function (e) {
            e.preventDefault();
            const keyword = input.value.trim().toLowerCase();
            if (!keyword) return;
            const contentBlocks = document.querySelectorAll(".markdown-body p, .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6");
            let found = false;
            contentBlocks.forEach(block => {
                if (block.textContent.toLowerCase().includes(keyword)) {
                    block.scrollIntoView({ behavior: "smooth", block: "center" });
                    block.style.backgroundColor = "#fffa90";
                    setTimeout(() => block.style.backgroundColor = "", 2000);
                    found = true;
                }
            });
            if (!found) {
                alert("没有找到匹配的内容。");
            }
        });
        </script>
        <div id="toc" class="position-fixed border rounded shadow p-3" style="top: 100px; width: 350px; max-height: 70vh; overflow-y: auto; z-index: 1000; position: relative; right: 30px;">
            <strong class="mb-2 d-block">目录</strong>
            <ul class="list-group list-group-flush" id="toc-list"></ul>
        </div>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                const tocList = document.getElementById("toc-list");
                const headers = document.querySelectorAll("h1, h2, h3");
                let index = 0;
                headers.forEach(header => {
                    if (!header.id) {
                        header.id = "heading-" + index++;
                    }
                    const li = document.createElement("li");
                    li.className = "list-group-item px-2 py-1";
                    const indent = header.tagName === "H2" ? "ms-3" :
                    header.tagName === "H3" ? "ms-5" : "";
                    li.innerHTML = `<a class="${indent} text-decoration-none" href="#${header.id}">${header.innerText}</a>`;
                    tocList.appendChild(li);
                });
            });
        </script>
        <div id="$m" class="markdown-body"></div>
        <textarea id="$t" style="display:none">
# 1.基本概念

> 下载本文代码涉及的头文件<a href="./static/res/header.h" download>header.h</a>

## 1.1数据结构的定义

用计算机解决一个具体问题的步骤：

1. 分析问题，确定数据模型。
2. 设计相应的算法。
3. 编写程序，运行并调试程序，直至得到正确的结果。

**数据(data)是描述客观事物的数和字符的集合**。

**数据项(data item)是具有独立含义的数据最小单位，也称为字段或域**。

**数据对象(data object)是指性质相同的数据元素的集合，它是数据的一个子集**。

**数据结构(data structure)是指所有数据元素以及数据元素之间的关系，可以看作是相互之间存在着某种特定关系的数据元素的集合**。

**数据结构=数据+结构**

数据的结构通常包括：

1. **数据的逻辑结构(logical structure)：由数据元素之间的逻辑关系构成**。
2. **数据的存储结构(storage structure)：数据元素及其关系在计算机存储器中的存储表示，也称为数据的物理结构(physical structure)**。
3. **数据的运算(operation)：施加在该数据上的操作**。

### 1.1.1逻辑结构

**数据的逻辑结构是从数据元素的逻辑关系上描述数据的，是指数据元素之间的逻辑关系的整体，通常是从求解问题中提炼出来的**。

#### 逻辑结构的表示

1. 图表表示
2. 二元组表示：`<x,y>`表示元素`x`和`y`之间是相邻的，`x`为`y`的直接前驱元素，`y`为`x`的直接后继元素。

#### 逻辑结构的类型

1. 集合
2. 线性结构
3. 树形结构
4. 图形结构

### 1.1.2存储结构

**数据逻辑结构在计算存储器中的存储表示称为数据的存储结构(也称为映像)，也就是逻辑结构在计算机中的存储实现**。

#### 顺序存储结构

是采用一组连续的存储单元存放所有的数据元素，**所有数据元素在存储器中占有一整块存储空间**，**两个逻辑上相邻的元素在存储器中的存储位置也相邻**。

优点：

1. 存储效率高，存储单元全用于存放数据元素，元素之间的逻辑关系没有占用额外的存储空间。
2. 可实现元素的随机存取。

缺点：

1. 不便于数据修改。

#### 链式存储结构

每个逻辑元素用一个内存结点存储，每个结点是单独分配的，所有的结点地址不一定是连续的，**所以无须占用一整块存储空间**。**给每个结点附加指针域**，**用于存放相邻结点的存储地址**。

优点：

1. 便于数据修改。

缺点：

1. 空间的利用率较低。
2. 不能对元素进行随机存取。

#### 索引存储结构

存储数据元素信息的同时还建立附加的索引表。**存储所有数据元素信息的表称为主数据表**，**每个数据元素有一个关键字和对应的存储地址**。

索引项一般是**关键字→地址**。通常，索引表中的所有索引项是按关键字有序排列的，利用这个性质，可以快速根据关键字查找到主数据表中的对应元素。

优点：

1. 查找效率高。

缺点：

1. 增加了索引表的空间开销。

#### 哈希(或散列)存储结构

根据元素的关键字通过哈希(或散列)函数直接计算出一个值，并将这个值作为该元素的存储地址。

优点：

1. 查找速度快

### 1.1.3数据运算

**数据运算是指对数据实施的操作**。

包括：**检索**、**插入**、**删除**、**更新**和**排序**等。

#### 运算定义

运算功能的描述，是抽象的，是基于逻辑结构的。

#### 运算实现

完成运算的实现方法，是具体的，是基于存储结构的。

**逻辑结构(运算定义)--映射->存储结构(运算实现)**

对于一种数据结构，其逻辑结构总是唯一的，但它可能对应多种存储结构，并且在不同的存储结构中同一运算的实现过程可能不同。

### 1.1.4数据类型和抽象数据类型

#### 数据类型

**一组性质相同的值的集合和定义在此集合上的一组操作的总称，是某种程序设计语言中已实现的数据结构**。

1. **基本数据类型(也被称为自动变量)**：系统自动为变量分配一个固定长度的存储空间，当超出其作用范围时系统自动释放其内存空间。
2. **指针类型**
3. **数组类型**
4. **结构体类型**
5. **共用体类型**
6. **自定义类型**

#### 存储空间的分配

1. **静态存储空间分配方式**：在程序编译期间分配固定的存储空间的方式：在变量定义时就分配存储单元并一直保持不变，直至整个程序结束。

2. **动态存储空间分配方式**：在程序运行期间根据需要动态地分配存储空间的方式：可以用`malloc()/free()`函数分配和释放空间。

   ```c++
   char* p;
   p=(char &)malloc(10*sizeof(char));
   strcpy(p,"China");
   free(p);
   ```

   一定要用`free()`释放内存，否则动态分配的空间对于程序而言就丢失了，可能造成内存泄露。

#### 抽象数据类型

**指用户进行软件系统设计时从问题的数学模型中抽象出来的逻辑数据结构和逻辑数据结构上的运算，而不考虑计算机的具体存储结构和运算的具体实现算法**。

一个抽象数据类型可用$(D,S,P)$三元组表示。其中，$D$是数据对象，$S$是$D$上的关系集，$P$是$D$中数据运算的基本运算集。

例如，一个复数的抽象数据类型`Complex`定义如下：

~~密码的，latex太难调了，反正不重要，不写了，密码的。~~

**重要特征**

1. 数据抽象：指用`ADT`描述程序处理的实体时强调的是其本质的特征、其所能完成的功能以及它和外部用户的接口(即外界使用它的方法)。
2. 数据封装：指将实体的外部特性和其内部实现细节分离，并且对外部用户隐藏其内部实现细节。

抽象数据类型需要通过固有数据类型来实现。

## 1.2算法及其描述

### 1.2.1算法

**算法是对特定问题求解步骤的一种描述，它是指令的有限序列**。

**算法的特性**：

1. **有穷性**：有穷步和有穷时间。
2. **确定性**：不能有二义性。
3. **可行性**：所有操作都必须足够基本。
4. **有输入**：有零个或多个输入。
5. **有输出**：有与输入对应关系的量值。有一个或者多个输出。

### 1.2.2算法设计的目标

1. **正确性**：最重要且最基本。
2. **可使用性**：用户友好性。
3. **可读性**：清晰，简单，结构化。
4. **健壮性**：容错性高。
5. **高效率与低存储量需求**：一定程度上取决于问题的规模。

### 1.2.3算法描述

这里采用`C/C++`语言来描述算法，通常是`C/C++`函数。

## 1.3算法分析

### 1.3.1算法分析概述

分析算法占用计算机资源的多少，即占用`CPU`时间(时间性能分析)和内存空间(空间性能分析)。

### 1.3.2算法时间性能分析

#### 两种算法时间性能分析方法

- **事后统计法**
  统计实际执行时间，必须执行程序，存在很多因素掩盖算法本质。
- **事前估算法**
  依赖问题的规模，或者说算法的执行时间是问题规模的函数。主要采用这种方法分析时间性能。

#### 算法时间复杂度分析

1. **计算算法的频度$T(n)$**
   一个算法是由控制结构(顺序、分支和循环3种)和原操作(指固有数据类型的操作)构成的。

   ```c++
   void fun(int a[],int n){
   	int i;              //p1
   	for(i=0;i<n;++i)    //p2
   	a[i]=2*i;           //p3
   	for(i=0;i<n;++i)    //p4
   	printf("%d",a[i]);  //p5
   	puts("");           //p6
   }
   ```

   上述语句中`p1`，`p3`，`p5`，`p6`就是原操作。

   **一个算法的执行时间可以由其中原操作的执行次数来计量**。

   算法时间分析的就是求出算法所有原操作的执行次数(也称为频度)，它是问题规模$n$的函数，用$T(n)$表示。

   算法执行时间大致等于原操作所需的时间$\times T(n)$。

2. **$T(n)$用$O$表示**
   算法时间复杂度就是用$T(n)$的数量级来表示，记作$T(n)=O(f(n))$。
   严格数学定义是$T(n)$的数量级表示为$O(f(n))$，是指存在着正常量$c$和$n_0$(一个足够大的正整数)，使得$\lim\limits_{x \to n_0} \frac{|T(n)|}{|f(n)|} =c\neq0$
   通常
   $$
   O(1)<O(log_2n)<O(n)<O(nlog_2n)<O(n^2)<O(n^3)<O(2^n)<O(n!)
   $$
   $O(log_2n)、O(n)、O(nlog_2n)、O(n^2)、O(n^3)$称为**多项式时间复杂度**，$O(2^n)、O(n!)$称为**指数时间复杂度**。

   一个问题可以通过**多项式时间复杂度**求解，则称为`P`问题，可以通过**指数时间复杂度**求解，则称为`NP`问题。

3. **简化的算法时间复杂度分析**
   即仅仅考虑算法中的基本操作，也就是最深层循环内的原操作。算法执行时间大致等于基本操作所需的时间$\times$其运算次数。

4. **时间复杂度的求和、求积定理**
   **求和定理**：设$T_1(n)=O(f(n)),T_2(n)=O(g(n))$，那么先执行第一部分再执行第二部分的总执行时间是$T_1(n)+T_2(n)=O(MAX(f(n),g(n)))$，例如多个并列循环就属于这种情况。
   **求积定理**：设$T_1(n)=O(f(n)),T_2(n)=O(g(n))$，那么$T_1(n)\times T_2(n)=O(f(n)\times g(n))$，例如多层嵌套循环就属于这种情况。

#### 算法的最好、最坏和平均时间复杂度

- **平均时间复杂度**
  设$I$是所有输入的集合$D_n$中的一个，$P(I)$是$I$出现的频率，$T(I)$是算法在输入$I$下所执行的基本操作次数，则该算法的平均时间复杂度定义为
  $$
  E(n)=\sum_{I\in D_n}P(I)\times T(I)
  $$

- **最好时间复杂度**
  $B(n)=MIN_{I\in D_n}\{T(n)\}$

- **最坏时间复杂度**
  $W(n)=MAX_{I\in D_n}\{T(n)\}$

#### 递归算法时间复杂度分析

参考如下例：

```c++
void fun(int a[],int n,int k){
	int i;
	if(k==n-1){
		for(i=0;i<n;++i)printf("%d\n",a[i]);
	}
	else{
		for(i=k;i<n;++i)a[i]=a[i]+i*i;
		fun(a,n,k+1);
	}
}
```

设$fun(a,n,k)$的执行时间为$T(n,k)$，$T(n)=T(n,0)$，且令$T(n,n)=n$，则当$k<n-1$时：
$$
T(n,k)=(n-k)+T(n,k+1)
$$
易得：
$$
T(n)=\frac{n^2}{2}+\frac{3n}{2}-1=O(n^2)
$$

### 1.3.3算法空间性能分析

#### 算法空间复杂度分析

**算法空间复杂度**是对一个算法在运行过程中临时占用得存储空间大小的量度，一般只考察临时变量所占的空间。一般也作为问题规模$n$的函数，以数量级形式给出，记作
$$
S(n)=O(g(n))
$$
其中$O$的含义与时间复杂度中的含义相同。

若所需临时空间相对于问题规模来说是常数，则称此算法为**原地工作**算法或**就地工作**算法。

#### 递归算法空间复杂度分析

分析方法与时间复杂度分析类似。

## 1.4数据结构+算法=程序

略

# 2.线性表

## 2.1线性表及其逻辑结构

### 2.1.1线性表的定义

**线性表**是具有相同特性的数据元素的一个有限序列。一般表示为$(a_1,a_2,...,a_i,...,a_n)$。

线性表用二元组表示为$L=(D,R)$，其中：
$$
D=\lbrace a_i|1\le i\le n,n\ge 0,a_i为ElemType类型\rbrace\\
$$
$$
R=\lbrace r\rbrace\\
$$
$$
r=\lbrace <a_i,a_{i+1}>|1\le i \le n-1\rbrace\\
$$
特性：

1. **有穷性**：一个线性表中的元素个数是有限的。
2. **一致性**：一个线性表中所有元素的性质相同。从实现的角度看，所有元素具有相同的数据类型。
3. **序列性**：一个线性表中所有元素之间的相对位置是线性的，即存在唯一的开始元素和终端元素，除此之外，每个元素只有唯一的前驱元素和后继元素。各元素在线性表中的位置只取决于它们的序号，所以在一个线性表中可以存在两个值相同的元素。

### 2.1.2线性表的抽象数据类型描述

~~谁爱描述谁描述。~~

## 2.2线性表的顺序存储结构

**存储密度**：**指结点中数据元素本身所占的存储量和整个结点占用的存储量之比**。顺序表的存储密度比较高，通常为$1$。而链表的存储密度小于$1$，单链表的存储密度为$50\%$。

### 2.2.1线性表的顺序存储结构——顺序表

参考<a href="./static/res/seqList.cpp" download>seqList.cpp</a>

## 2.3线性表的链式存储结构

### 2.3.1线性表的链式存储结构——链表

参考<a href="./static/res/doublyLinkedList.cpp" download>doublyLinkedList.cpp</a>

# 3.栈和队列

## 3.1栈

### 3.1.1栈的定义

**栈是一种只能在一端进行插入或删除操作的线性表**。

### 3.1.2栈的顺序存储结构及其基本运算的实现

参考<a href="./static/res/seqStack.cpp" download>seqStack.cpp</a>

### 3.1.3栈的链式存储结构及其基本运算的实现

参考<a href="./static/res/linkedStack.cpp" download>linkedStack.cpp</a>

> 忘写了。

### 3.1.4栈的应用

- 中、后缀表达式求值。
- 深度优先搜索。

## 3.2队列

### 3.2.1队列的定义

**队列是一种操作受限的线性表，仅允许在表的一端进行插入操作，而在表的另一端进行删除操作**。

### 3.2.2队列的顺序存储结构及其基本运算的实现

- 顺序队列

  参考<a href="./static/res/seqQueue.cpp" download>seqQueue.cpp</a>

- 环形队列。

  参考<a href="./static/res/seqCircleQueue.cpp" download>seqCircleQueue.cpp</a>

### 3.2.3队列的链式存储结构及其基本运算的实现

参考<a href="./static/res/linkedQueue.cpp" download>linkedQueue.cpp</a>

### 3.2.4队列的应用

- 求解报数问题。
- 广度优先搜索。

### 3.2.5双端队列

参考<a href="./static/res/seqDeque.cpp" download>seqDeque.cpp</a>

# 4.串

## 4.1串的基本概念

**串是由零个或多个字符组成的有限序列**。

含零个字符的串称为**空串**。

**两个串相等**当且仅当长度相等且各个位置上字符都相同。

一个串中任意个连续字符组成的序列称为该串的**子串**。

串的抽象数据描述如下：

~~查无此描述。~~

## 4.2串的存储结构

和线性表一样，串也有顺序存储结构和链式存储结构。前者叫**顺序串**，后者叫**链串**。

### 4.2.1串的顺序存储结构——顺序串

顺序串中的字符被依次存放在一组连续的存储单元里。一般一个字节表示一个字符。而计算机内存是按字编址的，即以字为存储单位，一个字包含的字节数随机器而异。

顺序串的存储方式有两种：

1. **非紧缩格式**(其存储密度小)：每个字只存一个字符。
   比较浪费存储空间，但处理单个字符或者一组连续字符方便。
2. **紧缩格式**(其存储密度大)：每个字存放多个字符。
   节省存储空间，但处理单个字符不太方便，运算效率低，需要花费时间从同一个字中分离字符。

我们主要讨论**非紧缩格式**。

参考<a href="./static/res/seqString.cpp" download>seqString.cpp</a>

### 4.2.2串的链式存储结构——链串

串采用链式存储结构存储时称为**链串**。

链串的组织形式与一般的单链表类似，主要区别在于链串中的一个结点可以存储多个字符。

通常将链串中每个结点所存储的字符个数称为**结点大小**。

当结点大小大于$1$时，会在链串尾结点未占满的数据域里补上不属于字符集的特殊符号(例如`#`)

1. 结点大小较大：存储密度较大，但一些基本操作(如插入、删除、替换)有所不便。
   适合串很少修改的情况。
2. 结点大小较小：相关操作的实现方便，但存储密度下降。

我们主要讨论链串结点大小为$1$。

参考<a href="./static/res/linkedString.cpp" download>linkedString.cpp</a>

## 4.3串的模式匹配

### 4.3.1Brute-Force算法

暴力，无需多言。

### 4.3.2KMP算法

通过分析模式串$t$从中提取出加速匹配的有用信息，这种信息是对于$t$的每个字符$t_j(0\le j\le m-1)$存在一个整数$k(k<j)$，使得模式串$t$中开头的$k$个字符$(t_0t_1\dots t_{k-1})$依次与$t_j$的前面$k$个字符$(t_{j-k}t_{j-k+1}\dots t_{j-1})$相同。如果有多个这样的$k$则取较大的$k$。

模式串$t$中每个位置$j$的字符都有这种信息，记为$nxt[j]$。

**$nxt$数组的求解过程**：

1. $nxt[0]=-1,nxt[1]=0(j=0)$
2. 如果$nxt[j]==k$，表示有"$t_0t_1\dots t_{k-1}$"$=$"$t_{j-k}t_{j-k+1}\dots t_{j-1}$"。
   若$k==-1$或$t_k==t_j$，也就是"$t_0t_1\dots t_{k-1}t_{k}$"$=$"$t_{j-k}t_{j-k+1}\dots t_{j-1}t_{j}$"，于是$nxt[++j]=++k$。
   若$t_k\ne t_j$，应当试图匹配一个较短的子串，则$k=nxt[k]$。

**$KMP$算法的匹配过程**：

设目标串$s=$"$s_0s_1\dots s_{n-1}$"，模式串$t=$"$t_0t_1\dots t_{m-1}$"，在进行第$i-j+1$趟匹配(从$s_{i-j}$开始)时出现失配情况($s_i\ne t_j$)。

这时的部分匹配是"$t_0t_1\dots t_{j-1}$"$=$"$s_{i-j}s_{i-j+1}\dots s_{i-1}$"，又有$nxt[j]=k$，说明"$t_0t_1\dots t_{k-1}$"$=$"$t_{j-k}t_{j-k+1}\dots t_{j-1}$"，因此"$t_0t_1\dots t_{k-1}$"$=$"$s_{i-k}s_{i-k+1}\dots s_{i-1}$"。下一趟就不再从$s_{i-j+1}$开始匹配，而是$s_{i-k}$开始匹配，并且将$s_i$和$t_k$比较，这样就可以把第$i-j+1$趟比较适配时的模式串$t$从当前位置直接右滑$j-k$个字符。

从而执行过程如下：

1. $j=-1或s[i]==t[j]$，则$++i,++j$。
2. 否则$j=nxt[j]$。
3. 直至$j>=t.length()$，匹配位置就是$i-t.length()$。

我们发现，若按照前面求$nxt$的步骤，得到$nxt[j]=k$，在模式串中有$t_j=t_k$，当目标串中的字符$s_i$和模式串中的字符$t_j$比较不相同时，$s_i$一定和$t_k$也不相同，所以没必要再将$s_i$和$t_k$进行比较，而是直接将$s_i$和$t_{nxt[k]}$比较，为此将$nxt[j]$修正为$nxtval[j]$。

**$nxtval$数组的求解过程**：

1. $nxtval[0]=-1,nxtval[1]=0(j=0)$
2. 若$k==-1$或$t_k==t_j$，则$++j,++k$，如果$t_j\ne t_k$，则$nxtval[j]=k$，否则$nxtval[j]=nxtval[k]$。
   若$t_k\ne t_j$，应当试图匹配一个较短的子串，则$k=nxtval[k]$。

**时间复杂度**：$O(n+m)$

# 5.递归

## 5.1什么是递归

### 5.1.1递归的定义

**一个过程或函数调用自身**。

### 5.1.2何时使用递归

1. 定义是递归的：将递归定义转化为递归算法。
2. 数据结构是递归的：例如结点数据结构中指向下一个结点的指针。
3. 问题求解方法是递归的：无需多言。

### 5.1.3递归模型

可以用树的模型阐释。

### 5.1.4递归与数学归纳法

数学归纳法是递归求解问题的理论基础。

## 5.2栈和递归

### 5.2.1函数调用栈

大多数`CPU`上的程序实现使用栈来支持函数调用操作，**单个函数调用操作所使用的函数调用栈被称为栈帧结构**，每次函数调用时都会相应地创建一帧，保存返回地址、函数实参和局部变量值等，并将该帧压入调用栈。在函数返回前发生新调用，则把新函数对应的一帧进栈，成为栈顶。函数执行完毕，对应的帧便出栈，控制权交还给该函数的上层调用函数。

### 5.2.2递归调用的实现

递归调用在内部实现时并不是每次调用真正去复制一个复制件存放到内存中，而是采用**代码共享**的方式。系统为每一次调用开辟一组**存储单元**，用来存放本次调用的返回地址以及被中断的函数的参数值。这些单元以**栈**的形式存放，每调用一次进栈一次，当返回时执行出栈操作，把当前栈顶保留的值送回相应的参数中进行恢复，并按栈顶中的返回地址从断点继续执行。

*如果习惯断点调试，就很容易理解这个过程*。

### 5.2.3递归到非递归的转换

1. **减少栈溢出**：递归深度过大时，可能会导致栈溢出。对于深递归，使用非递归方法可以避免这个问题。
2. **提高效率**：递归往往会有额外的函数调用开销，非递归实现可以通过显式的数据结构避免这种开销。
3. **优化**：某些递归实现效率较低，可以通过非递归的方式优化性能。

通常的做法是显式模拟递归函数的调用过程。这可以通过栈来完成。

## 5.3递归算法的设计

### 5.3.1递归算法设计的步骤

做熟练了哪要记什么步骤呢？

### 5.3.2基于递归数据结构的递归算法设计

这种类型侧重于处理具有树形或类似结构的问题，利用递归来解决。关键点在于数据结构本身支持递归操作，比如树、链表等。

- 特点：
  - 数据结构本身具有层次性，如树形结构。
  - 递归用于遍历和处理每个节点或子问题。
- 例子：
  - **快速排序**：利用二叉搜索树结构，递归地将数组分成两部分，分别排序后合并。
  - **归并排序**：通过递归地比较子列表并将它们合并，最终得到有序的列表。

### 5.3.3基于递归求解方法的递归算法设计

这种类型更注重如何利用递归来分解问题，寻找答案，而不论数据结构复杂性。这适用于所有类型的问题，不一定涉及复杂的数据结构。

- 特点：
  - 递归用于分解问题到更小的子问题，逐步解决。
- 例子：
  - **计算阶乘**：递归地将$n$分解为$n\times (n-1)\times...\times 1$。
  - **斐波那契数列**：递归地将问题分解为更小的两个问题，然后合并结果。

# 6.数组和广义表

## 6.1数组

### 6.1.1数组的基本概念

从逻辑结构上看，一维数组$A$是$n(n>1)$个相同类型数据元素$a_1,a_2,\dots ,a_n$构成的有限序列，其逻辑表示如下：
$$
A=(a_1,a_2,\dots,a_n)
$$
其中，$a_i(1\le i\le n)$表示数组$A$的第$i$个元素。

多维数组可以看作一个由$d-1$维数组作为数据元素的线性表。

$d$维数组的抽象数据类型：

~~没这东西。~~

数组具有以下性质：

1. 元素数目固定。
2. 元素具有相同数据类型。
3. 每个数据元素都和一组唯一的下标对应。
4. 随机存储结构，可随机存取数组中的任意数据元素。

### 6.1.2数组的存储结构

有**按行优先存放**和**按列优先存放**，对应的下标可以由公式推出。

### 6.1.3特殊矩阵的压缩存储

包括**对称矩阵**、**上下三角矩阵**和**对角矩阵**的压缩存储。

相当于把元素映射到一个一维数组上，注意具体下标推导。

## 6.2稀疏矩阵

当一个矩阵非零元素数量远小于矩阵元素总数时，称该矩阵为**稀疏矩阵**。

### 6.2.1稀疏矩阵的三元组表示

通常由一个三元组$(i,j,a_{i,j})$唯一确定，稀疏矩阵中的所有非零元素构成三元组线性表。

一定程度上节省存储空间，但是会丧失随机存取特性。

### 6.2.2稀疏矩阵的十字链表表示

**十字链表**是稀疏矩阵的一种链式存储结构。

我们需要给每个非零元素建立一个数据结点，包含行、列、值，行指针，列指针的信息。

再给每一行，每一列建立一个带头结点的单链表，头结点包括行、列、指向其它头结点的指针，指向行或者列数据的指针。看似第$i$行的头结点和第$i$列的头指针不同，事实上可以把它们合为一个头指针。

最后建立一个总头结点，包含矩阵行列数和指向头结点$h[0]$。

<img src=".\pictures\image-20250202155810834.png">

## 6.3广义表

### 6.3.1广义表的定义

**广义表**是线性表的推广，是有限个元素的序列，$GL=(a_1,a_2,\dots,a_i,\dots,a_n)$

其中$a_i$可以是**原子**，也可以是**子表**。

定义广义表的**长度**为最外层包含元素的个数，**深度**为层数。

例：$A((a,(a,b),((a,b),c)))$的长度为1，深度为4。

值得注意的是：一个广义表可以是自己的子表，这种广义表称为递归表。递归表的深度是无穷值，而长度是有限值。

### 6.3.2广义表的存储结构

采用链式存储结构。

采用以下结构：

| `tag` | `sublist/data` | `link` |
| ----- | -------------- | ------ |

1. 若`tag=0`，表示该结点为原子结点，则第2个域为`data`，存放相应原子元素的信息；
2. 若`tag=1`，表示该结点为表/子表结点，则第2个域为`sublist`，存放相应表/子表中第一个元素对应结点的地址。

当没有兄弟结点时，其`link`域为`NULL`。

### 6.3.3广义表的运算

参考<a href="./static/res/generalizedTable.cpp" download>generalizedTable.cpp</a>

# 7.树和二叉树

## 7.1树的基本概念

### 7.1.1树的定义

**树是由$n(n\ge 0)$个结点(或元素)组成的有限集合(记为T)**。

树的抽象数据类型：

~~无。~~

### 7.1.2树的逻辑表示方法

1. **树形表示法**：画图。
2. **文氏图表示法**：画圈圈。
3. **凹入表示法**：画条形图，长的为父亲结点。
4. **括号表示法**：画括号，类似广义表。

### 7.1.3树的基本术语

1. **结点的度与树的度**：分别是某个结点子树的个数和数中所有结点的度的最大值。
2. **分支结点与叶子结点**：分别是度不为零的结点和度为零的结点。
3. **路径与路径长度**：分别是任意两个结点连接的结点序列和这个序列长度。
4. **孩子结点、双亲结点、兄弟结点、子孙结点和祖先结点**：分别是顾名思义。
5. **结点层次和树的高度**：相当于深度。
6. **有序树和无序树**：若各结点子树按照一定次序排，则称为有序树，否则为无序树。
7. **森林**：$n$个互不相交的树的集合称为森林。

### 7.1.4树的性质

1. **数中结点数等于所有结点度数之和加1**。
2. **度为$m$的树中第$i$层上最多有$m^{i-1}$个结点$(i\ge 1)$**。
3. **高度为$h$的$m$次树最多有$\frac{m^h-1}{m-1}$个结点**。
4. **具有$n$个结点的$m$次树的最小高度为$log_m(n(m-1)+1)$**。

### 7.1.5树的基本运算

1. **寻找满足某种特定条件的结点**。
2. **插入或删除某个结点**。
3. **遍历树中的所有结点**：其中**层次遍历**为从上到下、从左到右的次序。

### 7.1.6树的存储结构

1. **双亲存储结构**：每个结点存储值和双亲位置。
2. **孩子链存储结构**：每个结点存储值和孩子位置。
3. **孩子兄弟链存储结构**：每个结点存储值和长子位置和下一个兄弟位置。

## 7.2二叉树的概念和性质

### 7.2.1二叉树的定义

无需多言。

### 7.2.2二叉树的性质

1. **非空二叉树上的叶子结点数等于双分支结点数加1**。
2. **非空二叉树的第$i$层上最多有$2^{i-1}$个结点$(i\ge 1)$**。
3. **高度为$h$的二叉树最多有$2^h-1$个结点$(h\ge 1)$**。
4. **完全二叉树具有些简单性质**。

### 7.2.3二叉树与树、森林之间的转换

1. **森林、树转换为二叉树**：相邻兄弟之间连线、删除非长子与双亲结点之间的连线。如果是森林，再将每个二叉树根节点相连。
2. **二叉树还原为树/森林**：逆过程。

## 7.3二叉树的存储结构

### 7.3.1二叉树的顺序存储结构

参考<a href="./static/res/seqBinaryTree.cpp" download>seqBinaryTree.cpp</a>

### 7.3.2二叉树的链式存储结构

参考<a href="./static/res/linkedBinaryTree.cpp" download>linkedBinaryTree.cpp</a>

## 7.4二叉树的基本运算及其实现

略。

## 7.5二叉树的遍历

略。

## 7.6二叉树的构造

**任何$n(n\ge 0)$个不同结点的二叉树，都可由它的中序序列和先序序列唯一地确定**。

示例<a href="./static/res/createBinayTree1.cpp" download>createBinaryTree1.cpp</a>

**任何$n(n\ge 0)$个不同结点的二叉树，都可由它的中序序列和后序序列唯一地确定**。

示例<a href="./static/res/createBinaryTree2.cpp" download>createBinaryTree2.cpp</a>

## 7.7线索二叉树

### 7.7.1线索二叉树的概念

**当某个结点左指针为空时，令该指针指向遍历序列中的前驱结点；当某个结点右指针为空时，令该指针指向遍历序列中的后继结点**。

### 7.7.2线索化二叉树

参考<a href="./static/res/threadedBinaryTree.cpp" download>threadedBinaryTree.cpp</a>

### 7.7.3遍历线索化二叉树

参考<a href="./static/res/threadedBinaryTree.cpp" download>threadedBinaryTree.cpp</a>

## 7.8哈夫曼树

### 7.8.1哈夫曼树概述

**带权路径长度(WPL)**：从根结点到该结点之间的路径长度与该结点上权的乘积
$$
WPL=\sum_{i=1}^{n_0}w_il_i
$$
**在$n_0$个带权叶子结点构成的所有二叉树中，带权路径长度WPL最小的二叉树称为哈夫曼树或最优二叉树**。

### 7.8.2哈夫曼树的构造算法

如图所示：

<img src=".\pictures\image-20250204140123216.png">

**对于具有$n_0$个叶子结点的哈夫曼树，共有$2n_0-1$个结点**。

### 7.8.3哈夫曼编码

参考<a href="./static/res/huffmanTree.cpp" download>huffmanTree.cpp</a>

## 7.9用并查集求解等价问题

### 7.9.1什么叫并查集

有"关系"的元素被分为一组，这一组可以用树的结构表示，这一组就是**并查集**。

### 7.9.2并查集的算法实现

略，烂熟于心。

# 8.图

## 8.1图的基本概念

### 8.1.1图的定义

图$G$由两个集合$V$和$E$组成，记为$G=(V,E)$，其中$V$是顶点的有限集合，记为$V(G)$，$E$是连接$V$中两个不同顶点(顶点对)的边的有限集合，记为$E(G)$。

包括**有向图**、**无向图**。

图的抽象数据类型：

~~去去去。~~

### 8.1.2图的基本术语

1. **端点和邻接点**：无向图中若存在一条边$(i,j)$，则顶点$i$和$j$为该边的两个**端点**，互为**邻接点**。而在有向图中若存在一条有向边$<i,j>$，则$i$为**起始端点**，$j$为**终止端点**，$j$是$i$的**出边邻接点**，$i$是$j$的**入边邻接点**。
2. **顶点的度、入度和出度**：略。
3. **完全图**：无向图每两个顶点之间都存在着一条边或有向图每两个顶点之间都存在方向相反的两条边。
4. **稠密图和稀疏图**：接近完全图的图和含有较少的边数的图。
5. **子图**：图$A$是图$B$的子图当且仅当$V_A\in V_B且E_A\in E_B$。
6. **路径和路径长度**：无需多言，只需注意若一条路径除开始点和结束点相同以外其余顶点均不相同，则此路径为**简单路径**。
7. **回路或环**：一条路径的开始点与结束点为同一个顶点。若这条路径为简单路径则这个回路或环也叫**简单回路**或**简单环**。
8. **连通、连通图和连通分量**：对于无向图：两个顶点连通当且仅当它们存在路径。若任意两个顶点连通，则这个图是**连通图**。无向图$G$中的极大连通子图称为$G$的**连通分量**。
9. **强连通图和强连通分量**：对于有向图：若顶点$i$到顶点$j$有路径，则$i$到$j$连通。若有向图中任意两顶点都互相连通，则有向图是**强连通图**。有向图$G$中的极大强连通子图为$G$的强连通分量。
   在非强连通图中找强连通分量(*不如 `tarjan`*)：
   1. 找有向环。
   2. 扩展：如果某顶点到该环一点有路径且该环中任一顶点到这个顶点也有路径，则加入这个顶点。
10. **权和网**：边上带有权的图称为**带权图**，也称作**网**。

## 8.2图的存储结构和基本运算算法

### 8.2.1邻接矩阵存储方法

无需多言。

### 8.2.2邻接表存储方法

储存每个结点的出度，无需多言。

### 8.2.3图基本运算算法设计

略。

### 8.2.4其他存储方法

1. **十字链表**：(没怎么用过)

   <img src=".\pictures\image-20250204163340403.png">

   十字链表是一种用于表示有向图的存储结构。它的基本思想是将图的每条边表示为一个链表节点，同时在每个节点中维护两个链表指针：一个指向该边的起点，另一个指向该边的终点。这种结构适合处理具有有向边的图。

   **十字链表的特点**

   - 十字链表适用于有向图的表示，尤其是在有大量**弯曲的边**和**边的反向遍历**操作时。
   - 该结构的优点是能同时高效地表示**从某顶点出发的所有边**和**指向某顶点的所有边**。
   - 它通过交叉链表的方式，避免了对边进行重复存储。

   **十字链表的结构**

   1. **顶点链表**：每个顶点都有一个指向它的出边的链表（**出度链表**）和一个指向它的入边的链表（**入度链表**）。
   2. **边结点**：每个边结点包含两个指针，一个指向该边的**起点**，另一个指向该边的**终点**。

   ```c++
   struct EdgeNode{
       int vertex;//该边的终点
       EdgeNode* next;//下一条边
   };
   struct VertexNode{
       EdgeNode* firstOut;//出度链表的头指针
       EdgeNode* firstIn;//入度链表的头指针
   };
   class Graph{
   public:
       vector<VertexNode> adjList;//图的邻接表
       int vertexCount,edgeCount;//顶点数和边数
       Graph(int v){
           vertexCount=v;
           adjList.resize(v);
           edgeCount=0;
       }
       void addEdge(int start,int end){
           EdgeNode* edge1=new EdgeNode{end,adjList[start].firstOut};
           adjList[start].firstOut=edge1;
           EdgeNode* edge2=new EdgeNode{start,adjList[end].firstIn};
           adjList[end].firstIn=edge2;
           edgeCount++;
       }
   };
   ```

2. **邻接多重表**：

<img src=".\pictures\image-20250204164203164.png">

邻接多重表（也称为多重邻接表）是一种扩展的邻接表结构，用于表示包含**多重边**或**自环**的图。在普通的邻接表中，每个顶点的邻接表仅包含指向该顶点的**一条边**，而在邻接多重表中，邻接表每个节点会包含多条边。

**邻接多重表的特点**

- 适用于**有重边**和**有自环**的图。
- 每个顶点的邻接表不仅仅存储指向邻居顶点的单一边，而是存储指向所有邻居顶点的边（如果图中存在多条边，或者一个顶点和其自身之间有边）。
- 该结构可以有效地表示多重边（即相同顶点之间有多条边）和自环（即一个顶点和自己之间的边）。

**邻接多重表的结构**

1. **邻接表的链表结构**：每个顶点在邻接多重表中有一个链表，这个链表包含多个边节点。
2. **每个边节点**：边节点包含两个部分：
   - **目标顶点**（即边的另一个端点）
   - **边的权值**（如果是加权图）

```c++
struct EdgeNode{
    int vertex;
    EdgeNode* next;
    int weight;
};
struct VertexNode{
    EdgeNode* firstEdge;
};
class Graph{
public:
    vector<VertexNode> adjList;
    int vertexCount,edgeCount;
    Graph(int v){
        vertexCount=v;
        adjList.resize(v);
        edgeCount=0;
    }
    void addEdge(int start,int end,int weight=0){
        EdgeNode* edge=new EdgeNode{end,adjList[start].firstEdge,weight};
        adjList[start].firstEdge=edge;
        edgeCount++;
    }
    void addUndirectedEdge(int start,int end,int weight=0){
        addEdge(start,end,weight);
        addEdge(end,start,weight);
    }
};

```

## 8.3图的遍历

### 8.3.1图的遍历的概念

从任意顶点开始每个顶点仅访问一次的遍历。

### 8.3.2深度优先遍历

栈，无需多言。

### 8.3.3广度优先遍历

队列，无需多言。

### 8.3.4非连通图的遍历

对于各个连通分量分别选择初始点进行遍历。其中有向图中可能要再选择初始点。

### 8.3.5图遍历算法的应用

随机应变。

## 8.4生成树和最小生成树

### 8.4.1生成树的概念

一个连通图的**生成树**是一个极小连通子图，其中含有图中的全部顶点和构成一棵树的$n-1$条边。

如果在一棵生成树上添加任何一条边，必定构成一个环。

**图的所有生成树中具有边上的权值之和最小的树称为图的最小生成树**。

### 8.4.2无向图的连通分量和生成树

事实上，如果记录一次合法的**深度优先遍历**经过的边和结点，可以得到一棵生成树，称为**深度优先生成树**，相应地，如果记录一次合法的**广度优先遍历**经过的边和结点，可以得到一棵生成树，称为**广度优先生成树**。

对于非连通图，各个连通分量的生成树组成非连通图的**生成森林**。

### 8.4.3Prim算法

设$G=(V,E)$是一个具有$n$个顶点的带权连通图，$T=(U,TE)$是$G$的最小生成树，其中$U$是$T$的顶点集，$TE$是$T$的边集，则由$G$构造从起始点$v$出发的最小生成树$T$的步骤如下：

1. 初始化$U=\{ v\}$，以$v$到其他顶点的所有边为侯选边。
2. 重复以下步骤$(n-1)$ 次，使得其他$(n-1)$个顶点被加入到$U$中。
   ①从侯选边中挑选权值最小的边加入$TE$，设该边在$V-U$中的顶点是$k$，将$k$加入$U$中；
   ②考查当前$V-U$中的所有顶点$j$，修改侯选边，若$(k,j)$的权值小于原来和顶点$j$关联的侯选边，则用$(k,j)$取代后者作为侯选边。

参考<a href="./static/res/prim.cpp" download>prim.cpp</a>

使用邻接矩阵且不加优化的时间复杂度为$O(n^2)$

使用邻接表且加堆优化时间复杂度为$O(mlogn)$

### 8.4.4Kruskal算法

设$G=(V,E)$是一个具有$n$个顶点的带权连通无向图，$T=(U,TE)$是$G$的最小生成树，则构造最小生成树的步骤如下：

1. 置$U$的初值为$V$(即包含有$G$中的全部顶点)，$TE$的初值为空集(即图$T$中的每一个顶点都构成一个分量)。
2. 将图$G$中的边按权值从小到大的顺序依次选取，若选取的边未使生成树$T$形成回路，则加入$TE$，否则舍弃，直到$TE$中包含$(n-1)$条边为止。

参考<a href="./static/res/kruskal.cpp" download>kruskal.cpp</a>

未经优化的算法时间复杂度为$O(m^2)$

使用堆优化的算法时间复杂度为$O(mlogm)$

## 8.5最短路径

### 8.5.1路径的概念

不妨把不带权图看作边权都为1的带权图，则对于带权图，从一个顶点到另一个顶点所有路径长度最短的那条路径就是**最短路径**。

### 8.5.2从一个顶点到其余各顶点的最短路径

**$Dijkstra$算法**：

1. 初始时$S$只包含源点，即$S=\{v\}$，源点$v$到自己的距离为$0$。$U$包含除源点$v$以外的其他顶点，源点$v$到$U$中任一顶点$i$的最短路径长度为边上的权(若源点$v\rightarrow i$有边$<v,i>$或$\infty$(若源点$v\rightarrow i$没有边)。
1. 从$U$中选取一个顶点$u$，使源点$v\rightarrow u$的最短路径长度为最小，然后把顶点$u$加入$S$中。
1. 以顶点$u$为新考虑的中间点，修改源点$v$到$U$中所有顶点的最短路径长度，称之为路径调整(松弛)。
1. 重复2和3，直至$S$包含所有的顶点。

参考<a href="./static/res/dijkstra.cpp" download>dijkstra.cpp</a>

$Dijkstra$不适合处理负权图。

不加优化的$Dijkstra$时间复杂度为$O(n^2+m)=O(n^2)$。

堆优化的$Dijkstra$时间复杂度为$O(mlogn)$。

**$Bellman-Ford$算法**：

不断尝试对图上每一条边进行松弛。我们每进行一轮循环，就对图上所有的边都尝试进行一次松弛操作，当一次循环中没有成功的松弛操作时，算法停止。

$Bellman-Ford$适用于处理负权图并可以对最短路不存在的情况进行判断。

参考<a href="./static/res/bellman-ford.cpp" download>bellman-ford.cpp</a>

常规时间复杂度为$O(nm)$。

**$SPFA$算法**：

很多时候我们并不需要那么多无用的松弛操作。

很显然，只有上一次被松弛的结点，所连接的边，才有可能引起下一次的松弛操作。

那么我们用队列来维护哪些结点可能会引起松弛操作，就能只访问必要的边了。

参考<a href="./static/res/SPFA.cpp" download>SPFA.cpp</a>

大多数情况下$SPFA$跑得很快，但其最坏情况下的时间复杂度为$O(nm)$。

### 8.5.3每对顶点之间的最短路径

**$Floyd$算法**：

设有向图$G=(V,E)$采用邻接矩阵$g$表示，另外设置一个二维数组$A$用于存放当前顶点之间的最短路径长度，即分量$A[i][j]$表示当前$i\rightarrow j$的最短路径长度。$Floyd$算法的基本思想是递推产生一个矩阵序列$\boldsymbol A_0,\boldsymbol A_1,\dots,\boldsymbol A_k,\dots,\boldsymbol A_{n-1}$，其中$\boldsymbol A_k[i][j]$表示$i\rightarrow j$的路径上所经过的顶点编号不大于$k$的最短路径长度。

初始时有$\boldsymbol A_{-1}[i][j]=g.edges[i][j]$。若$\boldsymbol A_{k-1}[i][j]$已求出，现在考查顶点$k$，求$i\rightarrow j$的路径上所经过的顶点编号不大于$k$的最短路径长度$\boldsymbol A_k[i][j]$，此时$i\rightarrow j$的路径有两条。

1. 在考查顶点$k$之前求出其最短路径长度为$\boldsymbol A_{k-1}[i][j]$(若没有这样的路径，则取为$\infty$)。
2. 考查顶点$k,i\rightarrow j$存在一条经过顶点$k$的路径，分为两段，即$i\rightarrow k$和$k\rightarrow j$，其长度为$\boldsymbol A_{k-1}[i][k]+\boldsymbol A_{k-1}[k][j]$，(若没有这样的路径，则取为$\infty$)。

选择较短的那一条。

$Floyd$适合负权图但不能有负权回路。

参考<a href="./static/res/floyd.cpp" download>floyd.cpp</a>

时间复杂度为$O(n^3)$。

## 8.6拓补排序

**在一个有向图中找一个拓补序列的过程称为拓补排序**。

比较简单，每次将入度为零的点入队，减少其指向的点的入度即可。

## 8.7AOE网与关键路径

### 8.7.1相关概念

若用$DAG$(有向无环图)描述工程的预计进度，以顶点表示事件，有向边表示活动，边权表示时间。图中入度为0的顶点表示工程的**开始事件**，出度为0的顶点表示工程**结束事件**，这样的有向图就是边表示活动的网($AOE$网)。

$AOE$网中入度为0的点称为**源点**，出度为0的顶点称为**汇点**。必要时可以添加虚拟源点和虚拟汇点。

**在$AOE$网中，从源点到汇点的所有路径中具有最大路径长度的路径称为关键路径**。

**关键路径上的活动称为关键活动**。

### 8.7.2求AOE网的关键活动

1. 通过拓补排序求得每个点的$ve$值。顺便通过拓补排序判断是否存在环。求$ve$值的方法如下：
   设$S$为指向点$j$的所有点的集合，对于所有$i\in S$，$D_{i,j}$为点$i$到点$j$的边权大小。
   则$ve(j)=max(ve(i)+D_{i,j}),i\in S$。
   特别地，$ve(源点)=0$
2. 通逆拓补序求得每个点的$vl$值。求$vl$值的方法如下：
   设$S$为点$j$指向的所有点的集合，对于所有$i\in S$，$D_{j,i}$为点$j$到点$i$的边权大小。
   则$vl(i)=min(vl(j)+D_{j,i}),i\in S$。
   特别地，$vl(汇点)=ve(汇点)$。
3. 其中满足$ve$值等于$vl$值的点就是关键活动点。

# 9.查找

## 9.1查找的基本概念

在查找表的定义下：**查找**的定义是给定一个值$k$，在含有$n$个元素的表中找出关键字等于$k$的元素。

若在查找的同时对表做修改操作(如插入和删除)，则相应的查找表称为**动态查找表**。若在查找中不涉及表的修改操作，则相应的查找表称为**静态查找表**。
若整个查找过程都在内存中进行，则称之为**内查找**；反之，若查找过程的需要访问外存，则称之为**外查找**。
在查找运算中时间主要花费在关键字的比较上，把平均需要和给定值*k*进行比较的关键字次数称为**平均查找长度**，其定义如下：
$$
ASL=\sum_{i=1}^np_ic_i
$$
$n$是查找表中元素的个数。$p_i$是查找第$i$个元素的概率，通常假设$p_i=\frac{1}{n}(1\le i\le n)$，$c_i$是找到第$i$个元素所需的关键字比较次数。

$ASL$分为$ASL_{成功}$和$ASL_{不成功}$。

对于$ASL_{成功}$，有
$$
\sum_{i-1}^np_i=1
$$
对于$ASL_{不成功}$，假设共有$m$种查找失败情况，则
$$
\sum_{i=1}^mq_i=1
$$
$ASL$越大，则算法的时间性能越差，反之则反之。

## 9.2线性表的查找

### 9.2.1顺序查找

无需多言。

$ASL_{成功}=\frac{n\times (n+1)}{2\times n}=\frac{n+1}{2}$

### 9.2.2折半查找

 无需多言。

$ASL_{成功}=log_2(n+1)-1$

### 9.2.3索引存储结构和分块查找

**索引存储结构**：

在存储数据的同时还建立附加的索引表。

**分块查找**：

要求整个表是分块有序的。

用二分查找查询所在块，再用顺序查找查询块中元素。

通常取块的长度为$\sqrt{n}$最佳

$ASL_{成功}=log_2(\sqrt{n}+1)+\frac{n+1}{2}-1$

## 9.3树表的查找

### 9.3.1二叉排序树

**二叉排序树**又称二叉搜索树，其定义为二叉排序树或者是空树，或者是满足以下性质的二叉树。

1. 若根结点的左子树非空，则左子树上的所有结点关键字均小于根结点关键字。
2. 若根结点的右子树非空，则右子树上的所有结点关键字均大于根结点关键字。
3. 根结点的左、右子树本身又各是一棵二叉排序树。

上述性质简称二叉排序树性质(`BST`性质),故二叉排序树实际上是满足`BST`性质的二叉树。也就是说，二叉排序树是在二叉树基础上增加了结点值的约束。

**二叉排序树的插入和创建**：

这个比较简单。

**二叉排序树的查找**：

这个也比较简单。

**二叉排序树的删除**：

1. 叶子结点：直接删。
2. 只有左子树或右子树：让唯一子树代替之。
3. 同时存在左右子树：让左子树中值最大的结点值与该结点值交换，删除左子树那个结点。

参考<a href="./static/res/BST.cpp" download>BST.cpp</a>

### 9.3.2平衡二叉树

本书主要指$AVL$树。

若一棵二叉树中每个结点的左、右子树高度最多相差1，则称此二叉树为**平衡二叉树**。

通过**平衡因子**来具体实现上述平衡二叉树的定义。

一个结点的平衡因子是该结点左子树的高度减去右子树的高度。

一个结点是平衡的当且仅当其平衡因子的取值为-1或0或1。

**若一棵二叉树的所有结点都是平衡的，称之为平衡二叉树**。

**平衡二叉树中插入结点的过程**：

1. **LL型调整**：当在$A$结点的左孩子(设为$B$结点)的左子树上插入结点，使得$A$结点的平衡因子由1变为2而引起不平衡。
   <img src=".\pictures\image-20250206173411641.png">

2. **RR型调整**：当在$A$结点的右孩子(设为$B$结点)的右子树上插入结点，使得$A$结点的平衡因子由-1变为-2而引起不平衡。
   <img src=".\pictures\image-20250206173613302.png">

3. **LR型调整**：当在$A$结点的左孩子(设为$B$结点)的右子树上插入结点，使得$A$结点的平衡因子由1变为2而引起不平衡。

   <img src=".\pictures\image-20250206173954771.png">

4. **RL型调整**：当在$A$结点的右孩子(设为$B$结点)的左子树上插入结点，使得$A$结点的平衡因子由-1变为-2而引起不平衡。

   <img src=".\pictures\image-20250206174202252.png">

**平衡二叉树中删除结点的过程**：

删除过程与二叉查找树一样，只是在最后增加一个**调整**步骤：

从被删除的结点向根结点方向查找，查找到失去平衡的结点时进行与插入相同的调整。

**平衡二叉树的查找**：

与二叉查找树完全相同。

最坏情况下，普通二叉查找树的查找性能为$O(n)$。

$AVL$树的平均查找长度为$O(log_2n)$，对应查找算法的时间复杂度为$O(log_2n)$。

实际上，折半查找对应的判断树就是一棵平衡的二叉排序树。

参考<a href="./static/res/AVL.cpp" download>AVL.cpp</a>

### 9.3.3B_树

$B$树是一种自平衡的搜索树，能够保持数据有序。这种数据结构能够让查找数据、顺序访问、插入数据及删除的动作，都在对数时间内完成。$B$树的每个结点可以拥有两个以上的子结点，因此$B$树是一种多路搜索树。

假设数据量达到亿级别，主存存储不下，是能以块的形式从磁盘读取数据。$B$树的主要目的就是减少磁盘的$I/O$操作。

在$B$树中，有两种结点：

1. 内部结点：存储了数据以及指向其子结点的指针。
2. 叶子(外部)结点：与内部结点不同的是，叶子结点只存储数据，并没有子结点。

一棵$m$阶$B$树或者是一棵空树，或者是满足下列要求的$m$叉树：

1. 每个结点最多有$m$个子结点。
2. 每一个非叶子结点(除根结点)最少有$\lceil\frac{m}{2}\rceil$个子结点。
3. 如果根结点不是叶子结点，那么它至少有两个子结点。
4. 有$k$个子结点的非叶子结点拥有$k-1$个元素，且升序排列，满足$k[i]<k[i+1]$。
5. 所有的叶子结点在同一层。

**$B$树的查找**：

$B$树中的结点包含有多个元素。假设需要查找的是$k$，那么从根结点开始，从上到下递归的遍历树。在每一层上，搜索的范围被减小到包含了搜索值的子树中。子树值的范围被它的父结点的元素确定。采用二分查找。

**$B$树的插入**：

1. 查找到关键字$k$的插入结点。
2. 若插入结点的关键字个数$<m-1$，把关键字$k$插入到该结点的合适位置上。
   若插入结点的关键字个数$=m-1$，把结点分裂，即创建一个新结点，将原结点中较大的一半关键字插入到新结点，中间位置关键字插入到双亲结点。

**B树的删除**：

**第一种策略**：定位并删除元素，然后调整树使它满足约束条件。

首先，查找$B$树中需删除的元素，如果该元素在$B$树中存在，则将该元素在其结点中进行删除；删除该元素后，首先判断该元素是否有左右孩子结点。如果有，则上移孩子结点中的某相近元素（左孩子最右边的结点或右孩子最左边的结点）到父结点中，然后是移动之后的情况；如果没有，直接删除。

1. 某结点中元素数目小于$\lceil m/2\rceil-1$，则需要看其某相邻兄弟结点是否丰满。
2. 如果丰满(结点中元素个数大于$\lceil m/2\rceil -1$)，则向父结点借一个元素来满足条件。
3. 如果其相邻兄弟都不丰满，即其结点数目等于$\lceil m/2\rceil -1$，则该结点与其相邻的某一兄弟结点进行合并成一个结点。

**第二种策略**：从上到下处理这棵树，在进入一个结点之前，调整树使得之后一旦遇到了要删除的元素，它可以被直接删除而不需要再进行调整。

代码中采用第一种策略。

参考<a href="./static/res/BT.cpp" download>BT.cpp</a>

### 9.3.4B+树

作为$B$树的一种变形，一棵$m$阶$B+$树满足：

1. 每个分支结点最多有$m$棵子树。
2. 根节点或者没有子树，或者最少有两棵子树。
3. 除根结点以外，其它每个分支结点最少有$\lceil m/2\rceil$棵子树。
4. 有$n$棵子树的结点有$n$个关键字。
5. 所有叶子结点包含全部关键字及指向相应记录的指针，而且叶子结点按关键字大小顺序链接。
6. 所有分支结点中仅包含它的各个子结点中的最大关键字及指向子结点的指针。

**$B+$树的查找**

1. 直接从最小关键字开始进行顺序査找(通过`sqt`指针查找)。
2. 从$B+$树的根结点开始进行随机査找(通过`root`指针查找)。这种查找方式与$B$树的查找方法相似，只是在分支结点上的关键字与查找值相等时查找并不结束，要继续查到叶子结点为止，此时若查找成功，则按所给指针取出对应元素即可。因此,在$B+$树中不管查找成功与否，每次查找都是经过了一条从根结点到叶子结点的路径。

**$B+$树的插入**

$B+$树的插入与$B$树的插入操作相似，$B+$树的插入也是在叶子结点中进行的，当插入后结点中的关键字个数大于$m$时要分裂成两个结点，它们所含的键值个数分别为$\lceil (m+1)/2\rceil$和$\lfloor (m+1)/2\rfloor$，同时要使得它们的双亲结点中包含有这两个结点的最大关键字和指向它们的指针。若双亲结点的关键字个数大于$m$，应继续分裂，依此类推。

**$B+$树的删除**
$B+$树的删除也是在叶子结点中进行的，当叶子结点中的最大关键字被删除时，分支结点中的值可以作为“分界关键字”存在。若因删除操作而使结点中的关键字个数少于$\lceil m/2\rceil$，则从兄弟结点中调剂关键字或和兄弟结点合并，其过程和$B$树相似。

有点难搓，略。

## 9.4哈希表的查找

### 9.4.1哈希表的基本概念

又称散列表，设要存储的元素个数为$n$，设置一个长度为$m(m\ge n)$的连续内存单元，以每个元素的关键字$k_i(0\le i\le n-1)$为自变量，通过一个称为**哈希函数**的函数$h(k_i)$把$k_i$映射为内存单元的地址(或下标)$h(k_i)$，并把该元素存储在这个内存单元中，$h(k_i)$也称为**哈希地址**。这样的线性表称为哈希表。

当出现$k_i\ne k_j$且$h(k_i)=h(k_j)$的情况时认为出现**哈希冲突**。通常把这种具有不同关键字而具有相同哈希地址的元素称为**同义词**。

哈希查找性能主要与3个因素有关：

1. 与装填因子$\alpha$有关。所谓**装填因子**是指哈希表中已存入的元素数$n$与哈希地址空间大小$m$的比值,即$\alpha=n/m$。$α$越小，冲突的可能性就越小；$α$越大(最大可取1)，冲突的可能性就越大。另一方面，$α$越小，存储空间的利用率就越低；反之，存储空间的利用率也就越高。为了既兼顾减少冲突的发生，又兼顾提高存储空间的利用率这两个方面，通常使最终的$α$控制在$0.6\sim0.9$的范围内。
2. 与所采用的哈希函数有关。若哈希函数选择得当，就可以使哈希地址尽可能均会地分布在哈希地址空间上，从而减少冲突的发生；否则，若哈希函数选择不当，就可能使哈希地址集中于某些区域，从而加大冲突的发生。
3. 当出现哈希冲突时需要采取解决哈希冲突的方法，所以哈希查找性能也与解决冲突的方法有关。对于预先知道且规模不大的关键字集合，通常可以找到不发生冲突的哈希函数，从而避免出现冲突，使查找时间复杂度为$O(1)$，提高了查找效率，因此对频繁进行查找的关键字集应尽力设计一个完美的哈希数。

### 9.4.2哈希函数的构造方法

1. 直接定址法：$h(k)=k+c$
2. 除留余数法：$h(k)=k\mod p$
3. 数字分析法：例如取一组数的后两位作为哈希地址，或者取关键字平方后分布均匀的几位作为哈希地址，或者把关键字中的若干段作为一小组，把各小组折叠相加后分布均匀的几位作为哈希地址。

### 9.4.3哈希冲突的解决方法

1. 开放定址法：在冲突地址前后找空闲位置。

   **线性探测**：

   $d_0=h(k)$

   $d_i=(d_{i-1}+1)\mod m~~~~(1\le i\le m-1)$

   **平方探测**：
   
   $d_0=h(k)$
   
   $d_i=(d_0\pm i^2)\mod m~~~~(1\le i\le m-1)$
   **伪随机序列**：略。
   **双哈希函数**：略。

2. 拉链法：在冲突地址生成一个链表储存同义词。

- 拉链法处理冲突简单，无堆积现象，平均查找长度较短。
- 适合造表前无法确定表长的情况。
- 节省空间
- 更易删除结点。

### 9.4.4哈希表的运算算法

**开放定址法**：参考<a href="./static/res/hash1.cpp" download>hash1.cpp</a>

**拉链法**：参考<a href="./static/res/hash2.cpp" download>hash2.cpp</a>

# 10.内排序

## 10.1排序的基本概念

1. **什么是排序**：

   就是排序。

2. **排序的稳定性**：
   经过排序后这些具有相同关键字的元素之间的相对次序保持不变，则称这种排序方法是稳定的。

3. **内排序和外排序**：

   在排序过程中，若整个表都放在内存中处理，排序时不涉及数据的内、外存交换，则称之为内排序；反之，若在排序过程中要进行数据的内、外存交换,则称之为外排序。内排序适用于元素个数不是很多的小表，外排序则适用于元素个数很多，不能一次将其全部元素放入内存的大表。内排序是外排序的基础，本章只讨论内排序。
   按所用的策略不同，内排序方法可以分为需要关键字比较和不需要关键字比较两类。需要关键字比较的排序方法有插入排序、选择排序、交换排序和归并排序等；不需要关键字比较的排序方法有基数排序等。

4. **基于比较的排序算法的性能**：
   对于$n$个元素排序结果有$n!$种情况，对应得判定树是一棵有$n!$个叶子结点的高度最小的二叉树，结点总数$=n_0+n_2=2n!-1$，则其高度为$h=\lceil log_22n!\rceil=\lceil log_2n!\rceil+1$，对应的关键字比较次数最多为$h-1=\lceil log_2n!\rceil$，又$\lceil log_2n!\rceil\approx nlog_2n$。
   所以排序的平均时间复杂度为$O(nlog_2n)$，即基于比较的排序算法最好的平均时间复杂度为$O(nlog_2n)$。

5. **排序数据的组织**：
   略。

## 10.2插入排序

### 10.2.1直接插入排序

无需多言。

稳定排序。

最快时间复杂度为$O(n)$

最坏时间复杂度为$O(n^2)$

平均时间复杂度为$O(n^2)$

### 10.2.2折半插入排序

 无需多言。

在直接插入排序基础上使用二分查找。

稳定排序。

平均时间复杂度为：
$$
\sum_{i=1}^{n-1}(log_2(i+1)-1+\frac{i}{2}+2)=O(n^2)
$$

### 10.2.3希尔排序

 考虑小于$n$的增量$d_t$，把表的元素分成$d_t$个组，将所有距离为$d_t$的倍数的元素放同一个组中，在同一个组中进行直接插入排序，再选取$d_{t+1},d_{t+1}<d_t$直至$d_m=1$。

不稳定排序。

平均时间复杂度有点难算，参考`OIwiki`的结果：

若间距序列为$H=\{2^k-1|k=1,2,\dots ,\lfloor log_2n\rfloor\}$(从大到小)，则希尔排序算法的时间复杂度为$O(n^{3/2})$。

若间距序列为$H=\{ k=2^p·3^q|p,q\in\mathbb N,k\le n\}$(从大到小），则希尔排序算法的时间复杂度为$O(nlog^2n)$。

## 10.3交换排序

### 10.3.1冒泡排序

无需多言。

稳定排序。

最快时间复杂度为$O(n)$

最坏时间复杂度为$O(n^2)$

平均时间复杂度为$O(n^2)$

### 10.3.2快速排序

选取数组中一个关键字(或者随机取一个关键字)，将不大于该关键字的元素和大于该关键字的元素分成两个子区间。对于每个子区间，又进行同样的排序，直到该子区间只有一个元素或不存在元素为止。

不稳定排序。

当初始序列比较有序，则算法的时间复杂度比较大，可能达到$O(n^2)$。

平均时间复杂度$O(nlog_2n)$。

## 10.4选择排序

### 10.4.1简单选择排序

无需多言。

不稳定排序。

平均时间复杂度为$O(n^2)$。

### 10.4.2堆排序

用堆结构排序。

堆嘛，如果是大根堆：

建立堆就是先塞成一棵完全二叉树，然后中序遍历把儿子结点中较大的关键字与当前结点交换。

取出堆顶元素后，把最后的元素移至堆顶，再进行建立时候的调整。

不稳定排序。

最好、最坏和平均时间复杂度都是$O(nlog_2n)$。

## 10.5归并排序

无需多言。

就是把排序表细分为多段，各自排序后合在一起。通常是二路合并。

稳定排序算法。

平均时间复杂度为$O(nlog_2n)$

三路归并可以是$O(nlog_3n)$，不过实现远远复杂。

## 10.6基数排序

无需多言。

就是按个位比较，十位比较...以此类推。

时间复杂度为$O(d(n+r))$，其中$d=\lfloor lg{最大元素}\rfloor+1$，$r$通常是10。

## 10.7各种内排序方法的比较和选择

<img src=".\pictures\image-20250207141451249.png">

# 11.外排序

## 11.1外排序概述

外存设备分为**顺序存取设备**和**直接存取设备**。

**磁带**是典型的顺序存取设备，通过读写头读写数据。检索和修改很不方便，主要用于处理很少需要修改的且进行顺序存取的信息。

**磁盘**是直接存取的外存设备，不仅能进行顺序存取，还能直接存取任何记录。存取速度比磁带快得多。

磁盘分为硬盘和软盘两种，硬盘的容量比软盘大得多，而且存取速度也比软盘快得多。

*目前磁盘多使用带有可移动式的磁头，整个磁盘由多个盘片组成，固定在同一轴上沿一个固定方向高速旋转，每个盘片包括上、下两个盘面，每个盘面用于存储信息，每个盘面有一个读写头，所有读写头是固定在一起同时同步移动的。在一个盘面上读写头的轨迹称为磁道，磁道就是磁面上的圆环。各个磁面上半径相同的磁道总和称为一个柱面。在一个磁道内又分为若干个扇面。一般情况下,把一次向磁盘写人或读出的数据称为一个物理块，一个物理块通常由若干个记录组成。对于磁盘而言，影响存取时间的因素有3个*：

1. ***搜索时间**(磁头定位到指定柱面所需要的时间)。*
2. ***等待时间**(磁头定位到磁道的指定扇区所需要的时间)。*
3. ***传送时间**(从磁盘或向碳盘传送一个物理块的数据所需要的时间)。*

外排序的基本方法是**归并排序**法：

1. **生成若干初始归并段(顺串)**：将一个文件(含待排序的数据)中的数据分段读人内存，在内存中对其进行内排序，并将经过排序的数据段(有序段)写到多个外存文件上。
2. **多路归并**：对这些初始归并段进行多遍归并，使得有序的归并段逐渐扩大，最后在外存上形成整个文件的单一归并段，也就完成了这个文件的外排序。

外排序的时间主要花费在内,外存数据的交换(对应存取时间)和内排序上。

## 11.2磁盘排序

### 11.2.1磁盘排序概述

对存放在磁盘中的文件进行排序属于典型的外排序称为**磁盘排序**。

可以通过读写数据块的次数来衡量存取时间。

磁盘中$F_{in}$文件包含待排序的数据，我们这样做：

1. 把$F_{in}$文件分块调入内存，产生若干个文件$F_1\sim F_n$，称为**顺串**。
2. 再次将$F_1\sim F_n$文件中的记录调入内存，通过相关归并算法产生一个有序文件$F_{out}$，从而达到数据排序的目的。

影响磁盘排序时间性能的主要因素：

1. 读写记录次数。
2. 关键字比较次数。

不同于内排序，磁盘排序中元素移动的次数相对上述两个因素可以忽略。

大致认为**磁盘排序时间=读写记录次数+关键字比较次数**。

### 11.2.2生成初始归并段

**置换-选择排序算法**：

1. 从待排序文件$F_{in}$中按内存工作区$WA$的容量(设为$w$)读入$w$个记录。设归并段编号$i=1$。
2. 从$WA$中选出关键字最小的记录$R_{min}$。
3. 将$R_{min}$记录输出到文件$F_i$中，作为当前归并段的一个记录。
4. 若$F_{in}$不空，则从$F_{in}$中读入下一个记录到$WA$中代替刚输出的记录。
5. 在$WA$工作区中所有大于或等于$R_{min}$的记录中选择出最小记录作为新的$R_{min}$，转第3步，直到选不出这样的$R_{min}$。
6. 置$i=i+1$，开始一个新的归并段。
7. 若$WA$工作区已空，则初始归并段已全部产生，算法结束；否则转第2步。

如下例：

<img src=".\pictures\image-20250209165510222.png">

可以证明，如果输入文件中的记录按关键字随机排列，所得到的初始归并段的平均长度为内存工作区大小的两倍。

算法的时间复杂度为$O(nw)$。

这种操作可以使用败者树来实现，使得该算法时间复杂度优化到$O(nlog_2w)$。

### 11.2.3多路平衡归并

 在$k$路归并中，如果基于简单选择排序方法，需要进行$k-1$次关键字比较。每趟归并$u$个记录需要做$(u-1)\times (k-1)$次关键字比较，则$s$趟归并总共需要的关键字比较次数为：
$$
\lceil log_2m\rceil\times(u-1)\times(k-1)/\lceil log_2k\rceil
$$
所以对$k$的选择有待斟酌。

**利用败者树的$k$路平衡归并**

**败者树**是一棵有$k$个叶子结点的完全二叉树(可将大根堆看成胜者树)，其中叶子结点存储参与归并的记录，分支结点存放关键字对应的段号。所谓败者是两个记录比较时关键字较大者，胜者是两个记录比较时关键字较小者。
**建立败者树**是采用类似于堆调整的方法实现的，初始时令所有的分支结点指向一个含最小关键字($MINKEY$)的叶子结点，然后从各叶子结点出发调整分支结点为新的败者即可。

对$k$个有序段进行 **$k$路平衡归并** 的方法如下：

1. 取每个输入有序段的第一个记录作为败者树的叶子结点，建立初始败者树：两两叶子结点进行比较，在双亲结点中存放比较的败者(关键字较大者)，而让胜者去参加更高一层的比赛，如此在根结点之上胜出的“冠军”是关键字最小者。
2. 将胜出的记录写至输出归并段，在对应的叶子结点处补充其输入有序段的下一个记录，若该有序段变空，则补充一个大关键字(比所有记录关键字都大，设为$k_{max}$)的虚记录。
3. 调整败者树，选择新的关键字最小的记录：从补充记录的叶子结点向上和双亲结点的关键字比较，败者留在该双亲结点，胜者继续向上，直到树的根结点，最后将胜者放在根结点的双亲结点中。
4. 若胜出的记录关键字等于$k_{max}$，则归并结束；否则转第2步继续。

参考<a href="./static/res/loserTree.cpp" download>loserTree.cpp</a>

**初始化时间复杂度**：$O(k)$，初始化树结构并填充初始数据。

**更新时间复杂度**：每次更新最多需要$O(logk)$的时间来更新败者树。

**查找最小值**：$O(1)$，直接访问根节点即可。

**弹出最小值**：$O(logk)$​，需要更新败者树。

关键字比较次数与$k$无关，总的内部归并时间不会随$k$的增大而增大。但$k$越大，归并树的高度较小，读写磁盘的次数也较少。
因此，当采用败者树实现多路平衡归并时，只要内存空间允许，增大归并路数$k$会有效地减少归并树的高度，从而减少读写磁盘次数，提高外排序的速度。

### 11.2.4最佳归并树

为了提高归并的时间效率，我们有必要对各归并段进行合理的搭配组合。按照最佳归并树的设计可以使归并过程中对外的读写次数最少。

归并树是描述归并过程的$k$次树。因为每一次做$k$路归并都需要有$k$个归并段参加因此归并树是只包含度为$0$和度为$k$的结点的标准$k$次树。

所有归并树中最小带权路径长度$WPL$的归并树称为**最佳归并树**。

为了使归并树成为一棵标准$k$次树，可能需要补入**虚段**(记录个数为$0$的归并段)。

补虚段的原则为：设参加归并的初始归并段有$m$个，做$k$路平衡归并。因为归并树是只有度为0和度为$k$的结点的正则$k$次树，设度为0的结点有$m$个(因为初始归并段有$m$个,对应归并树的叶子结点就有$m$个)，度为$k$的结点有$m_k$个，则有$m=(k-1)m_k+1$。因此，可以得出$m_k=(m-1)/(k-1)$。如果该除式能整除，即$(m-1)mod(k-1)=0$，则说明这$m$个叶子结点正好可以构造$k$次归并树，不需加虚段，此时分支结点有$m_k$个。如果$(m-1)\mod (k-1)=u≠0$，则需要补入$k-u-1$个虚段，这样就可以建立归并树了。

因此,最佳归并树构造步骤如下：

1. 若$(m-1)mod(k-1)≠0$，则需附加$(k-1)-(m-1)mod(k-1)$个长度为0的**虚段**，以使每次归并都可以对应$k$个段。
2. 按照哈夫曼树的构造原则(权值越小的结点离根结点越远)构造最佳归并树。

对应的读写记录次数为$WPL\times 2$。

参考<a href="./static/res/optimalMergeTree.cpp" download>optimalMergeTree.cpp</a>

## 11.3磁带排序

### 11.3.1多路平衡归并排序

**与磁盘的多路平衡归并排序过程基本上相同**。

不同之处在于：磁盘排序要充分考虑归并段的分布状况，因为磁带是顺序存取的。

1. 把输入文件分段读入内存并进行内排序，生成初始归并段，然后将这些归并段轮流写到磁带$T_1$ 和$T_2$上。
2. 采用二路归并，把$T_1$上的各归并段与$T_2$上的各归并段归并(之后$T_1$和$T_2$上的记录仍存在，但不再有用，可将它们看成空磁带)，并把所产生的较大归并段轮流分布到$T_3$和$T_4$上(若输入文件带需要保留，则在第1步完成后把输人文件带从$T_4$上卸下来，换上工作带)。其中$T_3$上的归并段1是$T_1$上的归并段1和$T_2$上的归并段2归并的结果，$T_3$上的归并段3是$T_1$上的归并段5和$T_2$上的归并段6归并的结果，$T_4$上的归并段2是$T_1$上的归并段3和$T_2$上的归并段4归并的结果。
3. 把$T_3$上的归并段1和$T_4$上的归并段2进行归并，并将结果放到$T_1$上。
4. 把$T_1$上的归并段1和$T_3$上的归并段3归并，并把结果放到$T_2$，这就是排好序的文件。

**排序的时间主要取决于对数据的扫描遍数**。

$k$路归并至少需要$k+1$台磁带，其中$k$台作为输入带，另一台为归并后输出之用。但是这样需要对输出带再做一遍扫描，把输出带上的各归并段重新分配到$k$台磁带上，以便作为下一级归并使用。

若使用$2k$台磁带，则可避免这种再分配扫描。把k台作为输入带，其余k台作为输出带。在下一级归并时输入带与输出带的作用互相对换。

### 11.3.2多阶段归并排序

**多阶段归并排序**实际上是**多路非平衡归并排序**，即各条带上的归并段不再保持平衡分布，它在$k$路归并中仅使用$k+1$条磁带就可避免在多路平衡归并排序法中遇到的重新分布有序段的问题。

1. 开始时,初始归并段不平衡地分配在前$k$条磁带上,第$k+1$条磁带作为输出带，开始为空。
2. 每一步归并只是部分记录参加，归并段最少的带在本步归并完成后便成为空带，作为下一步归并的输出带。这样$k+1$条磁带将轮流成为输出带，直到整个文件为一个排序文件为止。

**为使归并躺数最少，必须合理分配各磁带上初始归并段段数**。

分析得到：利用$(k+1)$台磁带机做$k$路多阶段归并时，总段数$T$满足(其中$F_i^{(k)}$为$k$阶$Fibonacci$序列中的第$i$项)：
$$
T_1=F_i^{(k)}+F_{i-1}^{(k)}+\dots +F_{i-(k-2)}^{(k)}+F_{i-(k-1)}^{(k)}
$$
$$
T_2=F_i^{(k)}+F_{i-1}^{(k)}+\dots +F_{i-(k-2)}^{(k)}\\
$$
$$
\dots\\
$$
$$
T_{k-1}=F_i^{(k)}+F_{i-1}^{(k)}\\
$$
$$
T_k=F_i^{(k)}\\
$$
$$
T=T_1+T_2+\dots T_k=[kF_i^{(k)}+(k-1)F_{i-1}^{(k)}+\dots +2F_{i-(k-2)}^{(k)}+F_{i-(k-1)}^{(k)}]
$$
枚举求得$i$，一共需要进行$i-k+2$个阶段的归并。

每个阶段每个磁带机上的段数减去除空的磁带机外最少的磁带段数，空的磁带机加上该段数。

# 12.文件

## 12.1文件的基本概念

### 12.1.1什么是文件

**文件**是性质相同的记录的集合，数据量通常很大，被放置在外存上。

数据结构中所讨论的文件主要是数据库意义上的文件，而不是操作系统意义上的文件。是有结构的记录集合。

**记录**是文件中存取的基本单位，**数据项**是文件可使用的最小单位。

数据项有时也称为字段，其值能唯一标识一个记录的数据项或数据项的组合称为**主关键字**，其他不能唯一标识一个记录的数据项则称为**次关键字**。

文件可以分为单关键字文件和多关键字文件。

也可以分为定长文件和不定长文件，取决于文件中记录含有的信息长度相同与否。

文件结构也包括**逻辑结构**、**存储结构**以及在**文件上的各种操作(运算)**。文件的操作定义在逻辑结构上，操作的具体实现要在存储结构上。

### 12.1.2文件的逻辑结构及操作

文件各个记录之间存在着逻辑关系，形成了一种**线性结构**。

文件上的操作包括：**检索**和**维护**。

**文件检索**就是在文件中查找满足给定条件的记录，它既可以按记录的逻辑号(即记录存人文件时的顺序编号)查找，也可以按关键字查找。

**文件维护**主要是指对文件进行记录的插入、删除及修改等更新操作。此外，为了提高文件的效率，还要进行再组织操作、文件被破坏后的恢复操作，以及文件中数据的安全保护等。

### 12.1.3文件的存储结构

指文件在外存上的组织方式。采用不同的组织方式就得到了不同的存储结构。

基本的组织方式有：**顺序组织**、**索引组织**、**哈希组织**和**链式组织**。

## 12.2顺序文件

**顺序文件**是指按记录进入文件的先后顺序存放、其逻辑顺序跟物理顺序一致的文件。若顺序文件中的记录按其主关键字有序，则称此顺序文件为**顺序有序文件**。否则称为**顺序无序文件**。为了提高检索效率，经常将顺序文件组织成有序文件。

存储在顺序存取存储器上的文件都只能是**顺序文件**，这类顺序文件只能按**顺序查找法**存取。

存储在直接存取存储器上的顺序文件还可以用**分块查找法**或**二分查找法**进行存取。其中后者只适合较小的文件，否则磁头来回移动增加寻查时间。

顺序文件不能按顺序表那样的方法进行插入、删除和修改。因此数据库系统总会产生很多临时文件

顺序文件的主要优点是**连续存取的速度较快**。多路存储设备上其他用户可能驱使磁头移向其他柱面，因此顺序文件多用于磁带。

## 12.3索引文件

指明逻辑记录和物理记录之间的一一对应关系的表称为**索引表**，它和主文件一起构成的文件称为**索引文件**。

索引表必须按主关键字有序，而主文件本身可以有序或无序。有序则称为**索引顺序文件**，无序则称为**索引非顺序文件**。

在**索引非顺序文件**中，建立的索引表称为**稠密索引**。而在**索引顺序文件**中则称为**稀疏索引**。

索引表和主文件一起形成**索引文件**。

**检索**：

1. 将外存上含有索引区的物理块送入内存，查找所需记录的物理地址。
2. 再将含有该记录的物理块送入内存。

**更新**：

- 在插入时将插入记录置于数据区的末尾，并在索引表中插入索引项。
- 在删除时删去相应的索引项。
- 若修改主关键字，则同时修改索引表。

当索引表太大以至于一个物理块容纳不下，可以为索引表建立一个索引，称为**查找表**。 

### 12.3.1ISAM文件

ISAM是**索引顺序存取方法**。ISAM文件是一种采用静态索引结构的磁盘存取文件，包括：

1. **基本数据区**：由一个或多个柱面组成,文件的记录按关键字有序存放于柱面的每个磁道上。

2. **溢出区**：每个柱面都开一个溢出区，为插入记录而设。
   当一个磁道存满记录以后，如果要在该磁道插入记录，就将该磁道的最后一个记录移至溢出区，再将新记录插在此磁道的适当位置。每个磁道的溢出数据在溢出区中组成链表。

3. **多级索引**：
   1)**磁道索引**：包括**基本索引项**(本磁道的最大关键字及起始地址)和**溢出索引项**(本磁道溢出记录的最大关键字及本磁道溢出区首地址)。
   2)**柱面索引**：索引项包含柱面中的最大关键字和该柱面磁道索引的起始地址。
   3)**主索引**：主索引是柱面索引的索引。每个索引项包含柱面索引中一组记录的最大关键字及该柱面索引组的起始地址。检索时由高级索引到低级索引逐级查找，找到待查记录所在的磁道后再到此磁道中查找待查记录。

4. **柱面**：包括**磁道索引区**、**基本区**和**溢出区**。

   磁道索引区存放该柱面的磁道索引，通常记为$T_0$。

   基本区存放主文件的记录，通常从$T_1$开始记若干项。

   溢出区由该柱面基本区的各个磁道共享。

5. **磁道索引项**：包括**基本索引项关键字**、**基本索引项指针**、**溢出索引项关键字**和**溢出索引项指针**。
   基本索引项关键字$\rightarrow$磁道在基本区中最末一个记录的关键字(即该磁道的最大关键字)。
   基本索引项指针$\rightarrow$磁道中第一个记录在基本区中的位置。
   溢出索引项关键字$\rightarrow$对应溢出链表的最大关键字。
   溢出索引项指针$\rightarrow$溢出链表的头指针。

6. **柱面索引项**：包括**关键字**和**指针**。
   关键字$\rightarrow$柱面(即对应磁道索引块)中最后一个记录的关键字(即该柱面的最大关键字)。
   指针$\rightarrow$柱面上的磁道索引首地址。

<img src=".\pictures\image-20250210132559686.png">

当有新的记录插入时需要重组某个磁道的记录，并将该磁道最后一个记录移人该柱面的溢出链表中,同时修改对应磁道索引的基本索引项和溢出索引项内容。

<img src=".\pictures\image-20250210133320173.png">

删除记录的操作只要找到待删除的记录，在其存储位置上加一个删除标志即可。

查询记录只需按照索引依次顺序查询即可。

ISAM文件多次增删后大量记录进入溢出区，在基本区又浪费了很多空间，需要周期性整理：

把记录读入内存重新排列复制成一个新的ISAM文件，填满基本区而空出溢出区。

### 12.3.2VSAM文件

VSAM是**虚拟存储存取方法**。VSAM文件是一种采用虚拟存取方法的文件，其存储单位是控制区间和控制区域，这是一些逻辑存储单位，与柱面、磁道等存储单位无必然联系。

也采用**索引顺序文件组织方式**。且VSAM采用$B+$树的动态索引结构。

1. **数据集**：一个结点称为一个控制区间,它是`I/0`操作的一个基本单位。文件的记录存放于数据集中。一个控制区间除存放一个或多个记录以外，还包含有记录的控制信息和区间的控制信息，且每个控制区间留有空间，为插入记录时备用。
2. **顺序集**：存放每个控制区间的索引项，一个索引项包含该控制区间的最大关键字和指向区间的指针。若于个控制区间的索引项组成顺序集中的一个结点，结点之间用指针链接，使整个顺序集形成一个链表。顺序集中一个结点和与之对应的控制区间组成一个控制区域。
3. **索引集**：每个顺序集的结点又在其上一层的结点中建立索引，且逐层向上建立索引，每个索引项都是由下层若干个结点的最大关键字和指向这些结点的指针组成。这些上层的索引组成了索引集。它们是$B+$树的非终端结点，与顺序集共同构成一棵 B+树，作为文件的索引部分。

<img src=".\pictures\image-20250210140728318.png">

- VSAM文件记录都存放在数据集中(其中的一个结点就是一个控制区间)。
- 控制区间大小视文件大小而定，但同一文件中大小需相同。
- 顺序集和索引集构成一棵$B+$树。
- 每个控制区间在顺序集中都有一个**索引项**，其关键字为控制区间中记录的最大关键字，其指针为该控制区间的首地址。顺序集中的一个结点和对应的若干个控制区间组成的部分称为**控制区域**。每个控制区间可看作一个逻辑磁道，每个控制区域可看作一个逻辑柱面，而控制区间相当于一个磁道。
- 记录插入：不填满控制区间或者留有一些全空的备用区间，插入时：
  1)可能要修改顺序集中索引项。
  2)可能要进行后移使得区间元素有序。
  3)元素已满，要进行区间的分裂，并修改索引。
  4)控制区域要分裂，对应的顺序集中结点也分裂。

相比ISAM，VSAM有优点：

1. 动态地分配和释放存储空间。
2. 不需要对文件进行重组。
3. 插入新记录后对新记录的查找时间和对原有记录的查找时间相同。

## 12.4哈希文件

类似于哈希表。

磁盘上的若干个文件记录组成一个存储单位，称为**桶**。

处理溢出主要采用**链地址法**：将溢出文件放入溢出桶中。

通常希望溢出桶和基桶最好在同一柱面上。

**查找**：顺序查找记录。

**删除**：对被删记录做删除标记。

优点：

1. 文件随机存放。
2. 记录不需进行排序。
3. 插入、删除方便。
4. 存取速度快。
5. 不需要索引区，节省存储空间。

缺点：

1. 只能按关键字随机存取。
2. 仅限于简单询问，并且在经过多次插入、删除后文件结构可能不合理，需要重新组织文件。

## 12.5多关键字文件

### 12.5.1多重表文件

一个顺序文件，把具有相同次关键字的记录链接成一个链表，并将此链表的头指针、链表长度及此关键字作为索引表的一个索引项。

**查找**：先查询索引表，再在主文件中读出待查记录信息。

**插入**：将新纪录插在链表头指针之后。

**删除**：需要在每个次关键字的链表中删去该记录。

### 12.5.2倒排文件

与多重表文件的区别是直接列出记录的物理地址或记录号。

相比之下检索更快，但难以维护。

# 13.采用面向对象的方法描述算法

参考附赠源文件。
        </textarea>
        <script>
            $m.innerHTML = marked.parse($t.value);
            window.MathJax && MathJax.typeset();
        </script>
        <!-- 评论展示容器 -->
         <div class="container" style="max-width: 900px; padding: 20px; transform: translateX(-150px);">
            <div id="comments-container"></div>
            <!-- 评论输入框 -->
            <div class="card mb-4">
                <div class="card-body">
                    <h5 class="card-title">发表评论</h5>
                    <form id="comment-form">
                        <input type="text" id="comment-username" class="form-control mb-2" placeholder="您的昵称" required></input>
                        <div class="mb-3">
                            <textarea id="comment-text" class="form-control" rows="3" placeholder="写下您的评论..." required></textarea>
                        </div>
                        <button type="submit" class="btn btn-secondary me-2">发送</button>
                    </form>
                </div>
            </div>
            <!-- 引入 Supabase -->
            <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
            <script>
                const SUPABASE_URL = 'https://iuywungpuuxkdjlnkhge.supabase.co';
                const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml1eXd1bmdwdXV4a2RqbG5raGdlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg4NzMwNjAsImV4cCI6MjA2NDQ0OTA2MH0.m7Sm50pXOYFB9vgHz0XlBhzu75HvT7kLX64UUD6C6Ts';
                const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                // 提交评论
                document.getElementById('comment-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const text = document.getElementById('comment-text').value.trim();
                    const username = document.getElementById('comment-username').value.trim();
                    if (!text || !username) return;
                    const { error } = await supabaseClient
                    .from('Comments')
                    .insert([{ username, message: text, page: 'data_structure'}]);
                    if (error) {
                        alert('提交失败！');
                        console.error(error);
                    }
                    else {
                        document.getElementById('comment-form').reset();
                        loadComments();
                    }
                });
                // 加载评论并展示
                async function loadComments() {
                    const { data, error } = await supabaseClient
                    .from('Comments')
                    .select('*')
                    .order('created_at', { ascending: false });
                    if (error) return console.error('加载失败', error);
                    const container = document.getElementById('comments-container');
                    container.innerHTML = '';
                    data.forEach(({ username, message, created_at, page}) => {
                        const date = new Date(created_at)
                        const timeAgo = new Date(date.getTime() + 8 * 60 * 60 * 1000).toLocaleString(); // 北京时间
                        const rand = Math.floor(Math.random() * 21) + 1;
                        const commentHtml = `
                        <div class="card mb-4 rounded-3 shadow-sm">
                            <div class="card-body d-flex">
                                <img src="./static/img/${rand}.jpg" class="rounded-circle me-3" width="40" height="40" alt="用户头像">
                                <div>
                                    <h6 class="mb-1">${username} <small class="text-muted">· ${timeAgo}</small></h6>
                                    <p class="mb-1">${message}</p>
                                </div>
                            </div>
                        </div>
                    `;
                    if (page == 'data_structure') container.innerHTML += commentHtml;
                    });
                }
                // 初次加载
                loadComments();
            </script>
        </div>
        <br></br>
        <br></br>
        <div class="player" id="audioPlayer">
      <div class="d-flex justify-content-between align-items-center">
        <div class="d-flex align-items-center">
          <button class="control-button" id="previousBtn">
            <i class="fas fa-backward"></i>
          </button>
          <button class="control-button" id="playPauseBtn">
            <i class="fas fa-play"></i>
          </button>
          <button class="control-button" id="nextBtn">
            <i class="fas fa-forward"></i>
          </button>
          <span id="currentSong" class="ml-3">sasakure.UK - uzumakinoharu.mp3</span>
        </div>
      </div>
	    <div id="progressBarControl">
        <img class="music_img" src="static\img\music.ico" width="30" height="30" alt="" id="music_img"></img>
        <input id="progressBar" type="range" min="0" max="100" step="0.1" value="0"></input>
	    </div>
      <div id="volumeControl">
        <img class="volume_img" src="static\img\volume-up.svg" width="30" height="30" alt="" id="volume_img"></img>
        <input id="progressBar_volume" type="range" id="volume" min="0" max="1" step="0.01" value="1" onchange="setVolume(this.value)"></input>
      </div>
      <audio id="audio">
        <source src="./static/audio/sasakure.UK - uzumakinoharu.mp3" type="audio/mp3"></source>
        Your browser does not support the audio element.
      </audio>
    </div>
    <script src="static\js\audio.js" rel="stylesheet"></script>
    </body>
</html>
