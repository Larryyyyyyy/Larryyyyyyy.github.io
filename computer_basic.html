<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Larry's garden</title>
	<link href="static\css\mainpage.css" rel="stylesheet"></link>
    <link href="static\plugins\bootstrap-5.3.3-dist\css\bootstrap.min.css" rel="stylesheet"></link>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet"></link>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown-dark.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<script src="static\plugins\bootstrap-5.3.3-dist\js\bootstrap.bundle.min.js"></script>
    <style>
        @media (max-width: 767px) { body { padding: 15px; } }
        body { 
            box-sizing: border-box;
            margin: 0 auto;
            color: black;
        }
        html, body {
            background-color: #0d1117;
            color: #c9d1d9;
        }
        .markdown-body {
            background-color: transparent;
            min-width: 200px;
            max-width: 980px;
            padding: 40px;
            position: relative;
            left: 120px;
        }
        html {
            scroll-behavior: smooth;
        }
        #toc a:hover {
            color: #c9d1d9;
            font-weight: bold;
        }
        .content {
            margin-right: 280px;
        }
        #toc a {
            color: white;
        }
        #toc a:hover {
            color: #ffc107; /* 黄色悬停高亮 */
            font-weight: bold;
        }
        #toc .list-group-item {
            background-color: #333;
            border: none;
        }
        #toc .list-group-item:hover {
            background-color: #444;
        }
        .player {
            position: fixed;
            bottom: -100px;
            left: 0;
            width: 100%;
            background-color: #333;
            padding: 15px;
            border-radius: 10px;
            transition: bottom 0.3s ease;
        }
        .player.active {
            bottom: 0;
        }
        .player .control-button {
            color: white;
            border: none;
            background: transparent;
        }
        .player .control-button:hover {
            color: #f39c12;
        }
    </style>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
    </head>
    <body>
        <div class="stars"></div>
        <nav class="navbar navbar-expand-lg bg-body-tertiary" data-bs-theme="dark" style="width: -100px;">
            <div class="container-fluid">
                <a class="navbar-brand" href="#">Larry的小花园</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse justify-content-between" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a class="nav-link" aria-current="page" href="index.html">首页</a>
                        </li>
                    <li class="nav-item">
                        <a class="nav-link" href="#">聊天</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle active" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">资源</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="advanced_programing.html">高等程序设计A</a></li>
                            <li><a class="dropdown-item" href="computer_basic.html">计算机系统基础</a></li>
                            <li><a class="dropdown-item" href="data_structure.html">数据结构A</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="#">更多...</a></li>
                        </ul>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link disabled" aria-disabled="true"></a>
                    </li>
                    </ul>
                </div>
            </div>
        </nav>
        <form class="d-flex ms-auto" role="search">
            <input class="form-control me-2" type="search" placeholder="搜索" aria-label="search" style="position: relative; left: 150px; width: 920px;"></input>
            <button class="btn btn-outline-success me-3" type="submit" style="position: relative; left: 150px;">
			    <img src="static\img\search.png" alt="Search" style="width: 20px; height: 20px; background-color: dark;">
			</button>
        </form>
        <script>
            const form = document.querySelector("form[role='search']");
            const input = form.querySelector("input[type='search']");
            form.addEventListener("submit", function (e) {
            e.preventDefault();
            const keyword = input.value.trim().toLowerCase();
            if (!keyword) return;
            const contentBlocks = document.querySelectorAll(".markdown-body p, .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6");
            let found = false;
            contentBlocks.forEach(block => {
                if (block.textContent.toLowerCase().includes(keyword)) {
                    block.scrollIntoView({ behavior: "smooth", block: "center" });
                    block.style.backgroundColor = "#fffa90";
                    setTimeout(() => block.style.backgroundColor = "", 2000);
                    found = true;
                }
            });
            if (!found) {
                alert("没有找到匹配的内容。");
            }
        });
        </script>
                <div id="toc" class="position-fixed border rounded shadow p-3" style="top: 100px; width: 350px; max-height: 70vh; overflow-y: auto; z-index: 1000; position: relative; right: 30px;">
            <strong class="mb-2 d-block">目录</strong>
            <ul class="list-group list-group-flush" id="toc-list"></ul>
        </div>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                const tocList = document.getElementById("toc-list");
                const headers = document.querySelectorAll("h1, h2, h3");
                let index = 0;
                headers.forEach(header => {
                    if (!header.id) {
                        header.id = "heading-" + index++;
                    }
                    const li = document.createElement("li");
                    li.className = "list-group-item px-2 py-1";
                    const indent = header.tagName === "H2" ? "ms-3" :
                    header.tagName === "H3" ? "ms-5" : "";
                    li.innerHTML = `<a class="${indent} text-decoration-none" href="#${header.id}">${header.innerText}</a>`;
                    tocList.appendChild(li);
                });
            });
        </script>
        <div id="$m" class="markdown-body"></div>
        <textarea id="$t" style="display:none">
# 2.信息的表示和处理

## 2.1信息存储

**概念**：

- 大多数计算机使用**8**位的**块**，或者**字节(byte)**，作为最小的可寻址的内存单位。
- 机器级程序将内存视为一个非常大的字节数组，称为**虚拟内存 (virtual memory)** 。
- 内存的每个字节都由一个唯一的数字来标识，称为它的**地址(address)** 。
- 所有可能地址的集合就称为**虚拟地址空间(virtual address space)** 。
  顾名思义，这个虚拟地址空间只是一个展现给机器级程序的概念性映像。

*实际的实现是将动态随机访问存储器(DRAM)、闪存、磁盘存储器、特殊硬件和操作系统软件结合起来，为程序提供一个看上去统一的字节数组。*

**每个程序对象可以简单地视为一个字节块，而程序本身就是一个字节序列**。

### 2.1.1十六进制表示法

略。

### 2.1.2字数据大小

每台计算机都有一个**字长(word size)**，指明指针数据的**标称大小(nominal size)**。 

因为虚拟地址是以这样的一个字来编码的，所以字长决定的最重要的系统参数就是**虚拟地址空间**的最大大小。

也就是说，对于一个字长为$w$位的机器而言，虚拟地址的范围为$0\sim 2^w-1$, 程序最多访问$2^w$个字节。

大多数64位机器也可以运行为 32位机器编译的程序，这是一种向后兼容。

因此，当程序`prog.c`用如下伪指令编译后

```bash
linux> gcc -m32 prog.c
```

该程序就可以在32位或64位机器上正确运行。

当程序用下述伪指令编译

```bash
linux> gcc -m64 prog.c
```

那就只能在 64 位机器上运行。

将程序称为**32位程序或64位程序**时，区别在于**该程序是如何编译的， 而不是其运行的机器类型**。

C声明下32位与64位的不同：`long`在32位下是4字节，64位下是8字节，`char *`在32位下是4字节，64位下是8字节。

为了**避免由于依赖典型大小和不同编译器设置带来的奇怪行为**，`ISO C99`引入了一类数据类型，其数据大小是固定的，不随编译器和机器设置而变化。其中就有数据类型`int32_t`和`int64_t`, 它们分别为4个字节和8个字节。 

程序对`char`是否有符号通常不敏感。

### 2.1.3寻址和字节顺序

在几乎所有的机器上，多字节对象都被存储为连续的字节序列，对象的地址为所使用字节中最小的地址。

两个排列对象字节的规则：

以`0x1234567`为例：

- **小端法**：最小地址存储67，最大地址存储01。
- **大端法**：最小地址存储01，最大地址存储67。

大多数`Intel`兼容机都只用小端模式。 另一方面，`IBM`和`Oracle`（从其2010年收购`Sun Microsystems`开始）的大多数机器则是按大端模式操作。

许多比较新的微处理器是**双端法(bi-endian)**，也就是说可以把它们配置成作为大端或者小端的机器运行。

*实际情况是：一旦选择了特定操作系统，字节顺序也就固定下来。如许多移动电话的 `ARM` 微处理 器，其硬件可以按小端或大端两种模式操作，但是这些芯片上最常见的两种操作系统 `Android` 和 `IOS` 却只能运行于小端模式。*

字节顺序很重要：

1. **网络应用程序的代码编写必须遵守已建立的关于字节顺序的规则**，以确保发送方机器将它的内部表示转换成网络标准，而接收方机器则将网络标准转换为它的内部表示。
2. **反汇编器**：反汇编器是一种确定可执行程序文件所表示的指令序列的工具。
3. **编写规避正常的类型系统的程序**：如涉及强制类型转换的程序。

### 2.1.4表示字符串

C语言中字符串被编码为一个以`null`(其值为0)字符结尾的字符数组。 每个字符都由某个标准编码来表示，最常见的是`ASCII`字符码。

**文本数据比二进制数据具有更强的平台独立性**。

### 2.1.5表示代码

在机器上编译时，会生成字节表示的机器代码，如：`55 89 e5 8b 45 Oc 03 45 08 5d c3`(Windows)。

说明**二进制代码是不兼容的，很少能在不同机器和操作系统组合之间移植**。

### 2.1.6布尔代数简介

当考虑长度为$w$的位向量上的＾、＆和～运算时，会得到一种不同的数学形式，称为**布尔环**($Boolean~ring$)。

**位向量**

是一种固定长度为$w$、由0和1组成的串。

一个很有用的应用是表示有限集合。我们可以用位向量$[a_{w-1},\dots,a_1,a_0]$编码任何子集A。比如：$a=[01101001]表示集合A=\left\{\right.0,3,5,6\left\}\right.$。 

### 2.1.7C语言中的位级运算

略。

### 2.1.8C语言中的逻辑运算

略。

### 2.1.9C语言中的移位运算

略。

- **逻辑右移**：在左端补$k$个0。
- **算术右移**：在左端补$k$个最高有效位的值。

实际上，几乎所有的编译器/机器组合都对**有符号数**使用**算术右移**，且许多程序员也都假设机器会使用这种右移。另一方面，对于**无符号数**，**右移必须是逻辑的**。

与C相比，Java对于如何进行右移有明确的定义。表达是`x>>k`会将x算术右移k个位置，而`x>>>k`会对x做逻辑右移。

**注**：当位移量很大的时候：在许多机器上，当移动一个$w$位的值时，移位指令只考虑位移量的低$\ce{log}_2w$位，因此实际上位移量就是通过计算$k~\ce{mod}~w$得到的。事实上未必能保证发生这种行为，还是注意别乱搞。

## 2.2整数表示

### 2.2.1整型数据类型

略。

### 2.2.2无符号数的编码

**定义**：

对向量$\overrightarrow x=[x_{w-1},x_{w-2},\dots,x_0]:$
$$
B2U_w(\overrightarrow x)\overset{.}{=}\sum_{i=0}^{w-1}x_i2^i
$$
无符号数的二进制表示有一个很重要的属性，也就是每个介于$0\sim 2^w-1$之间的数都有唯一一个$w$位的值编码。

此外：$B2U_w$是一个双射，即映射双方互相唯一对应。

### 2.2.3补码编码

**定义**：

对向量$\overrightarrow x=[x_{w-1},x_{w-2},\dots,x_0]:$
$$
B2T_w(\overrightarrow x)\overset{.}{=}-x_{w-1}2^{w-1}+\sum_{i=0}^{w-2}x_i2^i
$$
同无符号表示一样，在可表示的取值范围内的每个数字都有一个唯一的$w$位的补码编码。

此外：$B2T_w$是一个双射。

**C语言标准并没有要求要用补码形式来表示有符号整数，但是几乎所有的机器都是这么做的**。

***宏与格式字符串***：

*例：宏PRId32编译为64位程序时，展开为字符串d，而宏PRIu64展开成两个字符串l和u*。

*使用宏能保证：不论代码是如何被编译的，都能生成正确的格式字符串。根据平台的需要自动选择适当的格式符，使得这个宏在不同的系统上更加灵活和安全*。

***反码和原码***：

- **反码**：
  $$
  B2O_w(\overrightarrow x)\overset{.}{=}-x_{w-1}(2^{w-1}-1)+\sum_{i=0}^{w-2}x_i2^i
  $$

- **原码**：
  $$
  B2S_w(\overrightarrow x)\overset{.}{=}(-1)^{x_{w-1}}·\sum_{i=0}^{w-2}x_i2^i
  $$
  *虽然过去生产过基于反码表示的机器，但是几乎所有的现代机器都使用补码。我们将看到在浮点数中有使用原码编码*。

### 2.2.4有符号数和无符号数之间的转换

对于大多数C语言的实现，处理同样字长的有符号数和无符号数之间相互转换的一般规则是：**数值可能会改变，但是位模式不变**。

道理大家都懂，值得注意的是**有符号数和无符号数的右移规则不同**。

### 2.2.5C语言中的有符号数与无符号数

通常， 大多数数字都默认为是有符号的。

要创建一个无符号常扯，必须加上后缀字符 'U' 或者 'u'。

**强制类型转换**：

1. 显式强制类型转换：如

   ```c++
   y=(int)x;
   ```

2. 隐式强制类型转换：如

   ```c++
   y=x;
   ```

3. 格式字符串。

**当执行一个运算时，如果它的一个运算数是有符号的而另一个是无符号的，那么C语言会隐式地将有符号参数强制类型转换为无符号数，并假设这两个数都是非负的，来执行这个运算**。

### 2.2.6扩展一个数字的位表示

**零扩展**：要将一个无符号数转换为一个更大的数据类型，只需简单地在表示的开头添加0。

**符号扩展**：要将一个补码数字转换为一个更大的数据类型，可以在表示中添加最高有效位的值。事实上：
$$
B2T_{w+k}([x_{w-1},\dots,x_{w-1},x_{w-1},x_{w-2},\dots,x_0])=B2T_{w}([x_{w-1},x_{w-2},\dots,x_0])
$$
值得一提的是，从一个数据大小到另一个数据大小的转换，以及无符号和有符号数字之间的转换的相对顺序能够影响一个程序的行为。

通常是**先改变大小，再完成从有符号到无符号的转化**。这个规则是C语言标准要求的。

### 2.2.7截断数字

**截断无符号数**：直接截断
$$
B2U_w([x_{w-1},x_{w-2},\dots,x_0]){\rm mod}~2^k=B2U_k([x_{k-1},x_{k-2},\dots,x_0])
$$
**截断补码数据**：截断后注意符号位
$$
B2T_k([x_{k-1},x_{k-2},\dots,x_0])=U2T_k(B2U_w([x_{w-1},x_{w-2},\dots,x_0]){\rm mod}~2^k)
$$

### 2.2.8关于有符号数与无符号数的建议

许多无符号运算的细微特性，尤其是有符号数到无符号数的隐式转换，会导致错误或者漏洞的方式。避免这类错误的一种方法就是**绝不使用无符号数**。 实际上，除了C以外很少有语言支持无符号整数。

## 2.3整数运算

### 2.3.1无符号加法

对满足$0\le x,y<2^w$的$x$和$y$有：(这里的$x+y~$特指无符号数的加法)
$$
x+y=\left\{
\begin{aligned}
x+y,~~~~~~~~~~~x+y<2^w~~~~~~~~正常\\
x+y-2^w,~~~2^w\le x+y<2^{w+1}~~~~溢出
\end{aligned}
\right.\\
$$
当且仅当$x+y<x或x+y<y~$时，发生了溢出。

### 2.3.2补码加法

对满足$-2^{w-1}\le x,y<2^{w-1}-1$的$x$和$y$有：(这里的$x+y~$特指补码的加法)
$$
x+y=\left\{
\begin{aligned}
x+y-2^w,~~~~~2^{w-1}\le x+y~~~~~~~~正溢出\\
x+y,~~~-2^{w-1}\le x+y<2^{w-1}~~~~正常\\
x+y+2^w,~~~~~~x+y<-2^{w-1}~~~~负溢出
\end{aligned}
\right.\\
$$
当且仅当$x>0,y>0但x+y\le 0$时，发生了正溢出。

当且仅当$x<0,y<0但x+y\ge 0$时，发生了负溢出。

### 2.3.3补码的非

对满足$TMin_w\le x\le TMax_w$的$x$，其补码的非为：
$$
-x=\left\{
\begin{aligned}
TMin_w,~~~~~~x=TMin_w\\
-x,~~~~~~x>TMin_w
\end{aligned}
\right.\\
$$
执行位级补码非的笫一种方法是对每一位求补，再对结果加1，即：$-x=\sim x+1$。

### 2.3.4无符号乘法

对满足$0\le x,y\le UMax_w$的$x$和$y$有：
$$
x*y=(x·y)\mod 2^w
$$

### 2.3.5补码乘法

对满足$TMin_w\le x,y\le TMax_w$的$x$和$y$有：
$$
x*y=U2T_w((x·y)\mod 2^w)
$$
值得注意的是，同样的两个数，作为无符号数和补码相乘的时候，其乘积的位级表示不同，但是截断后乘积的位级表示相同。

### 2.3.6乘以常数

整数乘法指令通常很慢，大约是而其他整数运算（例如加法、 减法、位级运算和移位）的10倍左右。

因此，编译器使用了一项重要的优化，试着**用移位、加法和减法运算的组合来代替乘以常数因子的乘法**。

包括：考虑一组连续的1

- $(x<<n)+(x<<(n-1))+\dots+(x<<m)$
- $(x<<(n+1))-(x<<m)$

大多数编译器只在需要少量移位、加法和减法就足够的时候才使用这种优化。

### 2.3.7除以2的幂

在大多数机器上，整数除法要比整数乘法更慢，大概需要其他整数运算的30倍左右。

**除以2的幂也可以用移位运算来实现**。

值得注意的是，舍去小数位的时候：

- 正数：**向下取整**。
- 负数：**向上取整**。

## 2.4浮点数

### 2.4.1二进制小数

如用$(0.111111)_2$表示$\frac{63}{64}$。

对于$\frac{1}{5}$这种只能近似地表示它，增加二进制表示的长度可以提高表示的精度：
$$
(0.2)_{10}=(0.001100110011\dots)_2
$$

### 2.4.2IEEE浮点表示

IEEE浮点标准用$V=(-1)^s\times M\times 2^E$的形式来表示一个数：

- 符号(sign)$s$决定这数是负数$(s=1)$还是正数$(s=0)$，而对于数值$0$的符号位解释作为特殊情况处理。
- 尾数(significand)$M$是一个二进制小数，它的范围是$1\sim2-\epsilon$，或者是$0\sim 1-\epsilon$。
- 阶码(exponent)$E$的作用是对浮点数加权，这个权重是2的$E$次幂（可能是负数）。

将浮点数的位表示划分为三个字段，分别对这些值进行编码：

- 一个单独的符号位$s$直接编码符号$s$。
- $k$位的阶码字段${\rm{exp}}=e_{k-1}\dots e_1e_0$编码阶码$E$。
- $n$位小数字段${\rm{frac}}=f_{n-1}\dots f_1f_0$编码尾数$M$，但是编码出来的值也依赖于阶码字段的值是否等于0。

在封装到32位字中，其$k=8$，$n=23$。

在封装到64位字中，其$k=11$，$n=52$。

根据$\rm{exp}$的值，被编码的值可以分成三种情况：

1. **规格化的值**：
   当$\rm{exp}$的位模式既不全为0或全为1时：$E={\rm{exp}}-Bias$，其中$Bias=2^{k-1}-1$。
   尾数定义为$M=1+\rm{frac}$。

2. **非规格化的值**：
   当$\rm{exp}$全为0时，$E=1-Bias$，$M=f$。
   此时当$M=f=0$时，可以取到$0$，而根据符号位不同，分为$+0.0$和$-0.0$。
   根据$\rm{IEEE}$的浮点格式，值$+0.0$和$-0.0$在某些方面被认为是不同的，而在其他方面是相同的。

3. **无穷**：
   当$\rm{exp}$全为1时，$\rm{frac}$全为0时，取为无穷，正负无穷取决于符号位。
   这可以由两个大数相乘或除以零得到。

4. **$\ce{NaN}$**:

   当$\rm{exp}$全为1时，$\ce{frac}$不全为0时，取为$\ce{NaN}$。
   一些运算结果不能是实数或无穷时，就会得到这个结果。(例如$\infty-\infty,\frac{1.0}{0}$)。

### 2.4.3示例

本节只作以下提醒：

- 值$+0.0$总有一个全为0的位表示。
- 最小的正非规格化值的位表示，是由最低有效位为1而其他所有位为0构成的。它具有小数（和尾数）值$M=f=2^{-n}$和阶码值$E=-2^{k-1}+2$。因此它的数字值是$V=2^{-n-2^{k-1}+2}$。
- 最大的非规格化值的位模式是由全为0的阶码字段和全为1的小数字段组成的。它有小数（和尾数）值$M=f=1-2^{-n}$（我们写成$1-\epsilon$)和阶码值$E=-2^{k-1}+2$。因此，数值$V=(1-2^{-n})\times 2^{-2^{k-1}+2}$ ，这仅比最小的规格化值小一点。
- 最小的正规格化值的位模式的阶码字段的最低有效位为1，其他位全为0。它的尾数值$M=1$，而阶码值$E=-2^{k-1}+2$。因此，数值$V=2^{-2^{k-1}+2}$
- 值$1.0$的位表示的阶码字段除了最高有效位等于$1$以外，其他位都等于$0$。它的尾数值是$M=1$，而它的阶码值是$E=0$。
- 最大的规格化值的位表示的符号位为$0$，阶码的最低有效位等于$0$，其他位等于$1$。它的小数值$f=1-2^{-n}$，尾数$M=2-2^{-n}$（我们写作$2-\epsilon$)。它的阶码值$E=2^{k-1}-1$得到数值$V=(2-2^{-n})\times 2^{2^{k-1}-1}=(1-2^{-n-1})\times 2^{2^{k-1}}$

### 2.4.4舍入

 IEEE浮点格式定义了四种不同的舍入方式。默认的方法是找到最接近的匹配，而其他三种可用于计算上界和下界。

四种舍入方式：

- **向偶数舍入(round-to-even)**是默认的方式， 试图找到一个最接近的匹配值。当在可能结果的中间数值：它将数字向上或者向下舍入，使得结果的最低有效数字是偶数。例如，$1.5$和$2. 5$都舍入成$2$。
- **向零舍入**：把正数向下舍入，把负数向上舍入。
- **向下舍入**：把正数和负数都向下舍入。
- **向上舍入**：把正数和负数都向上舍入。

提供一个float类型采取**向偶数舍入**的例子：

```c++
//temp是一个32位数，现在将其右移9位。f取为1时尾数要加1
f=0;
if((temp&0x1ff)>0x100)f=1;
if((temp&0x3ff)==0x300)f=1;
```

### 2.4.5浮点运算

把浮点值$x$和$y$看成实数，而某个运算$\bullet$定义在实数上，计算将产生$Round(x\bullet y)$，这是进行舍入后的结果。在实际中，浮点单元的设计者使用一些聪明的小技巧来避免执行这种精确的计算，因为计算只要精确到能够保证得到一个正确的舍入结果就可以了。

**浮点加法**：

- 浮点加法不具有结合性，这是缺少的最重要的群属性。
- 浮点加法满足单调性：如果$a\ge b$，那么对于任何$a、b$以及$x$的值，除了$NaN$，都有$x+a\ge x+b$。无符号或补码加法不具有这个实数（和整数）加法的属性。

**浮点乘法**：

- 浮点乘法不具有结合性。

- 浮点乘法不具备分配性。

- 浮点乘法满足单调性：不考虑$NaN$，都有
  $$
  a\ge b且c\ge 0~\Rightarrow~a*c\ge b*c \\
  a\ge b且c\le 0~\Rightarrow~a*c\le b*c
  $$

### 2.4.6C语言中的浮点数

所有的C语言版本提供了两种不同的浮点数据类型：`float`和`double`。通常都使用向偶数舍入的舍入方式。

不幸的是，因为C语言标准不要求机器使用IEEE浮点，所以没有标准的方法来改变舍入方式或者得到诸如$-0$、$+\infty$、$-\infty$或者$NaN$之类的特殊值。

通常在包含`math.h`库中：GNU编译器GCC会定义程序常数`inftyITY`表示$+\infty$)和`NAN`（表示 $NaN$)。

# 3.程序的机器级表示

*本章基于x86-64，一种现在笔记本电脑和台式机中最常见处理器的机器语言，也是驱动大型数据中心和超级计算机的最常见处理器的机器语言。*

*IA32是x86-64的32位前身*

## 3.1历史观点

略。

## 3.2程序编码

从一段代码开始：

```bash
#有两个文件p1.c和p2.c，用Unix命令行编译这些代码：
gcc -Og -o p p1.c p2.c
```

- 命令`gcc`(也可以是`cc`)是`GCC`编译器，这是Linux上默认的编译器。
- 编译选项`-Og`告诉编译器使用**会生成符合原始C代码整体结构的机器代码的优化等级**。较高级别优化产生的代码会严重变形，难以理解。
  实际中，从得到的程序的性能考虑，较高级别的优化（例如`-O1`或`-O2`）更好。
- 实际上`gcc`命令调用了一整套的程序，将源代码转化成可执行代码。
  - C预处理器扩展源代码，插入所有用`#include`命令指定的文件，并扩展所有用`#define`声明指定的宏。
  - 编译器产生两个源文件的汇编代码，名字分别为`p1.s`和`p2.s`。接下来，汇编器会将汇编代码转化成二进制目标代码文件`p1.o`和`p2.o`。目标代码是机器代码的一种形式，它包含所有指令的二进制表示，但是还没有填入全局值的地址。
  - 链接器将两个目标代码文件与实现库函数的代码合并， 并产生最终的可执行代码文件`p`（由命令行指示符`-op`指定的）。可执行代码是我们要考虑的机器代码的第二种形式，也就是处理器执行的代码格式。

### 3.2.1机器级代码

对千机器级编程来说，其中两种抽象尤为重要：

1. **指令集体系结构或指令集架构(Instruction Set Architecture,ISA)**：
   它定义了处理器状态、指令的格式，以及每条指令对状态的影响。
2. 机器级程序使用的内存地址是**虚拟地址**，提供的内存模型看上去是一个非常大的字节数组。

**一些隐藏的处理器状态**：

- 程序计数器（通常称为**PC**，在x86-64中用`％rip`表示）给出将要执行的下一条指令在内存中的地址。
- 整数寄存器文件**包含16个命名的位置，分别存储64位的值**。 这些寄存器可以存储**地址**（对应于C语言的指针）或**整数数据**。有的寄存器被用来记录某些**重要的程序状态**，而其他的寄存器用来保存**临时数据**，例如过程的参数和局部变量，以及函数的返回值。
- 条件码寄存器保存着最近执行的**算术或逻辑指令的状态信息**。它们用来实现控制或数据流中的条件变化，比如说用来实现`if`和`while`语句。
- 一组向量寄存器可以存放**一个或多个整数或浮点数值**。

**程序内存**：

- 程序的可执行机器代码。
- 操作系统需要的一些信息。
- 用来管理过程调用和返回的**运行时栈**，以及用户分配的**内存块**。

程序内存用虚拟地址来寻址。

在任意时刻，**只有有限的一部分虚拟地址被认为是合法的**。例如，x86-64的虚拟地址由64位的字表示。在目前的实现中， 这些地址的高16位必须设置为0，所以一个地址实际上能够指定的是$2^{48}$或64TB范围内的一个字节。

较为典型的程序只会访问几兆字节或几千兆字节的数据。

**操作系统负责管理虚拟地址空间**，将虚拟地址翻译成**实际处理器内存中的物理地址**。

**一条机器指令只执行一个非常基本的操作**，机器指令可以由编译器产生。

### 3.2.2代码示例

使用`-S`选项编译文件，就可以仅得到编译器产生的汇编文件`test.s`：`gcc -Og -S test.c`。

`test.s`示例：

```bash
test:
  pushq %rbx
  movq %rdx,%rbx
  call mult2
  movq %rax,(%rbx)
  popq %rbx
  ret
```

使用`-c`选项编译文件，就可以编译并汇编代码产生二进制文件`test.o`：`gcc -Og -c test.c`。

1368字节的文件`test.o`中有一段14字节的序列，它的十六进制表示为：`53 48 89 d3 e8 00 00 00 00 48 89 03 5b c3`。

**反汇编器**

**反汇编器程序**根据机器代码产生一种类似于汇编代码的格式。在Linux，带`-d`命令行标志的程序OBJDUMP可以充当这个角色：

`objdump -d test.o`

我们得到的结果为

```bash
0000000000000000 <multstore>:
0: 53               push   %rbx
1: 48 89 d3         mov    %rdx,%rbx
4: e8 00 00 00 00   callq  9 <multstore+0x9>
9: 48 89 03         mov    %rax,(%rbx)
c: 5b               pop    %rbx
d: c3               retq
```

*要展示程序的二进制目标代码，可以用反汇编器确定该过程的代码长度。然后，在 `.o` 文件上运行GNU调试工具GDB，输入命令： `(gdb) x/14xb multstore` 这条命令告诉 GDB显示从函数 `multstore` 所处地址开始的14个十六进制格式表示的字节。*

**值得注意的是**：

- x86-64的指令长度**从1到15个字节**不等。
  常用的指令以及操作数较少的指令所需的字节数少。
  不太常用或操作数较多的指令所需字节数较多。

- 设计指令格式的方式是，从某个给定位置开始，可以将字节**唯一地**解码成机器指令。
  例如，只有指令`pushq %rbx`是以字节值53开头的。

- 反汇编器只是基于机器代码文件中的字节序列来确定汇编代码。 它不需要访问该程序的源代码或汇编代码。

- 反汇编器使用的指令命名规则与GCC生成的汇编代码使用的有些细微的差别。

  它省略了很多指令结尾的`q`。
  这些后缀是大小指示符，在大多数情况中可以省略。
  反汇编器给`call`和`ret`指令添加了`q`后缀，同样，省略这些后缀也没有问题。

生成实际可执行的代码需要对一组目标代码文件运行链接器，而这一组目标代码文件中必须含有一个`main`函数，这样会使生成文件包含**启动和终止程序的代码和用来与操作系统交互的代码**。

有时候会插入如`e: 90 nop`这样的指令，**无特殊意义，仅为补充为16字节**。

### 3.2.3关于格式的注解

例：

```bash
test:
	pushq %rbx                #Save %rbx
	movq %rdx, %rbx           #Copy dest to %rbx
	call mult2                #Call mult2(x,y)
	movq %rax, (%rbx)         #Store result at *dest
	popq %rbx                 #Restore %rbx
	ret                       #Return
```

通常给出与讨论内容相关的代码行。每一行的**左边都有编号供引用**，**右边是注释**，简单地描述指令的效果以及它与原始C语言代码中的计算操作的关系。 

这是一种汇编语言程序员写代码的风格。

对于一些应用程序，程序员必须用汇编代码来访问机器的低级特性。一种方法是**用汇编代码编写整个函数，在链接阶段把它们和C函数组合起来**。另一种方法是**利用GCC的支持，直接在C程序中嵌入汇编代码**。

第二种方法示例：

```c
#include <stdio.h>
int main(){
    int a=2,b=3,result;
    asm ("addl %%ebx, %%eax" 
         : "=a" (result)  // 输出：将 eax 赋值给 result
         : "a" (a), "b" (b)  // 输入：a 传入 eax, b 传入 ebx
         : "cc");  // 破坏了条件标志寄存器
    printf("Result = %d\n", result); // 输出 5
    return 0;
}
```

**使用内联汇编的情景**：

- **优化代码**。（虽然现在编译器优化能力也很强）
- **访问特殊寄存器**（如`rdtsc`计时）。
- **直接执行CPU指令**（如`cpuid`获取CPU信息）。
- **驱动开发**（与硬件通信）。

## 3.3数据格式 

Intel用**字(word)**表示16位数据类型。称32位数为**双字(double words)**，称64位数为**四字(quad words)**。

| C声明  | Intel数据类型 | 汇编代码后缀 | 大小(字节) |
| ------ | ------------- | ------------ | ---------- |
| char   | 字节          | b            | 1          |
| short  | 字            | w            | 2          |
| int    | 双字          | l            | 4          |
| long   | 四字          | q            | 8          |
| char*  | 四字          | q            | 8          |
| float  | 单精度        | s            | 4          |
| double | 双精度        | l            | 8          |

- **非浮点数**：b，w，l，q分别对应1，2，4，8字节，后缀会加到汇编代码指令后面。
- **浮点数**：与非浮点数用的是不同的指令和寄存器，所以后缀会有区别。

## 3.4访问信息

一个x86-64的中央处理单元(CPU)包含一组16个存储64位值的通用目的**寄存器**。 这些寄存器用来存储整数数据和指针。 它们都以**%r**开头。

1. 在最初的`8086`中是8个16位寄存器。
2. 扩展到`IA32`架构时扩展成32位寄存器。
3. 扩展到`x86-64`扩展成64位，且增加了8个寄存器。

| 32-63位 | 16-31位 | 8-15位  | 0-7位   | 用途         |
| ------- | ------- | ------- | ------- | ------------ |
| `%rax`  | `%eax`  | `%ax`   | `%al`   | 返回值       |
| `%rbx`  | `%ebx`  | `%bx`   | `%bl`   | 被调用者保存 |
| `%rcx`  | `%ecx`  | `%cx`   | `%cl`   | 第4个参数    |
| `%rdx`  | `%edx`  | `%dx`   | `%dl`   | 第3个参数    |
| `%rsi`  | `%esi`  | `%si`   | `%sil`  | 第2个参数    |
| `%rdi`  | `%edi`  | `%di`   | `%dil`  | 第1个参数    |
| `%rbp`  | `%ebp`  | `%bp`   | `%bpl`  | 被调用者保存 |
| `%rsp`  | `%esp`  | `%sp`   | `%spl`  | 栈指针       |
| `%r8`   | `%r8d`  | `%r8w`  | `%r8b`  | 第5个参数    |
| `%r9`   | `%r9d`  | `%r9w`  | `%r9b`  | 第6个参数    |
| `%r10`  | `%r10d` | `%r10w` | `%r10b` | 调用者保存   |
| `%r11`  | `%r11d` | `%r11w` | `%r11b` | 调用者保存   |
| `%r12`  | `%r12d` | `%r12w` | `%r12b` | 被调用者保存 |
| `%r13`  | `%r13d` | `%r13w` | `%r13b` | 被调用者保存 |
| `%r14`  | `%r14d` | `%r14w` | `%r14b` | 被调用者保存 |
| `%r15`  | `%r15d` | `%r15w` | `%r15b` | 被调用者保存 |

指令可以对这16个寄存器的低位字节中存放的不同大小的数据进行操作。字节级操作可以访问最低的字节，16位操作可以访问最低的2个字节，32位操作可以访问最低的4个字节，而64位操作可以访问整个寄存器。

当指令以这些寄存器为目标时，根据字节数会有所不同：

- 生成1字节和2字节数字的指令会保持剩下的字节不变。
- 生成4字节数字的指令会把高位4个字节置为0（这么规定是为了从`IA32`架构向`x86-64`扩展）。

### 3.4.1操作数指示符

1. **立即数**：用来表示常数值，如`$-577`，`$0x7f`。
2. **寄存器**：表示某个寄存器的内容，16个寄存器的低位1字节、2字节、4字节或8字节中的一个作为操作数， 这些字节数分别对应于8位、16位、32位或64位。
3. **内存引用**：根据计算出来的地址访问某个内存位置，如`%rax`。

**寻址模式**：

| 类型   | 格式             | 操作数值                        | 名称                |
| ------ | ---------------- | ------------------------------- | ------------------- |
| 立即数 | ${$Imm}$         | $Imm$                           | 立即数寻址          |
| 寄存器 | $r_a$            | ${\rm{R}}[r_a]$                 | 寄存器寻址          |
| 存储器 | $Imm$            | ${\rm{M}}[Imm]$                 | 绝对寻址            |
| 存储器 | $(r_a)$          | ${\rm{M}}[R[r_a]]$              | 间接寻址            |
| 存储器 | $Imm(r_b)$       | ${\rm{M}}[Imm+R[r_b]]$          | （基址+偏移量）寻址 |
| 存储器 | $(r_b,r_i)$      | ${\rm{M}}[R[r_b]+R[r_i]]$       | 变址寻址            |
| 存储器 | $Imm(r_b,r_i)$   | ${\rm{M}}[Imm+R[r_b]+R[r_i]]$   | 变址寻址            |
| 存储器 | $(,r_i,s)$       | ${\rm{M}}[R[r_i]· s]$           | 比例变址寻址        |
| 存储器 | $Imm(,r_i,s)$    | ${\rm{M}}[Imm+R[r_i]·s]$        | 比例变址寻址        |
| 存储器 | $(r_b,r_i,s)$    | ${\rm{M}}[R[r_b]+R[r_i]·s]$     | 比例变址寻址        |
| 存储器 | $Imm(r_b,r_i,s)$ | ${\rm{M}}[Imm+R[r_b]+R[r_i]·s]$ | 比例变址寻址        |

### 3.4.2数据传送指令

**MOV类**：

| 指令                                                         | 效果                                    | 描述                                                         |
| ------------------------------------------------------------ | --------------------------------------- | ------------------------------------------------------------ |
| `MOV`                   $S,D$                                | $D\leftarrow S$                         | 传送                                                         |
| `movb`<br />`movw`<br />`movl`<br />`movq`<br />`movabsq`            $I,R$ | <br /><br /><br /><br />$R\leftarrow I$ | 传送字节<br />传送字<br />传送双字<br />传送四字<br />传送绝对的四字 |

源操作数指定的值是**存储在寄存器中或者内存中的一个立即数**。

目的操作数指定**一个寄存器或者一个内存地址的位置**。

*`movl`指令会把目的寄存器的高位4字节设置为0*。

在将较小的源值复制到较大的目的时使用MOVZ类或MOVS类。其中后者会做符号位扩展。

| 指令                                                         | 效果                     | 描述                                                         |
| ------------------------------------------------------------ | ------------------------ | ------------------------------------------------------------ |
| `MOVZ`              $S,R$                                    | $R\leftarrow$零扩展$(S)$ | 以零扩展进行传送                                             |
| `movzbw`<br />`movzbl`<br />`movzwl`<br />`movzbq`<br />`movzwq` |                          | 将做了零扩展的字节传送到字<br />将做了零扩展的字节传送到双字<br />将做了零扩展的字传送到双字<br />将做了零扩展的字节传送到四字<br />将做了零扩展的字传送到四字 |

| 指令                                                         | 效果                                                         | 描述                                                         |
| ------------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| `MOVS`              $S,R$                                    | $R\leftarrow$符号扩展$(S)$                                   | 传送符号扩展的字节                                           |
| `movsbw`<br />`movsbl`<br />`movswl`<br />`movsbq`<br />`movswq`<br />`movslq`<br />`cltq` | <br /><br /><br /><br /><br /><br />`%rax`$\leftarrow$符号扩展(`%eax`) | 将做了符号扩展的字节传送到字<br />将做了符号扩展的字节传送到双字<br />将做了符号扩展的字传送到双字<br />将做了符号扩展的字节传送到四字<br />将做了符号扩展的字传送到四字<br />将做了符号扩展的双字传送到四字<br />把`%eax`符号扩展到`%rax` |

### 3.4.4压入和弹出栈数据

**栈顶元素的地址通常是所有栈中元素地址中最低的**。

| 指令                                                   | 效果                                                         | 描述                                       |
| ------------------------------------------------------ | ------------------------------------------------------------ | ------------------------------------------ |
| `pushq`        $S$<br /><br />`popq`         $D$<br /> | $R[\%rsp]\leftarrow R[\%rsp]-8$;<br />$M[R[\% rsp]]\leftarrow S$<br />$D\leftarrow M[R[\%rsp]]$;<br />$R[\%rsp]\leftarrow R[\%rsp]+8$ | 将四字压入栈<br /><br />将四字弹出栈<br /> |

`pushq`相当于

```bash
subq $8,%rsp
movq %rbp,(%rsp)
```

`popq`相当于

```bash
movq (%rsp),%rax
addq $8,%rsp
```

**栈中被写过的内存位置直到被覆盖前不会被更改**。

**程序可以用标准的内存寻址方法访问栈内的任意位置**。

## 3.5算术和逻辑操作

| 指令          | 效果             | 描述         |
| ------------- | ---------------- | ------------ |
| `leaq`  $S,D$ | $D\leftarrow\&S$ | 加载有效地址 |

| 指令     | 效果                 | 描述 |
| -------- | -------------------- | ---- |
| `INC`  D | $D\leftarrow D+1$    | 加1  |
| `DEC`  D | $D\leftarrow D-1$    | 减1  |
| `NEG`  D | $D\leftarrow -D$     | 取负 |
| `NOT`  D | $D\leftarrow \sim D$ | 取补 |

| 指令          | 效果                    | 描述 |
| ------------- | ----------------------- | ---- |
| `ADD`  $S,D$  | $D\leftarrow D+S$       | 加   |
| `SUB`  $S,D$  | $D\leftarrow D-S$       | 减   |
| `IMUL`  $S,D$ | $D\leftarrow D*S$       | 乘   |
| `XOR`  $S,D$  | $D\leftarrow D\oplus S$ | 异或 |
| `OR`  $S,D$   | $D\leftarrow D~|~S$     | 或   |
| `AND`  $S,D$  | $D\leftarrow D\&S$      | 与   |

| 指令         | 效果                  | 描述     |
| ------------ | --------------------- | -------- |
| `SAL`  $k,D$ | $D\leftarrow D<<S$    | 左移     |
| `SHL`  $k,D$ | $D\leftarrow D<<S$    | 同上     |
| `SAR`  $k,D$ | $D\leftarrow D>>_AS$  | 算术右移 |
| `SHR`  $k,D$ | $D\leftarrow D>>_L k$ | 逻辑右移 |

### 3.5.1加载有效地址

`leaq`实际上是`movq`指令的变形，它的指令形式是从内存读数据到寄存器，但实际上它根本就没有引用内存，是**将有效地址写入到目的操作数**（**必须是寄存器**）。

其几乎等效于`&`取址符。

### 3.5.2一元和二元操作

见上方表格，第二个即一元操作。

- 一元操作的操作数**可以是 一个寄存器，也可以是一个内存位置**。

- 二元操作中，**当第二个操作数为内存地址时，处理器必须从内存读出值，执行操作，再把结果写回内存**。

  内存操作需要显式指定大小

  - 如`BYTE`（1字节）、`WORD`（2字节）、`DWORD`（4字节）、`QWORD`（8字节）。

    ```bash
    mov  DWORD PTR [eax], 123  将 123 写入 eax 指向的地址，以双字（4字节）形式存储
    inc  BYTE PTR [mem]        对内存地址 mem 处的字节（1字节）进行加1操作
    neg  WORD PTR [ebx]        对 ebx 指向的地址处的字（2字节）取负
    ```

    

### 3.5.3移位操作

移位量可以是一个立即数，或者放在单字节寄存器`％cl`中。（这些指令很特别，因为只允许以这个特定的寄存器作为操作数。）

移位操作对$w$位长的数据值进行操作，移位量是由`％cl`寄存器的低$m$位决定的。

### 3.5.5特殊的算术操作

Intel把16字节的数称为八字(oct word)。下面描述的是支持产生两个64位数字的全128位乘积以及整数除法的指令。

| 指令                          | 效果                                                         | 描述                           |
| ----------------------------- | ------------------------------------------------------------ | ------------------------------ |
| `imulq`  $S$<br />`mulq`  $S$ | $R[\%rdx]:R[\%rax]\leftarrow S\times R[\%rax]$<br />$R[\%rdx]:R[\%rax]\leftarrow S\times R[\%rax]$ | 有符号全乘法<br />无符号全乘法 |
| `clto`                        | $R[\%rdx]:R[\%rax]\leftarrow符号扩展(R[\%rax])$              | 转换为八字                     |
| `idivq`  $S$                  | $R[\%rdx]\leftarrow R[\%rdx]: R[\%rax]\mod S$<br />$R[\%rdx]\leftarrow R[\%rdx]:R[\%rax]÷S$ | 有符号除法                     |
| `divq`  $S$                   | $R[\%rdx]\leftarrow R[\%rdx]: R[\%rax]\mod S$<br />$R[\%rdx]\leftarrow R[\%rdx]:R[\%rax]÷S$ | 无符号除法                     |

两个64位有符号或无符号整数相乘得到的乘积需要128位来表示。

- `mulq`，`imulq`都要求一个参数必须在寄存器`%rax`中，而另一个作为指令的源操作数给出。然后乘积存放在寄存器`％rdx`（高64位）和`％rax`（低64位）中。

*注意区分一个和两个操作数的 `mulq`* 。

- 有符号除法指令过`idivl`将寄存器`％rdx`（高64位）和`％rax`（低64位）中的128位数作为**被除数**，而**除数**作为指令的操作数给出。指令将**商**存储在寄存器`％rax`中，将**余数**存储在寄存器`％rdx`中。
  除数通常是一个64位的值，应该存放在`％rax`中，`％rdx`的位应该设置为全0（无符号运算）或者`％rax`的符号位（有符号运算）。
  *后面这个操作可以用指令 `cqto` （有时也是 `cqo` ）来完成。这条指令不需要操作数而是隐含读出 `％rax` 的符号位，并将它复制到 `％rdx` 的所有位*。

## 3.6控制

### 3.6.1条件码

| 条件码 | 标志类型 | 作用                                                       |
| ------ | -------- | ---------------------------------------------------------- |
| `CF`   | 进位标志 | 最近的操作使最高位产生了进位。可用来检查无符号操作的溢出。 |
| `ZF`   | 零标志   | 最近的操作得出的结果为0。                                  |
| `SF`   | 符号标志 | 最近的操作得到的结果为负数。                               |
| `OF`   | 溢出标志 | 最近的操作导致一个补码溢出——正溢出或负溢出。               |

条件码(condition code)寄存器，它们描述了最近的算术或逻辑操作的属性。可以检测这些寄存器来执行条件分支指令。

| 指令             | 基于      | 描述     |
| ---------------- | --------- | -------- |
| `CMP`  $S_1,S_2$ | $S_2-S_1$ | 比较     |
| `cmpb`           |           | 比较字节 |
| `cmpw`           |           | 比较字   |
| `cmpl`           |           | 比较双字 |
| `cmpq`           |           | 比较四字 |

| 指令              | 基于       | 描述     |
| ----------------- | ---------- | -------- |
| `TEST`  $S_1,S_2$ | $S_1\&S_2$ | 测试     |
| `testb`           |            | 测试字节 |
| `testw`           |            | 测试字   |
| `testl`           |            | 测试双字 |
| `testq`           |            | 测试四字 |

这两类指令（有8、16、32和64位形式），它们只设置条件码而不改变任何其他寄存器。

### 3.6.2访问条件码

条件码通常不会直接读取，常用的使用方法有三种：

1. 可以根据条件码的某种组合， 将一个字节设置为0或者1。
2. 可以条件跳转到程序的某个其他的部分。
3. 可以有条件地传送数据。

| 指令         | 同义名   | 效果                                    | 设置条件             |
| ------------ | -------- | --------------------------------------- | -------------------- |
| `sete`  $D$  | `setz`   | $D\leftarrow ZF$                        | 相等/零              |
| `setne`  $D$ | `setnz`  | $D\leftarrow \sim ZF$                   | 不等/非零            |
| `sets`  $D$  |          | $D\leftarrow SF$                        | 负数                 |
| `setns`  $D$ |          | $D\leftarrow\sim SF$                    | 非负数               |
| `setg`  $D$  | `setnle` | $D\leftarrow\sim(SF\oplus OF)\&\sim ZF$ | 大于(有符号>)        |
| `setge`  $D$ | `setnl`  | $D\leftarrow \sim(SF\oplus OF)$         | 大于等于(有符号>=)   |
| `setl`  $D$  | `setnge` | $D\leftarrow SF\oplus OF$               | 小于(有符号<)        |
| `setle`  $D$ | `setng`  | $D\leftarrow (SF\oplus OF)|ZF$          | 小于等于(有符号<=)   |
| `seta`  $D$  | `setnbe` | $D\leftarrow \sim CF\& \sim ZF$         | 超过(无符号>)        |
| `setae`  $D$ | `setnb`  | $D\leftarrow \sim CF$                   | 超过或相等(无符号>=) |
| `setb`  $D$  | `setnae` | $D\leftarrow CF$                        | 低于(无符号<)        |
| `setbe`  $D$ | `setna`  | $D\leftarrow CF|ZF$                     | 低于或相等(无符号<=) |

该操作会将目标操作数**第一位设置为0或1**。如果需要零扩展，请使用`MOVZ`指令。

### 3.6.3跳转指令

| 指令              | 同义名 | 跳转条件                     | 描述                 |
| ----------------- | ------ | ---------------------------- | -------------------- |
| `jmp`  $Lable$    |        | 1                            | 直接跳转             |
| `jmp`  $*Operand$ |        | 1                            | 间接跳转             |
| `je`  $Label$     | `jz`   | ZF                           | 相等/零              |
| `jne`  $Label$    | `jnz`  | -ZF                          | 不相等/非零          |
| `js`  $Label$     |        | SF                           | 负数                 |
| `jns`  $Label$    |        | -SF                          | 非负数               |
| `jg`  $Label$     | `jnle` | $\sim(SF\oplus OF)\&\sim ZF$ | 大于(有符号>)        |
| `jge`  $Label$    | `jnl`  | $\sim(SF\oplus OF)$          | 大于或等于(有符号>=) |
| `jl`  $Label$     | `jnge` | $SF\oplus OF$                | 小于(有符号<)        |
| `jle`  $Label$    | `jng`  | $(SF\oplus OF)|ZF$           | 小于或等于(有符号<=) |
| `ja`  $Label$     | `jnbe` | $\sim CF\&\sim ZF$           | 超过(无符号>)        |
| `jae`  $Label$    | `jnb`  | $\sim CF$                    | 超过或相等(无符号>=) |
| `jb`  $Label$     | `jnae` | $CF$                         | 低于(无符号<)        |
| `jbe`  $Label$    | `jna`  | $CF|ZF$                      | 低于或相等(无符号<=) |

跳转(jump)指令会导致执行切换到程序中一个全新的位置。

`jmp  *%rax`会跳转到`%rax`中的值而`jmp  *(%rax)`以`%rax`中的值作为读地址，从内存中读出跳转目标。

### 3.6.4跳转指令的编码

跳转指令有几种不同的编码，但是最常用都是**PC相对的(PC-relative)**。

第一种编码方法是：它们会将目标指令的地址与紧跟在跳转指令后面那条指令的地址之间的差作为编码。这些地址偏移量可以编码为1、2或4个字节。
**目标地址=当前指令的下一条指令地址+偏移量**。

第二种编码方法是：给出绝对地址，用4个字节直接指定目标。汇编器和链接器会选择适当的跳转目的编码。

*`rep` 和 `ret` 指令通常用来实现重复的字符串操作，这里用 `rep` 后面跟 `ret` 的组合来避免使 `ret` 指令成为条件跳转指令的目标，从而使处理器不能预测 `ret` 指令目的（暂时可以无视）*。

### 3.6.5用条件控制来实现条件分支

其汇编代码可以用`if`和`goto`的形式去理解。

### 3.6.6用条件传送来实现条件分支

实现条件操作一种策略是使用**数据的条件转移**。这种方法计算一个条件操作的两种结果，然后再根据条件是否满足从中选取一个。

例如：

```bash
cmpq %rsi, %rdi
cmovge %rdx, %rax
ret
```

使用另一种策略即**控制的条件转移**：

**分支条件结果未决时**：处理器无法确定下一条指令的地址，导致流水线暂停（称为**流水线气泡**），性能显著下降。

- **减少流水线停顿**：通过预测分支的方向（跳转/不跳转），提前执行预测路径的指令，保持流水线满载。
- **提升指令级并行性（ILP）**：避免等待分支条件计算完成，充分利用处理器的执行资源。

**预测失败会导致更多的时钟周期的惩罚**。

| 指令            | 同义名    | 传送条件     | 描述                 |
| --------------- | --------- | ------------ | -------------------- |
| `cmove`  $S,R$  | `cmovz`   | ZF           | 相等/零              |
| `cmovne`  $S,R$ | `cmovnz`  | ~ZF          | 不相等/非零          |
| `cmovs`  $S,R$  |           | SF           | 负数                 |
| `cmovns`  $S,R$ |           | ~SF          | 非负数               |
| `cmovg`  $S,R$  | `cmovnle` | ~(SF^OF)&~ZF | 大于(有符号>)        |
| `cmovge`  $S,R$ | `cmovnl`  | ~(SF^OF)     | 大于或等于(有符号>=) |
| `cmovl`  $S,R$  | `cmovnge` | SF^OF        | 小于(有符号<)        |
| `cmovle`  $S,R$ | `cmovng`  | (SF^OF)\|ZF  | 小于或等于(有符号<=) |
| `cmova`  $S,R$  | `cmovnbe` | ~CF&~ZF      | 超过(无符号>)        |
| `cmovae`  $S,R$ | `cmovnb`  | ~CF          | 超过或相等(无符号>=) |
| `cmovb`  $S,R$  | `cmovnae` | CF           | 低于(无符号<)        |
| `cmovbe`  $S,R$ | `cmovna`  | CF\|ZF       | 低于或相等(无符号<=) |

条件传送指令。当传送条件满足时，指令把源值S复制到目的R。

**实验表明**：只有当两个分支（条件成立/不成立）的代码必须**可安全提前计算**，且不会引发异常或改变程序状态，同时**容易计算**时，例如表达式分别都只是一条加法指令，它才会使用条件传送。即使许多分支预测错误的开销会超过更复杂的计算，GCC还是会使用条件控制转移。

### 3.6.7循环

可以用**条件测试和跳转组合**起来实现循环的效果。GCC和其他汇编器产生的循环代码主要基于两种基本的循环模式。

**让我们从`do-while`开始**：

```c
int f(int x){
	int res=0;
    do{
        res+=x;
    }
    while(x<=100);
    return res;
}
```

这个形式可以翻译成：

```c
int f(int x){
	int res=0;
	loop:
	if(x<=100){
		res+=x;
		goto loop;
	}
	return res;
}
```

所以对应的汇编代码可以是：

```bash
	movl	$0, %eax
.L2:
	addl	%ecx, %eax
	cmpl	$100, %ecx
	jle	.L2
	ret
```

**`while`循环**：

第一种翻译方法：`jump to middle`

```c
int f(int n){
	int res=1;
	while(n>1){
		res*=n;
		n=n-1;
	}
	return res;
}
```

我们把它翻译成：

```c
int f(int n){
	int res=1;
	goto test;
loop:
	res *=n;
	n=n-1;
test:
	if(n>1)goto loop;
	return res;
}
```

对应的汇编代码可以是：

```bash
	movl	$1, %eax
	jmp	.L5
.L6:
	imulq	%rdi, %rax
	subq	$1, %rdi
.L5:
	cmpq	$1, %rdi
	jg	.L6
	rep; ret
```

第二种翻译方法：`guarded-do`

```c
int f(int n){
	int res=1;
	while(n>1){
		res*=n;
		n=n-1;
	}
	return res;
}
```

我们把它翻译成：

```c
int f(int n){
	int res=1;
    if(n<=1)goto done;
loop:
	res *=n;
	n=n-1;
done:
	return res;
}
```

对应的汇编代码可以是：

```bash
	cmpq	$1, %rdi
	jle	.L7
	movl	$1, %eax
.L6:
	imulq	%rdi, %rax
	subq	$1, %rdi
	cmpq	$1, %rdi
	jne	.L6
	rep; ret
.L7:
	movl	$1, %eax
	ret
```

**`for`循环**

GCC为`for`循环产生的代码是`while`循环的两种翻译之一，这取决于优化的等级。

### 3.6.8switch语句

`switch`使用跳转表(jump table)这种数据结构使得实现更加高效。

跳转表是一个数组，表项`t`是一个代码段的地址，这个代码段实现当`case`索引值等于1时程序应该采取的动作。

程序代码用`case`索引值来执行一个跳转表内的数组引用，确定跳转指令的目标。

当`case`情况数量比较多（例如 4 个以上），并且值的范围跨度比较小时，就会使用跳转表。

 **不使用跳转表的情况与条件控制类似**，我们具体讲一下跳转表类型：

源代码：

```c
int f(int x){
    switch(x){
        case 100:
            x+=1;
            break;
        case 102:
            x+=2;
            break;
        case 103:
            x+=3;
            break;
        case 104:
            x<<=4;
            break;
        case 106:
            x-=5;
            break;
        default:
            x-=100;
    }
    return x;
}
```

对应的汇编代码：

```bash
f:
	leal	-100(%rcx), %eax    #减去100，使得方便处理偏移量
	cmpl	$6, %eax    #大于6则进入default
	ja	.L2
	movl	%eax, %eax    #占位符
	leaq	.L4(%rip), %rdx    #将.L4标签的地址加载到rdx寄存器中
	movslq	(%rdx,%rax,4), %rax    #从内存地址%rdx+%rax*4处读取一个32位有符号整数，并将其扩展为64位后存入rax。此时%rax的值是目标地址相对于.L4的偏移量
	addq	%rdx, %rax    #.L4存储的是相对偏移量，需要加上.L4的基地址rdx，得到目标地址的完整位置
	jmp	*%rax    #根据rax中的地址进行间接跳转，执行对应的代码块
	.section .rdata,"dr"    #声明一个只读数据段，属性为 dr（data, readonly）。
	.align 4    #数据按 4 字节对齐。
.L4:    #跳转表
	.long	.L8-.L4
	.long	.L2-.L4
	.long	.L7-.L4
	.long	.L6-.L4
	.long	.L5-.L4
	.long	.L2-.L4
	.long	.L3-.L4
	.text
.L8:
	leal	1(%rcx), %eax
.L1:
	ret
.L7:
	leal	2(%rcx), %eax
	jmp	.L1
.L6:
	leal	3(%rcx), %eax
	jmp	.L1
.L5:
	movl	%ecx, %eax
	sall	$4, %eax
	jmp	.L1
.L3:
	leal	-5(%rcx), %eax
	jmp	.L1
.L2:
	leal	-100(%rcx), %eax
	jmp	.L1
```

比较难理解的是跳转表部分：

假设：

- `.L4`的地址是`0x1000`
- `.L8`的地址是`0x1020`

那么：

`leaq	.L4(%rip), %rdx`后`%rdx`是`0x1000`
`movslq	(%rdx,%rax,4), %rax`后`%rax`是`0x20`
`addq	%rdx, %rax`后`rax`是`0x1020`

### 3.7过程

过程提供了一种封装代码的方式，用一组指定的参数和一个可选的返回值实现了某种功能。

假设过程`P`调用过程`Q`，`Q`执行后返回到`P`。这些动作包括下面一个或多个机制：

**传递控制**：在进入过程`Q`的时候，程序计数器必须被设置为`Q`的代码的起始地址，然后在返回时，要把程序计数器设置为`P`中调用`Q`后面那条指令的地址。

**传递数据**：`P`必须能够向`Q`提供一个或多个参数，`Q`必须能够向`P`返回一个值。

**分配和释放内存**：在开始时，`Q`可能需要为局部变量分配空间，而在返回前，又必须释放这些存储空间。 

x86-64 的过程实现包括一组特殊的指令和一些对机器资源（例如寄存器和程序内存）使用的约定规则。它遵循了被认为是最低要求策略的方法，只实现上述机制中每个过程所必需的那些。

### 3.7.1运行时栈

过程`P`调用过程`Q`：

- 当`Q`在执行时，`P`以及所有在向上追溯到`P`的询用链中的过程，都是**暂时被挂起**的。
- 当`Q`运行时，它只需要为局部变量分配新的存储空间，或者设置到另一个过程的调用。
- 当`Q`返回时，任何它所分配的局部存储空间都可以**被释放**。

因此，程序可以用栈来管理它的过程所需要的**存储空间**，栈和程序寄存器存放着传递控制和数据、分配内存所需要的信息。 当`P`调用`Q`时，控制和数据信息添加到栈尾。当`P`返回时，这些信息会释放掉。

*x86-64的栈向低地址方向增长*。

栈指针`%rsp`指向栈顶（更低的地址）元素。

`pushq`：**将数据存入栈中**，将栈指针减小一个适当的量可以为没有指定初始值的数据在栈上分配空间。

`popq`：**将数据从栈中取出**，通过增加栈指针来释放空间。

**栈帧**：

当x86-64过程需要的存储空间超出寄存器能够存放的大小时，就会在栈上分配空间（栈帧）。

栈帧的部分包括：

- **函数参数**：

  在函数调用时，参数通常通过寄存器传递，但为了确保函数调用的独立性，栈中也会保留一份参数的副本。

- **局部变量**：

  - 函数内部声明的局部变量存储在栈帧中，以确保不同函数调用之间的局部变量互不干扰。
  - 局部变量的大小和数量决定了栈帧中用于存储局部变量的空间大小。

- **返回地址**：

  在函数调用时，返回地址被压入栈中，函数执行完毕后，通过弹出返回地址来恢复执行流程。

- **保存的寄存器**：

  - 函数通常会将需要使用的寄存器的值保存在栈帧中。
  - 这些保存的寄存器值在函数返回前被恢复，以确保调用函数的寄存器状态不受影响。

- **栈帧基址指针（Base Pointer, RBP）**：

  - 栈帧基址指针是一个寄存器，用于指向当前栈帧的基地址。

**大多数过程的栈帧都是定长的，在过程的开始就分配好了。但是有些过程需要变长的帧**。

**当所有的局部变量都可以保存在寄存器中，而且该函数不会调用任何其他函数时，并不需要栈帧**。

### 3.7.2转移控制

将控制从函数`P`转移到函数`Q`只需要简单地把程序计数器(PC)设置为`Q`的代码的起始位置。 

返回过程要通过`call`指令调用过程`Q`来记录。

| 指令               | 描述             |
| ------------------ | ---------------- |
| `call`  $Label$    | 过程调用         |
| `call`  $·Operand$ | 过程调用         |
| `ret`              | 从过程调用中返回 |

`call Q`会把`P`的地址`A`压入栈中，将`PC`设置为`Q`的起始地址。

`ret`会从栈中弹出地址`A`，并把`PC`设置为`A`。

### 3.7.3数据传送

x86-64中，大部分过程间的数据传送是通过寄存器实现的。

寄存器的使用具有特殊顺序（详见前表），可以通过64位寄存器适当的部分访问小于64位的参数。

存储参数的寄存器只有6个，当函数有大于6个整型参数时，**超出6个的部分就要通过栈来传递**：

1. 要把参数1~6复制到对应的寄存器，为超出6个部分的参数分配空间，把参数7~n放到栈上，而参数7位于栈顶。
   其中通过栈传递参数时，所有的数据大小都向8的倍数对齐。
2. 程序再执行`call`指令将控制转移到过程`Q`。

例：

```c
void f(long a1,long *a1p,int a2,int *a2p,short a3,short *a3p,char a4,char *a4p){
	*a1p+=a1;
    *a2p+=a2;
    *a3p+=a3;
    *a4p+=a4;
}
```

```bash
f:
	movq	16(%rsp), %rax  #从栈获取a4p
	addq	%rdi, (%rsi)
	addl	%edx, (%rcx)
	addw	%r8w, (%r9)
	movl	8(%rsp), %edx  #从栈获取a4
	addb	%dl, (%rax)
	ret
```

*`movl`从内存读入4字节，而`addb`只使用其中的低位一字节以对应char的字节数*。

### 3.7.4栈上的局部存储

有些时候局部数据必须存放在内存中，包括：

- 寄存器不足够存放所有的本地数据。
- 对一个局部变量使用地址运算符&，因此必须能够为它产生一个地址。
- 某些局部变量是数组或结构，因此必须能够通过数组或结构引用被访问到。

例：

```c
long call_f(){
	long x1=1;
	int x2=2;
	short x3=3;
	char x4=4;
	f(x1,&x1,x2,&x2,x3,&x3,x4,&x4);
	return (x1+x2)*(x3-x4);
}
```

```bash
call_f:
	subq	$32, %rsp
	movq	$1, 24(%rsp)
	movl	$2, 20(%rsp)
	movw	$3, 18(%rsp)
	movb	$4, 17(%rsp)
	leaq	17(%rsp), %rax
	movq	%rax, 8(%rsp)
	movl	%4, (%rsp)
	leaq	18(%rsp), %r9
	movl	$3, %r8d
	leaq	20(%rsp), %r9
	movl	$3, %r8d
	leaq	24(%rsp), %rsi
	movl	$1, %edi
	call	f
	movslq	20(%rsp), %rdx
	addq	24(%rsp), %rdx
	movswl	18(%rsp), %eax
	movsbl	17(%rsp), %ecx
	subl	%ecx, %eax
	cltq
	imulq	%rdx, %rax
	addq	$32, %rsp
	ret
```

可以看到代码中第2~15行是为调用函数f做准备。其中包括**为局部变量和函数参数建立栈帧**，**将函数参数加载至寄存器**。

在栈上分配局部变量x1~x4，它们具有不同的大小：24~31(x1)，20~23(x2)，18~19(x3)和17(x4) 。用`leaq`指令生成到这些位置的指针（第7、10、12和14行）。参数7（值为4)和参数8（指向x4的位置的指针）存放在栈中相对于栈指针偏移量为0和8的地方(第8~9行)。

当调用过程f时，参数7和参数8现在位于相对于栈指针偏移量为8和16的地方，因为返回地址这时已经被压入栈中了。

下图是call_f的栈帧。

<img src="D:\黄羽翔\大学\计算机系统基础\pictures\image-20250321142208224.png">

在程序结束前，把栈指针加32，释放这个栈帧。

### 3.7.5寄存器中的局部存储空间

寄存器组是唯一被所有过程共享的资源，因此必须确保当一个过程**调用**另一个过程（被调用者）时，被调用者不会**覆盖**调用者稍后会使用的寄存器值。为此，x86-64采用了一组统一的寄存器使用惯例，所有的过程（包括程序库）都必须遵循。

**通常**：`%rbx`、`%rbp`和`%r12~%r15`是**被调用者保存寄存器**。发生P过程调用Q过程的时候，Q必须保存这些寄存器的值，并确保它们在Q返回时的值也是一样的。

- 可以不去改变这些寄存器的值。
- 也可以把原始值压入栈中，在返回前从栈中弹出旧值，保存回寄存器中。

其它寄存器除了`%rsp`，都是**调用者保存寄存器**。过程P在某个此类寄存器中有局部数据，然后调用过程Q。因为Q可以随意修改这个寄存器，所以P要在调用之前首先保存好这个数据。

执行过程中**值的弹出顺序与压入顺序相反**。

### 3.7.6递归过程

栈规则提供了一种机制，每次函数调用都有它自己**私有的状态信息**（**保存的返回位置**和**被调用者保存寄存器的值**）存储空间。如果需要，它还可以提供局部变量的存储。

栈分配和释放的规则很自然地就与函数调用-返回的顺序匹配。这种实现函数调用和返回的方法甚至对更复杂的情况也适用，包括相互递归调用（例如，过程P调用Q，Q再调用P）。

## 3.8数组分配和访问

C语言中会产生指向数组中元素的指针，并对这些指针进行运算。

### 3.8.1基本原则

声明`T A[N]`。

- 起始位置表示为$x_A$。它在内存中分配一个`L•N`字节的连续区域，这里`L`是数据类型`T`的大小（单位为字节）。
- 其次，它引入了标识符`A`，可以用`A`来作为指向数组开头的指针，这个指针的值就是$x_A$。可以用$0\sim N-1$的整数索引来访问该数组元素。数组元素$i$会被存放在地址为$x_A+L·i$的地方。

x86-64的内存引用指令可以用来简化数组访问。例如，假设`E`是一个int 型的数组，
而我们想计算`E[i]`，在此，`E`的地址存放在寄存器`%rdx`中，而`i`存放在寄存器`％rcx`中。

```bash
movl (rdx,%rcx,4) %eax
```


会执行地址计算$x_E+4i$，读这个内存位置的值，并将结果存放到寄存器`％eax`中。

### 3.8.2指针运算

C语言允许对指针进行运算。也可以用`&`和`*`产生指针和间接引用指针。

| 表达式     | 类型   | 值                  | 汇编代码                     |
| ---------- | ------ | ------------------- | ---------------------------- |
| `E`        | `int*` | $x_E$               | `movq %rdx,%rax`             |
| `E[0]`     | `int`  | $\ce{M}[x_E]$       | `movl (%rdx),%rax`           |
| `E[i]`     | `int`  | $\ce{M}[x_E+4i]$    | `movl (%rdx,%rcx,4),%eax`    |
| `&E[2]`    | `int*` | $x_E+8$             | `leaq 8(%rdx),%rax`          |
| `E+i-1`    | `int*` | $x_E+4i-4$          | `leaq -4(%rdx,%rcx,4),%rax`  |
| `*(E+i-3)` | `int`  | $\ce{M}[x_E+4i-12]$ | `movl -12(%rdx,%rcx,4),%eax` |
| `&E[i]-E`  | `long` | $i$                 | `movq %rcx,%rax`             |

### 3.8.3嵌套的数组

以`int A[R][C]`为例：

- 数组的大小为$4\times R\times C$字节。
- 行优先顺序排列，数组元素的内存地址为$\& A[i][j]=x_A+L(C·i+j)$。

可以用下面的代码将数组元素`A[i][j]`复制到寄存器`％eax`中。

```bash
leaq (%rsi,%rsi,2), %rax
leaq (%rdi,%rax,4), %rax
movl (%rax,%rdx,4), %eax
```

**更多维的数组**：

以`int A[R][C][D]`为例：

- 数组的大小为$4\times R\times C$字节。
- 行优先顺序排列，数组元素的内存地址为$A[i][j][k]=x_A+L[C·D·i+D·j]$。

### 3.8.4定长数组

C语言编译器能够优化定长多维数组上的操作代码。

例如：

```c
int fix_prod_ele(fix_matrix A,fix_matrix B,long i,long k) {
	long j;
	int result=O;
	for(j=O;j<N;j++)result+=A[i][j]*B[j][k];
	return result;
}
```

会被优化为：

```c
int fix_prod_ele_opt(fix_matrix A,fix_matrix B,long i,long k) {
	int *Aptr=&A[i][0];
	int *Bptr=&B[0][k];
	int *Bend=&B[N][k];
	int result=0;
	do {
		result+=*Aptr* *Bptr;
		Aptr++;
		Bptr+=N;
	}while(Bptr!=Bend);
	return result;
}
```

- **减少了索引运算**（如`A[i][j]`→`*Aptr`）。
- **减少了循环判断**，利用`Bend`作为终止条件。
- **减少了乘法运算**（`Bptr+=N`直接跳到下一行，而不是计算`B[j][k]`的索引）。

### 3.8.5变长数组

ISOC99后我们可以允许数组的维度是**表达式**，**在数组被分配的时候才计算出来**。

例如：

```c++
int var_ele(long n, int A[n][n], long i, long j) {
	return A[i][j];
}
```

GCC为这个函数产生的代码可能是：

```bash
var_ele:
  imulq  %rdx, %rdi
  leaq   (%rsi,%rdi,4), %rax
  movl   (%rax,%rcx,4), %eax
ret
```

这段代码计算元素$i$，$j$的地址为$x_A+4(n·i+j)$，类似于定长数组的地址计算，不同点在于：

1. 由于增加了参数$n$，寄存器的使用变化了。
2. 用了乘法指令来计算$n·i$，而不是用`leaq`指令来计算$3i$。

因此引用变长数组只需要对定长数组做一点儿概括。动态的版本必须用乘法指令对$i$伸缩$n$倍，而不能用一系列的移位和加法。

**在一个循环中引用变长数组时，编译器常常可以利用访问模式的规律性来优化索引的计算**。

原始C代码：

```c
int var prod_ele(long n, int A[n][n], int B[n][n], long i, long k) {
	long j;
	int result=O;
	for(j=0;j<n;j++)result+=A[i][j]*B[j][k];
	return result;
}
```

优化后的C代码：

```c
int var prod_ele_opt(long n, int A[n][n], int B[n][n], long i, long k) {
	int *Arow=A[i];
	int *Bptr=&B[0][k];
	int result=0;
	long j;
	for(j=0;j<n;j++){
		result+=Arow[j]* *Bptr;
		Bptr+=n;
	}
	return result;
}
```

我们看到程序既使用了伸缩过的值$4n$（寄存器`％r9`）来增加`Bptr`，也使用了$n$的值（寄存器`％rdi`中）来检查循环的边界。

因此：**如果允许使用优化，GCC能够识别出程序访问多维数组的元素的步长。然后生成的代码会避免直接应用乘法。不论生成基于指针的代码还是基于数组的代码，这些优化都能显著提高程序的性能。**

## 3.9异质的数据结构

### 3.9.1结构

结构的所有组成部分都存放在**内存中一段连续的区域内**，而**指向结构的指针就是结构第一个字节的地址**。

编译器维护关于每个结构类型的信息，指示每个字段的字节偏移。它以这些偏移作为内存引用指令中的位移，从而产生对结构元素的引用。

例如：

```c
struct rec {  //下面是变量相对于结构第一个字节地址的偏移
	int i;  //0~3
	int j;  //4~7
	int a[2];  //8~15
	int *p;  //16~23
};
```

用一个例子展示结构体中编译器的行为：

```c
r->p=&r->a[r->i+r->j];
```

开始时$r$在寄存器`%rdi`中。

```bash
movl    4(%rdi), %eax
addl    (%rdi), %eax
cltq
leaq    8(%rdi,%rax,4), %rax
movq    %rax, 16(%rdi)
```

综上所述，结构的各个字段的选取完全是在编译时处理的。机器代码不包含关于字段声明或字段名字的信息。

### 3.9.2联合

联合提供了一种方式，能够规避C语言的类型系统，允许以多种类型来引用一个对象。

联合声明的语法与结构的语法一样，只不过语义相差比较大。它们是**用不同的字段来引用相同的内存块**，也因此：**一个联合的总的大小等于它最大字段的大小**。

一个很好的例子：我们想实现一颗二叉树，若为叶子结点，其左右孩子存储值，否则存储指向左右孩子结点的指针

```c
struct node_s {
	struct node_s *left;
	struct node_s *right;
	double data[2];
};
```

这种做法显然很浪费空间，我们可以联合！

```c
union node_u {
	struct {
		union node_u *left;
		union node_u *right;
	}internal;
	double data[2];
};
```

这样，每个节点就只需要16个字节。

除了**节省空间**，联合还可以用来**访问不同数据类型的位模式**。

```c
unsigned long double2bits(double d) {
	union {
		double d;
		unsigned long u;
	}temp;
	temp.d=d;
	return temp.u;
};
```

此外，联合意味着**字节顺序问题**也很重要。

```c
double uu2double(unsigned wordO, unsigned word1){
	union {
		double d;
		unsigned u[2];
	}temp;
	temp.u[0]=word0;
	temp.u[1]=word1;
	return temp.d;
}
```

在小端法机器上，参数`word0`是`d`的低位4个字节，而`word1`是高位4个字节。在大端法机器上，这两个参数的角色刚好相反。

### 3.9.3数据对齐

许多计算机系统对基本数据类型的合法地址做出了一些限制，要求某种类型对象的地址必须是某个值（通常是2、4或8）的倍数。

这种对齐限制**简化了形成处理器和内存系统之间接口的硬件设计**。比如借此我们可以用一个内存操作来读或者写值，否则对象可能被分放在两个8字节内存块，我们需要执行两次内存访问。

- 跳转表的汇编代码声明在第2行可能包含下面这样的命令：

  ```bash
  .align 8
  ```

  后面的元素都会遵守8字节对齐的限制。

- 对于包含结构的代码，编译器可能需要在字段的分配中插入间隙，以保证每个结构元素都满足它的对齐要求。而结构本身对它的起始地址也会满足之前的对齐要求，例如：

  ```c
  struct S {
  	int x;  //0~3
  	char s;  //4~4
  	int j;  //8~11
  }d[4];
  ```

  编译器会为结构`S`分配12个字节，

  而结构体的对齐是根据其成员中最大的对齐要求来决定的，所以`d`的元素的地址分别为$x_d,x_d+12,x_d+24,x_d+36$。

## 3.10在机器级程序中将控制与数据结合起来

### 3.10.1理解指针

- **每个指针都对应一个类型**。这个类型表明该指针指向的是哪一类对象。特殊的`void*`类型代表通用指针。指针类型不是机器代码中的一部分，而是C语言提供的一种**抽象**，帮助程序员避免寻址错误。

- **每个指针都有一个值**。这个值是某个指定类型的对象的地址。特殊的`null`（c++引入了`nullptr`）值表示该指针没有指向任何地方。

- **指针用`&`运算符创建**。我们已经看到，因为`leaq`指令是设计用来计算内存引用的地址的，＆运算符的机器代码实现常常用这条指令来计算表达式的值。

- **`*`操作符用于间接引用指针**。其结果是一个值，它的类型与该指针的类型一致。

- **数组与指针紧密联系**。一个数组的名字可以像一个指针变量一样引用（但是不能修
  改）。数组引用（例如`a[3]`）与指针运算和间接引用（例如`＊(a+3)`）有一样的效果。

- **将指针从一种类型强制转换成另一种类型，只改变它的类型，而不改变它的值**。

  强制类型转换的一个效果是改变指针运算的伸缩。
  例如，如果`p`是一个`char`类型的指针，它的值为$p$，那么表达式`(int*)p+7`计算为$p+28$，而`int*)(p+7)`计算为$p+7$ 。（~~强制类型转换的优先级高于加法~~。）

- **指针也可以指向函数**。函数指针的值是该函数机器代码表示中第一条指令的地址。

~~用了java可以发现指针的星号是不必要的，毕竟怎么不能用整型储存地址呢？~~

### 3.10.2应用：使用GDB调试器

这有助于玩$Bomb\_Lab$。

| 命令                           | 效果                                          |
| ------------------------------ | --------------------------------------------- |
| **开始和停止**                 |                                               |
| `quit`                         | 退出GDB                                       |
| `run`                          | 运行程序（在此给出命令行参数）                |
| `kill`                         | 停止程序                                      |
| **断点**                       |                                               |
| `break multstore`              | 在函数`multstore`入口处设置断点               |
| `break *0x400540`              | 在地址`0x400540`处设置断点                    |
| `delete 1`                     | 删除断点1                                     |
| `delete`                       | 删除所有断点                                  |
| **执行**                       |                                               |
| `stepi`                        | 执行1条命令                                   |
| `stepi 4`                      | 执行4条命令                                   |
| `nexti`                        | 类似于`stepi`，但以函数调用为单位             |
| `continue`                     | 继续执行（到下一个断点）                      |
| `finish`                       | 运行到当前函数返回                            |
| **检查代码**                   |                                               |
| `disas`                        | 反汇编当前函数                                |
| `disas multstore`              | 反汇编函数`multstore`                         |
| `disas 0x400544`               | 反汇编位于地址`0x400544`附近的函数            |
| `disas 0x400540,0x40054d`      | 反汇编指定地址范围内的代码                    |
| `print /x $rip`                | 以十六进制输出程序计数器的值                  |
| **检查数据**                   |                                               |
| `print $rax`                   | 以十进制输出`%rax`的内容                      |
| `print /x $rax`                | 以十六进制输出`%rax`的内容                    |
| `print /t $rax`                | 以二进制输出`%rax`的内容                      |
| `print 0x100`                  | 输出`0x100`的十进制表示                       |
| `print /x 555`                 | 输出555的十六进制表示                         |
| `print /x ($rsp+8)`            | 以十六进制输出`%rsp`的内容加上8               |
| `print*(long *)0x7fffffffe818` | 输出位于地址`0x7fffffffe818`的长整数          |
| `print*(long *)($rsp+8)`       | 输出位于地址`$rsp+8`处的长整数                |
| `x/2g 0x7fffffffe818`          | 检查从地址`0x7fffffffe818`开始的双（8字节）字 |
| `x/20bmultstore`               | 检查函数`multstore`的前20个字节               |
| **有用的信息**                 |                                               |
| `info frame`                   | 有关当前栈帧的信息                            |
| `info registers`               | 所有寄存器的值                                |
| `help`                         | 获取有关GDB的信息                             |

### 3.10.3内存越界引用和缓冲区溢出

众所周知，对越界的数组元素的写操作会破坏存储在栈中的状态信息。当程序使用这个被破坏的状态，试图重新加载寄存器或执行`ret`指令时，就会出现很严重的错误。

下面讲一个有趣的例子说明这个问题：

```c
char *gets(char *s) {
	int c;
	char *dest=s;
	while((c=getchar())!='\n'&&c!=EOF)*dest++=c;
	if(c==EOF&&dest==s)return NULL;
	*dest++='\0';
	return s;
}
void echo() {
	char buf[8];
	gets(buf);
	puts(buf);
}
```

上面我们试图输入一个字符串，并将其复制到参数`s`指明的位置。

```bash
echo:
  subq    $24, %rsp
  movq    %rsp, %rdi
  call    gets
  movq    %rsp, %rdi
  call    puts
  addq    $24, %rsp
  ret
```

根据字符串的长度，会出现不同的**被破坏的状态**。

| 输入的字符数量 | 附加的被破坏的状态   |
| -------------- | -------------------- |
| 0~7            | 无                   |
| 9~23           | 未被使用的栈空间     |
| 24~31          | 返回地址             |
| 32+            | `caller`中保存的状态 |

达到24个字符后，就会导致程序跳转到一个完全意想不到的位置。

*一些库函数，如 `strcpy`、`strcat`、`sprintf` ，在目标缓冲区长度小于源字符串时，可能导致缓冲区溢出漏洞*。

**缓冲区溢出的一个更加致命的使用就是让程序执行它本来不愿意执行的函数**。

比如输入给程序一个字符串，这个字符串包含一些可执行代码的字节编码，称为**攻击代码**，还有一些字节会用一个指向攻击代码的指针覆盖返回地址。那么，执行`ret`指令的效果就是跳转到攻击代码。

### 3.10.4对抗缓冲区溢出攻击

1. **栈随机化**

   - 在过去，程序的栈地址非常容易预测。对于所有运行同样程序和操作系统版本的系统来说，在不同的机器之间，栈的位置是相当固定的。

     因此，攻击者可以确定一个常见的Web服务器所使用的栈空间，就可以设计一个在许多机器上都能实施的攻击。这种现象常被称作**安全单一化(security monoculture)**。

   - **栈随机化**的思想使得栈的位置在程序每次运行时都有变化。实现的方式是：

     程序开始时， 在栈上分配一段$0\sim n$字节之间的随机大小的空间，程序不使用这段空间，但是它会导致程序每次执行时后续的栈位置发生了变化。

     分配的范围**必须足够大**，才能获得足够多的栈地址变化，但是**又要足够小**，不至于浪费程序太多的空间。

   - 在Linux中，**栈随机化**巳经变成了标准行为。它属于**地址空间布局随机化（Address-Space Layout Randomization）**，或者简称**ASLR**技术的一种。

     采用**ASLR**，每次运行时程序的不同部分都会被加载到内存的不同区域，不同机器上相同程序的地址映射会**大相径庭**！

   - 面对**ASLR**，攻击者依然有办法：**空操作雪橇（nop sled）**是在实际攻击代码前插入一段很长的`nop`指令，只要攻击者能够猜中这段序列中的某个地址， 程序就会经过这个序列，到达攻击代码。

2. **栈破坏检测**

   - 我们能够在发生了越界写的时候，在造成任何有害结果之前，尝试检测到它。

   - **栈保护者（stack protector）机制**：在栈帧中任何局部缓冲区与栈状态之间存储一个特殊的**金丝雀值**，其为每次运行时随机产生。如果某次运行后金丝雀值被改变，则程序异常中止。
   - 栈保护只会带来很小的性能损失，却能很好地防止缓冲区溢出攻击破坏存储在程序栈上的状态。

3. **限制可执行代码区域**

   - 消除攻击者向系统中插入可执行代码的能力：
   - **限制哪些内存区域能够存放可执行代码**。许多系统允许控制三种访问形式：读（从内存
     读数据）、写（存储数据到内存）和执行（将内存的内容看作机器级代码）。在典型的程序中，只有保存编译器产生的代码的那部分内存才需要是可执行的。

### 3.10.5支持变长栈帧

**变长栈帧**指栈帧的大小在运行时才能确定，而非编译时固定。常见于动态内存需求场景。

------

1. **产生变长栈帧的场景**

- 变长数组（VLA）

  ```c
  void func(int n) {
      int arr[n]; //数组长度依赖参数n，编译时大小未知
  }
  ```

- `alloca`动态分配

  ```c
  void* ptr = alloca(n); //在栈上动态分配空间（n运行时确定）
  ```

- **复杂条件分支**
  不同分支下使用的局部变量大小不同（需运行时决定）。

------

2. **实现机制**

编译器需在运行时动态调整栈指针（`rsp`），通过以下步骤：

1. **计算所需空间**：根据运行时变量计算总栈空间。
2. **调整栈指针**：动态修改栈指针。
3. **维持对齐**：确保调整后的栈指针满足对齐要求。

例如：

```c
void vframe(long n, long idx, long *q) {
	long i;
	long *p[n];
	p[O]=&i;
	for(i=1;i<n;i++)p[i]=q;
    return *p[idx];
}
```

```bash
vframe:
    pushq %rbp
    movq  %rsp, %rbp
    subq  $16, %rsp
    leaq  22(,%rdi,8), %rax
    andq  $-16, %rax
    subq  %rax, %rsp
    leaq  7(%rsp), %rax
    shrq  $3, %rax
    leaq  0(,%rax,8), %r8
    movq  %r8, %rcx
    
.L3:
	movq  %rdx, (%rcx,%rax,8)
	addq  $1, %rax
	movq  %rax, -8(%rdp)
.L2:
	movq  -8(%rbp), %rax
	cmpq  %rdi, %rax
	jl    .L3
	
    leave
    ret
```

在函数的整个执行过程中，使`%rbp`指向那个时刻栈的位置，然后用固定长度的局部变量相对于`％rbp`的偏移量来引用它们。

其中`leave`等价于：

```bash
movq  %rbp, %rsp
popq  %rbp
```

首先把栈指针设置为保存`％rbp`值的位置，然后把该值从栈中弹出到`％rbp` 。这个指令组合具有释放整个栈帧的效果

------

### 3.11浮点代码

处理器的浮点体系结构包括多个方面，会影响对浮点数据操作的程序如何被映射到机器上，包括：

- 如何存储和访问浮点数值。通常是通过某种寄存器方式来完成。
- 对浮点数据操作的指令。
- 向函数传递浮点数参数和从函数返回浮点数结果的规则。
- 函数调用过程中保存寄存器的规则。例如：一些寄存器被指定为调用者保存，而其他的被指定为被凋用者保存。

本书主要讲**AVX2**，即**AVX（Advanced Vector Extension，高级向量扩展）**的第二个版本。

**AVX**浮点体系结构允许数据存储在16个`YMM`寄存器中，它们的名字为`%ymm0~%ymm15`。

| 128-255位 | 0-127位  | 用途              |
| --------- | -------- | ----------------- |
| `%ymm0`   | `%xmm0`  | 1st FP arg.返回值 |
| `%ymm1`   | `%xmm1`  | 2nd FP参数        |
| `%ymm2`   | `%xmm2`  | 3rd FP参数        |
| `%ymm3`   | `%xmm3`  | 4th FP参数        |
| `%ymm4`   | `%xmm4`  | 5th FP参数        |
| `%ymm5`   | `%xmm5`  | 6th FP参数        |
| `%ymm6`   | `%xmm6`  | 7th FP参数        |
| `%ymm7`   | `%xmm7`  | 8th FP参数        |
| `%ymm8`   | `%xmm8`  | 调用者保存        |
| `%ymm9`   | `%xmm9`  | 调用者保存        |
| `%ymm10`  | `%xmm10` | 调用者保存        |
| `%ymm11`  | `%xmm11` | 调用者保存        |
| `%ymm12`  | `%xmm12` | 调用者保存        |
| `%ymm13`  | `%xmm13` | 调用者保存        |
| `%ymm14`  | `%xmm14` | 调用者保存        |
| `%ymm15`  | `%xmm15` | 调用者保存        |

### 3.11.1浮点传送和转换操作

下面给出一组在内存和XMM寄存器之间以及从一个XMM寄存器到另一个不做任何转换的传送浮点数（$M_{32}$和$M_{64}$）的指令，指令引用内存的指定方式与`MOV`相同。

其中代码优化规则建议32位内存数据满足4字节对齐，64位数据满足8字节对齐。（**$X$是`XMM`寄存器，$M_{32}$是32位内存范围，$M_{64}$是64位内存范围**）

| 指令      | 源       | 目的     | 描述                       |
| --------- | -------- | -------- | -------------------------- |
| `vmovss`  | $M_{32}$ | $X$      | 传送单精度数               |
| `vmovss`  | $X$      | $M_{32}$ | 传送单精度数               |
| `vmovsd`  | $M_{64}$ | $X$      | 传送双精度数               |
| `vmovsd`  | $X$      | $M_{64}$ | 传送双精度数               |
| `vmovaps` | $X$      | $X$      | 传送对齐的封装好的单精度数 |
| `vmovapd` | $X$      | $X$      | 传送对齐的封装好的双精度数 |

把浮点值转换成整数时，指令会执行**截断（truncation）**，把值向0进行舍入，这是C和大多数其他编程语言的要求。

**双操作数浮点转换指令。这些操作将浮点数转换成整数**：（**$R_{32}$是32位通用寄存器，$R_{64}$是64位通用寄存器**）

| 指令          | 源         | 目的     | 描述                                 |
| ------------- | ---------- | -------- | ------------------------------------ |
| `vcvttss2si`  | $X/M_{32}$ | $R_{32}$ | 用截断的方法把单精度数转换成整数     |
| `vcvttsd2si`  | $X/M_{64}$ | $R_{32}$ | 用截断的方法把双精度数转换成整数     |
| `vcvttss2siq` | $X/M_{32}$ | $R_{64}$ | 用截断的方法把单精度数转换成四字整数 |
| `vcvttsd2siq` | $X/M_{64}$ | $R_{64}$ | 用截断的方法把双精度数转换成四字整数 |

**三操作数浮点转换指令。这些操作将第一个源的数据类型转换成目的的数据类型。第二个源值
对结果的低位字节没有影响。**

我们暂且忽略第二个操作数，因为它的值只会影响结果的高位字节。

| 指令         | 源1             | 源2  | 目的 | 描述                     |
| ------------ | --------------- | ---- | ---- | ------------------------ |
| `vcvtsi2ss`  | $M_{32}/R_{32}$ | $X$  | $X$  | 把整数转换成单精度数     |
| `vcvtsi2sd`  | $M_{32}/R_{32}$ | $X$  | $X$  | 把整数转换成双精度数     |
| `vcvtsi2ssq` | $M_{64}/R_{64}$ | $X$  | $X$  | 把四字整数转换成单精度数 |
| `vcvtsi2sdq` | $M_{64}/R_{64}$ | $X$  | $X$  | 把四字整数转换成双精度数 |

| 指令        | 源   | 源   | 目的 | 描述                                               |
| ----------- | ---- | ---- | ---- | -------------------------------------------------- |
| `vunpcklps` | $X$  | $X$  | $X$  | 交叉放置来自两个源的值，把它们存储到第三个寄存器中 |

这个指令的例子：如果一个源寄存器的内容为字$[s_3,s_2,s_1,s_0]$，另一个源寄存器为字$[d_3,d_2,d_1,d_0]$，那么目的寄存器的值会是$[s_1,d_1,s_0,d_0]$。

### 3.11.2过程中的浮点代码

在x86-64中，`XMM`寄存器用来向函数传递浮点参数，以及从函数返回浮点值。

有如下规则：

- `XMM`寄存器`％xmm0~%xmm7`最多可以传递8 个浮点参数。按照参数列出的顺序使用这些寄存器。可以通过栈传递额外的浮点参数。
- 函数使用寄存器$％xmm0$来返回浮点值。
- 所有的`XMM`寄存器都是调用者保存的。被调用者可以不用保存就覆盖这些寄存器中任意一个。

当函数包含指针、整数和浮点数混合的参数时，指针和整数通过通用寄存器传递，而浮点值通过`XMM`寄存器传递。也就是说，**参数到寄存器的映射取决于它们的类型和排列的顺序**。

比如：

```c
double f(double y, int x, long z);
```

这个函数会把`x`存放在`％edi`中，`y`放在`％xmm0`中，而`z`放在`％rsi`中。

### 3.11.3浮点运算操作

以下指令每条指令有一个（$S_1$）或两个（$S_1,S_2$）源操作数，和一个目的操作数$D$。

第一个源操作数$S_1$可以是一个`XMM`寄存器或一个内存位置。第二个源操作数和目的操作数都必须是`XMM`寄存器。每个操作都有一条针对单精度的指令和一条针对双精度的指令。结果存放在目的寄存器中。

| 单精度   | 双精度   | 效果                        | 描述         |
| -------- | -------- | --------------------------- | ------------ |
| `vaddss` | `vaddsd` | $D\leftarrow S_2+S_1$       | 浮点数加     |
| `vsubss` | `vsubsd` | $D\leftarrow S_2-S_1$       | 浮点数减     |
| `vmulss` | `vmulsd` | $D\leftarrow S_2\times S_1$ | 浮点数乘     |
| `vdivss` | `vdivsd` | $D\leftarrow S_2/S_1$       | 浮点数除     |
| `vmaxss` | `vmaxsd` | $D\leftarrow max(S_2,S_1)$  | 浮点数最大值 |
| `vminss` | `vminsd` | $D\leftarrow min(S_2,S_1)$  | 浮点数最小值 |
| `sqrtss` | `sqrtsd` | $D\leftarrow \sqrt{S_1}$    | 浮点数平方根 |

### 3.11.4定义和使用浮点常数

和整数运算操作不同， `AVX`浮点操作不能以立即数值作为操作数。相反，编译器必须为所有的常量值分配和初始化存储空间。然后代码在把这些值从内存读入。

例如：

```c
double cel2fahr(double temp) {
	return 1.8*temp+32.0;
}
```

对应的汇编代码部分如下：

```bash
cel2fahr:
    vmulsd  .LC2(%rip), %xmm0, %xmm0
	vaddsd  .LC3(%rip), %xmm0, %xmm0
	ret
.LC2:
	.long 3435973837
	.long 1073532108
.LC3:
	.long 0
	.long 1077936128
```

### 3.11.5在浮点代码中使用位级操作

这些操作都作用于封装好的数据，即它们更新整个目的`XMM`寄存器，对两个源寄存器的所有位都实施指定的位级操作。从下面的例子中可以看出，运用这些操作通常可以简单方便地操作浮点数。

| 单精度   | 双精度  | 效果                        | 描述     |
| -------- | ------- | --------------------------- | -------- |
| `vxorps` | `vorpd` | $D\leftarrow S_2\oplus S_1$ | 位级异或 |
| `vandps` | `andpd` | $D\leftarrow S_2\& S_1$     | 位级与   |

### 3.11.6浮点比较操作

| 指令                    | 基于      | 描述         |
| ----------------------- | --------- | ------------ |
| `ucomiss`  $S_1$，$S_2$ | $S_2-S_1$ | 比较单精度值 |
| `ucomisd`  $S_1$，$S_2$ | $S_2-S_1$ | 比较双精度值 |

这些指令比较操作数$S_1$和$S_2$，并设置条件码指示它们的相对值。

浮点比较指令会设置三个条件码。

| 顺序$S_2:S_1$ | CF   | ZF   | PF   |
| ------------- | ---- | ---- | ---- |
| 无序的        | 1    | 1    | 1    |
| $S_2<S_1$     | 1    | 0    | 0    |
| $S_2=S_1$     | 0    | 1    | 0    |
| $S_2>S_1$     | 0    | 0    | 0    |

当任一操作数为$NaN$时，就会出现无序的情况。可以通过奇偶标志位发现这种情况。

# 5.优化程序性能

## 5.1优化编译器的能力和局限性

大多数编译器向用户提供了一些对它们所使用的优化的**控制**。最简单的控制就是**指定优化级别**。

**编译器必须使优化后的版本与优化前有相同的行为**。

```c
void test1(long *xp，long *yp){
	*xp+=*yp;
	*xp+=*yp;
}

void test2(long *xp，long *yp){
	*xp+=2* *yp;
}
```

显然当`*xp`和`*yp`指向同一个地址的时候，两个代码的效果并不等同，因此`test2`不能作`test1`的优化版本。

------

```c
x=114514，y=1919810;
*q=x;
*p=y;
t=*q;
```

这里当`*p`和`*q`指向同一个地址与否也会影响`t`的取值，这会妨碍编译器优化。

------

```c
long cnt=0;
long f(){
	return cnt++;
}

long f1(){
	return f()+f()+f()+f();
}

long f2(){
	return 4*f();
}
```

函数修改全局程序状态，会导致`f1`和`f2`行为不同。

大多数编译器不会试图判断一个函数是否没有副作用，如果没有，就可能被优化成像`f2`中的样子。相反，编译器会假设最糟的情况，并保持所有的函数调用不变。

## 5.2表示程序性能

**每元素的周期数(Cycles Per Element，CPE)**是一种表示程序性能并指导我们改进代码的方法。

处理器活动的顺序是由时钟控制的，时钟提供了某个频率的规律信号，通常用**千兆赫兹(GHz)**，即**十亿周期每秒**来表示。

**每个时钟周期的时间是时钟频率的倒数**。

从程序员的角度来看，用**时钟周期(一秒内执行了多少条指令)**来表示度量标准要比用纳秒或皮秒来表示有帮助得多。

------

```c
void psum1(float a[]，float p[]，long n){
	long i;
	p[0]=a[0];
	for(i=1;i<n;i++)p[i]=p[i-1]+a[i];
}

void psum2(float a[]，float p[]，long n){
	long i;
	p[0]=a[0];
	for(i=1;i<n-1;i+=2){
		float mid_val=p[i-1]+a[i];
		p[i]=mid_val;
		p[i+1]=mid_val+a[i+1];
	}
	if(i<n)p[i]=p[i-1]+a[i];
}
```

`psum2`使用了**循环展开**。这两个函数的运行时间分别近似于$368+9.0n$和$368+6.0n$，其中$368$是循环以外过程。所以`psum1`的CPE为$9.0$，所以`psum2`的CPE为$6.0$。

## 5.3程序示例

~~这一部分用实验证明了优化选项可以近乎提高几个数量级的性能，接下来的测试中我们将用-O1和-O2级别的优化来生成和测量程序。~~

## 5.4消除循环的低效率

如果我们这么写：

```c
int getlen(int s[]){
    int len=0;
    while(s[len]!=0)len++;
    return len;
}
for(int i=0;i<getlen(s);++i){
	/*...*/
}
```

这样子的写法由于不能确定`s[]`是否发生了更新，多次`getlen(s)`返回值可能不一样，每次循环都会执行一次。~~`strlen`也是~~

## 5.5减少过程调用

减少调用函数，虽然好像在数组求和的例子中这样性能反而下降，但我们还是相信这会带来性能提升。

## 5.6消除不必要的内存引用

```c
void combine(/*...*/，int *dest){
	/*...*/
	int tot=1;
	for(int i=0;i<length;++i){
		tot*=data[i];
	}
	*dest=tot;
}
```

```c
void combine(/*...*/，int *dest){
	/*...*/
    *dest=1;
	for(int i=0;i<length;++i){
		*dest*=data[i];
	}
}
```

第一种写法相比第二种有显著的提升。

请看原因：

```bash
.L25:
	vmulsd (%rdx)， %xmm0， %xmm0
	addq   $8， %rdx
	cmpq   %rax， %rdx
	jne    .L25
```

```bash
.L17:
	vmovsd (%rbx)， %xmm0
	vmulsd (%rdx)， %xmm0， %xmm0
	vmovsd %xmm0， (%rbx)
	addq   $8， %rdx
	cmpq   %rax， %rdx
	jne    .L17
```

第一种写法不需要从地址引用内存，快了许多。

编译器不会优化这个过程，因为如果`*dest`指向的地址在我们累乘的数组内存内，显然也会导致函数效果不同。

## 5.7理解现代处理器

随着试图进一步提高性能，必须考虑利用**处理器微体系结构**的优化，也就是处理器用来执行指令的底层系统设计。

要想充分提高性能，需要仔细分析程序，同时代码的生成也要针对目标处理器进行调整。

------

**指令级并行**：采用复杂而奇异的微处理器结构，其中，多条指令可以并行地执行，同时又呈现出一种简单的顺序执行指令的表象。

**延迟界限**：当一系列操作必须按照严格顺序执行时，就会遇到**延迟界限**。当代码中的数据相关限制了处理器利用指令级并行的能力时，延迟界限能够限制程序性能。

**吞吐量界限**：处理器功能单元的原始计算能力。这个界限是程序性能的终极限制。

### 5.7.1整体操作

下图是现代处理器的一个非常简化的示意图，这里假想的处理器设计是不太严格地基于Intel处理器的结构。
这些处理器被称为是**超标量的 (superscalar)**，每个时钟周期可执行多个操作，且是**乱序的(out-of-order)**，意思就是指令的执行顺序不一定要与它们在机器级程序中的顺序一致。

整体的设计分为两部分：

**指令控制单元(Instruction Control Unit， ICU)**，负责从内存读出指令序列， 并根据这些指令序列生成一组针对程序数据的基本操作。

**执行单元(Execution Unit， EU)**，执行ICU生成的操作。

![image-20250430185916606](D:/黄羽翔/大学/计算机系统基础/pictures/image-20250430185916606.png)

下面简单介绍处理器的各个部分：

- **指令高速缓存(instruction cache)**：特殊的高速存储器，存储最近的指令，ICU就是从这里读取指令。

  > 通常ICU会在当前正在执行的指令很早之前取指，以保证有足够的时间对指令译码，并把生成的操作发送给EU。不过一个问题是当程序遇到**分支(条件转移指令)**时，程序可能会进入分支也可能跳过分支。
  > 现代处理器采用一种称为**分支预测(branch prediction)**的计数，处理器会猜测是否选择分支，同时预测分支的目标地址。
  >
  > 采用**投机执行(speculative execution**的计数，处理器会开始取出它预测的分支目标地址处取指令，并对指令译码，甚至在确定分支预测是否正确之前就开始执行这些操作。如果过后确定分支预测错误，会将状态重新设置到分支点的状态，并开始取出并执行另一个方向的指令。

- **取指控制(fetch control)**：包括上述的分支预测。

- **指令译码(instruction decode)**：接受实际的程序指令，并将它们转换成一组基本操作(有时称为微操作)。
  这样的操作完成一个简单的任务，如加减、内存读写。

------

在典型的x86实现中，一条只对寄存器的操作，如：

```bash
addq %rax, %rbx
```

会被转化为一个操作。而一条包含一个或多个内存引用的指令，如:

```bash
addq %rax, 8(%rdx)
```

会产生多个操作，把内存引用和算数运算分开。这条指令会被分为3个操作：从内存读，将读入的值加上`rax`中的值，对内存写。

- **功能单元(functional units)**：EU中的用于执行不同的来自ICU操作的单元。
- **数据高速缓存(data cache)**：高速存储器，存放最近访问的数据值。
- **加载和存储单元(load&store)**：读写内存。均有一个加法器用于计算地址，通过数据高速缓存来访问内存。

> 使用投机执行技术对操作求值，直到处理器能确定应该实际执行这些指令前，其最终结果不会存储在程序寄存器或内存中。分支操作被送到EU，用于确定分支是否预测正确。如果预测错误，EU会丢弃分支点之后计算的结果，并发送信号给**分支单元(branch)**告诉预测是错误的，这样的预测错误会带来很大的性能开销。

由于不同程序间所要求的操作变化很大，因此，算法运算单元被特意设计称能够执行不同的操作。

举个例子, `Intel Core i7 Haswell`参考机有编号为0∼7的8个功能单元：

- 0：整数运算、浮点乘、整数和浮点数除法、分支。
- 1：整数运算、浮点加、整数乘、浮点乘。
- 2：加载、地址计算。
- 3：加载、地址计算。
- 4：存储。
- 5：整数运算。
- 6：整数运算、分支。
- 7：存储、地址计算。

> [!CAUTION]
>
> 这一部分全都是原理级内容，暂时略了。

## 5.8循环展开

循环展开是一种程序变换，通过增加每次迭代计算的元素的数量，减少循环的迭代次数。

循环展开能够从两个方面改进程序的性能：

1. 它减少了不直接有助于程序结果的操作的数量，例如循环索引计算和条件分支。
2. 它提供了一些方法，可以进一步变化代码，减少整个计算中关键路径上的操作数量。

这个做法的原理：

1. **减少循环控制开销**
   每次循环迭代涉及条件检查、计数器更新等操作，展开后循环次数减少，降低了这些固定开销在总执行时间中的比例。
2. **提高指令级并行性(ILP)**
   展开后的循环体内包含更多独立指令，处理器可同时执行多个操作。现代CPU的乱序执行引擎能更好地填充流水线。
3. **优化缓存利用率**
   连续访问内存时，展开循环能更充分地利用缓存行。例如一次加载64字节缓存行后，处理其中的16个整型(4字节)元素，减少缓存未命中次数。

## 5.9提高并行性

### 5.9.1多个累积变量

现代CPU（如Intel Skylake、AMD Zen）支持同时执行多个独立的运算指令。例如：

- **4个独立的加法**可被分配到4个不同的ALU（算术逻辑单元）并发执行。

另一方面：仅在最终合并时访问内存，中间结果保留在寄存器中。

### 5.9.2重新结合变换 

例如

```c
result=result*(a[i]*b[i]);
result=(result*a[i])*b[i];
```

上述两种写法，第一种由于改变`result`的值的过程和循环的过程可以并行执行，会快一些。

## 5.10优化合并代码的结果小结

使用多项优化技术，我们获得的CPE已经接近于0.50和1.00的吞吐量界限，只受限于功能单元的容最。与原始代码相比提升了10~20倍，且使用普通的C代码和标准编译器就获得了所有这些改进。重写代码利用较新的SIMD指令得到了将近4倍或8倍的性能提升。比如单精度乘法，CPE从初值11.14降到了0.06，整体性能提升超过180倍。
这个例子说明现代处理器具有相当的计算能力，但是我们可能需要按非常程式化的方式来编写程序以便将这些能力诱发出来。

> [!CAUTION]
>
> 后面几章理论性极强，实用性不大，暂时略过。

# 7.链接

**链接(linking)**是将各种代码和数据片段收集并组合成为一个单一文件的过程，这个文件可被加载（复制）到内存并执行。

链接可以执行于：

- **编译时(compile time)** ，也就是在源代码被翻译成机器代码时。
- **加载时(load time)** ，也就是在程序被**加载器(loader)**加载到内存并执行时
- **运行时(run time)** ，也就是由应用程序来执行。

在早期的计算机系统中，链接是**手动执行**的。在现代系统中，链接是由叫做**链接器(linker)**的程序自动执行的。

~~学习本章节可以避免链接库失败带来的高血压~~，更好地利用共享库，避免危险的编程错误。

**我们将在一个运行Linux的x86-64系统，使用标准的ELF-64目标文件格式的环境下研究**。

## 7.1编译器驱动程序

现在我们有程序`main.c`：

```c
int sum(int *a,int n);
int array[2]={1,2};
int main(){
	int val=sum(array,2);
	return val;
}
```

将`main.c`翻译成可执行目标文件`main.o`的过程：

1. 驱动程序首先运行C预处理器(`cpp`)，它将`main.c`翻译成一个ASCII码的中间文件`main.i`：
   `cpp [other arguments] main.c /tmp/main.i`
2. 驱动程序运行C编译器(`ccl`)，它将`main.i`翻译成一个ASCII汇编语言文件`main.s`：
   `ccl /tmp/main.i -Og [other arguments] -o /tmp/main.s`
3. 驱动程序运行汇编器(`as`)，它将`main.s`翻译成一个可重定位目标文件(relocatable object file)`main. o`：
   `as [other arguments] -o /tmp/main.o /tmp/main.s`

假设我们还有程序`sum.c`：

```c
int sum(int *a,int n){
	int i,s=0;
	for(i=0;i<n;i++){
		s+=a[i];
	}
	return s;
}
```

驱动程序经过相同的过程生成`sum.o`。

我们链接的指令`gcc -Og -o prog main.c sum.c`，就要先生成`main.o`和`sum.o`文件。

最后，它运行链接器程序`ld`，将`main.o`和`sum.o`以及一些必要的系统目标文件组合起来，创建一个**可执行目标文件(executable object file)**prog：
`ld -o prog [system object files and args] /tmp/main.o /tmp/sum.o`
`shell`调用操作系统中一个叫做**加载器（loader）**的函数，它将可执行文件`prog`中的代
码和数据复制到内存，然后将控制转移到这个程序的开头。

## 7.2静态链接

**静态链接器(static linker)**以一组**可重定位目标文件**（如`.o`，`.obj`文件）和命令行参数作为输入，生成一个完全链接的、可以加载和运行的**可执行目标文件**作为输出。

在**可重定位目标文件**中包含各种不同的代码和数据节。每一节都是一个连续的字节序列，这个我们在7.4介绍。

为了构造可执行文件，链接器必须完成两个主要任务：

- **符号解析(symbol resolution)**。目标文件定义和引用符号，使每个符号引用正好和一个符号定义关联起来。
- **重定位(relocation)**。编译器和汇编器生成从地址0开始的代码和数据节。链接器通过把每个符号定义与一个内存位置关联起来，从而重定位这些节，然后修改所有对这些符号的引用，使得它们指向这个内存位置。链接器使用汇编器产生的**重定位条目(relocation entry)**的详细指令，不加甄别地执行这样的重定位。

## 7.3目标文件

目标文件包括：

- **可重定位目标文件**：包含二进制代码和数据，其形式可以在编译时与其他可重定位目标文件合并起来，创建一个可执行目标文件。
- **可执行目标文件**：包含二进制代码和数据，其形式可以被直接复制到内存并执行。
- **共享目标文件**：一种特殊类型的可重定位目标文件，可以在加载或者运行时被动态地加载进内存并链接。

编译器和汇编器生成**可重定位目标文件**（包括共享目标文件）。链接器生成**可执行目标文件**。

从技术上来说， 一个**目标模块(object module)**就是一个字节序列，而一个**目标文件(object file)**就是一个以文件形式存放在磁盘中的目标模块。

各个操作系统的目标文件格式都不相同。

| 操作系统                   | 目标文件格式                                          |
| -------------------------- | ----------------------------------------------------- |
| Unix                       | `a.out`                                               |
| Windows                    | 可移植可执行（Portable Executable,PE）格式`a.exe`     |
| MacOS-X                    | Mach-O格式                                            |
| x86-64 Linux和现代Unix系统 | 可执行可链接格式(Executable and Linkable Format, ELF) |

我们主要讨论ELF。

## 7.4可重定位目标文件

**ELF头（ELF header）**以一个16字节的序列开始，这个序列描述了生成该文件的系统的字的大小和字节顺序。

ELF头剩下的部分包含帮助链接器语法分析和解释目标文件的信息。其中包括：

- **ELF头的大小**。
- **目标文件的类型（如可重定位、可执行或者共享的）**
- **机器类型（如x86-64）**。
- **节头部表（section header table）的文件偏移**。
- **节头部表中条目的大小和数量**。

不同节的位置和大小是由节头部表描述的，其中目标文件中每个节都有一个固定大小的**条目(entry)**。

|    ELF头     |
| :----------: |
|  .**text**   |
| **.rodata**  |
|  **.data**   |
|   **.bss**   |
| **.symtab**  |
| **rel.text** |
| **rel.data** |
|  **.debug**  |
|  **.line**   |
| **.strtab**  |
| **节头部表** |

`.text`：已编译程序的机器代码。

`.rodata`：只读数据，比如`printf`语句中的格式串和开关语句的跳转表。

`.data`：**已初始化的全局和静态C变量**。局部C变量在运行时被保存在栈中，既不出现在`.data`节中，也不出现在`.bss`节中。
`.bss`：**未初始化的全局和静态C变量，以及所有被初始化为0的全局或静态变量**。在目标文件中这个节不占据实际的空间，它仅仅是一个占位符。目标文件格式区分已初始化和未初始化变量是为了空间效率：在目标文件中，未初始化变量不需要占据任何实际的磁盘空间。运行时，在内存中分配这些变量，初始值为0。
`.symtab`：**一个符号表，它存放在程序中定义和引用的函数和全局变量的信息**。一些程序员错误地认为必须通过`-g`选项来编译一个程序，才能得到符号表信息。实际上，每个可重定位目标文件在`.symtab`中都有一张符号表（除非程序员特意用STRIP命令去掉它）。然而，和编译器中的符号表不同，`.symtab`符号表不包含局部变量的条目。
`.rel.text`：**一个`.text`节中位置的列表，当链接器把这个目标文件和其他文件组合时，需要修改这些位置**。一般而言，任何调用外部函数或者引用全局变量的指令都需要修改。另一方面，调用本地函数的指令则不需要修改。注意，可执行目标文件中并不需要重定位信息，因此通常省略，除非用户显式地指示链接器包含这些信息。
`.rel.data`：**被模块引用或定义的所有全局变量的重定位信息**。一般而言，任何已初始化的全局变量，如果它的初始值是一个全局变量地址或者外部定义函数的地址，都需要被修改。
`.debug`：**一个调试符号表，其条目是程序中定义的局部变量和类型定义，程序中定义和引用的全局变量，以及原始的C源文件**。只有以`-g`选项调用编译器驱动程序时，才会得到这张表。
`.line`：**原始C源程序中的行号和`.text`节中机器指令之间的映射**。只有以`-g`选项调用编译器驱动程序时，才会得到这张表。
`.strtab`：**一个字符串表，其内容包括`.symtab`和`.debug`节中的符号表，以及节头部中的节名字**。字符串表就是以`null`结尾的字符串的序列。

## 7.5符号和符号表

每个可重定位目标模块$m$都有一个符号表，它包含$m$定义和引用的符号的信息。在链接器的上下文中，有三种不同的符号：

- 由模块$m$定义并能被其他模块引用的全局符号。全局链接器符号对应于非静态的C函数和全局变量。
- 由其他模块定义并被模块$m$引用的全局符号。这些符号称为外部符号，对应于在其他模块中定义的非静态C函数和全局变量。
- 只被模块$m$定义和引用的局部符号。它们对应于带static属性的C函数和全局变量。这些符号在模块$m$中任何位置都可见，但是不能被其他模块引用。

定义为带有C static属性的本地过程变量不在**栈**中管理的，而是在`.data`或`.bss`中为每个定义分配空间，并在符号表中创建一个有唯一名字的本地链接器符号。比如，假设在同一模块中的两个函数各自定义了一个静态局部变量x，编译器向汇编器输出**两个不同名字的局部链接器符号**（比如`x.1`，`x.2`）

`.symtab`节中包含ELF符号表。

**一个ELF符号表的条目**

用一个结构体类比条目，变量类型名对应各个条目的格式。

```c
typedef struct {
	int name;
	char type:4,
		 binding:4;
	char reseerved;
	short section;
	long value;
	long size;
} Elf64_Symbol;
```

- **name**：字符串表中的字节偏移，指向符号的以`null`结尾的字符串名字。
- **value**：对于可重定位的模块来说，value是**距定义目标的节的起始位置的偏移**。对于可执行目标文件来说，该值是一个**绝对运行时地址**。
- **size**：目标的大小（以字节为单位）。
- **type**：数据或者函数。
- **binding**：表示符号是本地的还是全局的。
- **section**：到节头部表的索引。**另外**有三个特殊的**伪节(pseudosection)**（只在可重定位目标文件中才有），它们在节头部表中是没有条目的：
  - **ABS**代表不该被重定位的符号。
  - **UNDEF**代表未定义的符号，也就是在本目标模块中引用，但是却在其他地方定义的符号。
  - **COMMON** 表示还未被分配位置的未初始化的数据目标（链接器决定分配位置）。
    - **value**字段给出对齐要求。
    - **size**给出最小的大小。

**COMMON** 和**`.bss`**的区别很细微。现代的GCC 版本根据以下规则来将**可重定位目标文件（可执行目标文件中没有）**中的符号分配到**COMMON** 和.**`bss`**中：

- **COMMON**：未初始化的全局变量。
- **`.bss`**：未初始化的静态变量，以及初始化为0的全局或静态变量。

我们可以用**GNU READELF**查看目标文件内容，例如：

| Num  | Value            | Size | Type   | Bind   | Vis     | Ndx  | Name  |
| ---- | ---------------- | ---- | ------ | ------ | ------- | ---- | ----- |
| 8    | 0000000000000000 | 24   | FUNC   | GLOBAL | DEFAULT | 1    | main  |
| 9    | 0000000000000000 | 8    | OBJECT | GLOBAL | DEFAULT | 3    | array |
| 10   | 0000000000000000 | 0    | NOTYPE | GLOBAL | DEFAULT | UND  | sum   |

其中`Ndx=1`表示`.text`节，而`Ndx=3`表示`.data`节。

## 7.6符号解析

**链接器**解析符号引用的方法是将每个引用与它输入的可重定位目标文件的符号表中的**一个确定的符号定义关联起来**。

对那些和引用定义在相同模块中的局部符号的引用， 符号解析是非常简单明了的，例如：

```c
// file1.c
static int localVar = 10;  // 静态局部变量
static void localFunc() {  // 静态局部函数
    localVar++;
}
int main() {
    localFunc();
    return 0;
}
```

链接器在解析时，直接在`file1.o`中找到定义，无需与其他模块交互。

编译器只允许每个模块中每个局部符号有一个定义。静态局部变量也会有本地链接器符号，编译器还要确保它们拥有唯一的名字。

------

对于全局符号的引用解析：**当编译器遇到一个不是在当前模块中定义的符号（变量或函数名）时，会假设该符号是在其他某个模块中定义的，生成一个链接器符号表条目，并把它交给链接器处理。如果链接器在它的任何输入模块中都找不到这个被引用符号的定义，就输出一条（通常很难阅读的）错误信息并终止**。

我们来研究这个过程。

### 7.6.1链接器如何解析多重定义的全局符号

在编译时，编译器向汇编器输出每个全局符号，或者是**强(strong)**或者是弱**(weak)**，而汇编器把这个信息隐含地编码在可重定位目标文件的符号表里。**函数和已初始化的全局变量是强符号**，**未初始化的全局变量是弱符号**。

处理多重定义的规则：

1. **不允许有多个同名的强符号**。
2. **如果有一个强符号和多个弱符号同名，那么选择强符号**。
3. **如果有多个弱符号同名，那么从这些弱符号中任意选择一个**。

**例1**：

```c
/* foo1.c */
int main(){
	return 0;
}
```

```c
/* bar1.c */
int main(){
	return 0;
}
```

链接时会生成错误信息：

```bash
linux> gcc foo1.c bar1.c
/tmp/ccq2Uxnd.o: In function'main':
barl.c:(.text+OxO):multiple definition of 'main'
```

表示强符号`main`被定义了多次，违背了规则1。

**例2**：

```c
/* foo2.c */
#include <stdio.h>
void f(void);
int x=114514;
int main(){
    printf("%d\n",x);
	f();
	printf("%d",x);
	return 0;
}
```

```c
/* bar2.c */
int x;
void f(){
	x=1919810;
}
```

链接时，`foo2.c`中`x`是强符号，`bar2.c`中x是弱符号。

链接结果会是：

```bash
linux> gcc -o foobar3 foo3.c bar3.c
linux> ./foobar3
114514
1919810
```

**例3**：

```c
/* foo4.c */
#include <stdio.h>
void f(void);
int x;
int main(){
	x=114514;
	f();
	printf("%d",x);
	return 0;
}
```

```c
/* bar4.c*/
int x;
void f(){
	x=1919810;
}
```

链接时，两个都是弱符号，取其一。

**例4**：

```c
/* foo5.c */
#include <stdio.h>
void f(void);
int y=1919810;
int x=114514;
int main(){
	f();
	printf("%d %d",x,y);
	return 0;
}
```

```c
/* bar5.c */
double x;
void f(){
	x=-0.0;
}
```

这个例子~~很有意思~~。

在一台x86-64 / Linux机器上，`double`类型是8个字节，而`int`类型是4个字节。在我们的系统中，`x`的地址是`0x601020`，`y`的地址是`0x601024`。因此，`bar5.c`的第6行中的赋值`x= -0.0`将用负零的双精度浮点表示覆盖内存中`x`和`y`的位置。

```bash
linux> gcc -Wall -Og -o foobar5 foo5.c bar5.c
/usr/bin/ld: Warning: alignment 4 of symbol 'x' in /tmp/cclUFK5g.o
is smaller than 8 in /tmp/ccbTLcb9.o
linux> ./foobar5
0x0 0x80000000
```

------

由上面的分析可以知道：

当编译器在翻译某个模块时，遇到一个**弱全局符号**，它并不知道其他模块是否也定义了，如果是，它无法预测链接器该使用多重定义中的哪一个。所以编译器将其分配成COMMON，把决定权留给链接器。

另一方面，如果初始化为0，那么它是一个**强符号**，所以编译器可以很自信地将它分配成`.bss` 。类似地，静态符号的构造就必须是唯一的，所以编译器可以自信地把它们分配成`.data`或`.bss`。

### 7.6.2与静态库链接

实际上，所有的编译系统都提供一种机制，将所有相关的目标模块打包成为一个单独的文件，称为静态库(**static library**)，它可以用做链接器的输入。
当链接器构造一个输出的可执行文件时，它只复制静态库里被应用程序引用的目标模块。

------

在此之前，`Pascal`（~~一个你都没听过的语言~~）等语言用的是提供一小部分标准函数，由编译器辨认你的调用，直接生成相应代码。

此外，我们可以将所有的标准C函数都放在一个单独的可重定位目标模块。应用程序员可以把这个模块链接到他们的可执行文件中。

```bash
linux > gcc main.c /usr/lib/libc.o
```

但是修改将会是极大的困难，而且很占磁盘，链接也很耗时。

```bash
linux > gcc main.c /usr/lib/libm.a /usr/lib/libc.a
```

------

静态库概念被提出来，以解决这些不同方法的缺点。
相关的函数可以被编译为**独立的目标模块**，然后封装成一个单独的**静态库文件**。然后，应用程序可以通过在命令行上指定单独的文件名字来使用这些在库中定义的函数。

比如，使用C标准库和数学库中函数的程序可以用形式如下的命令行来编译和链接：

```bash
linux > gcc main.c /usr/lib/libm.a /usr/lib/libc.a
```

- 链接器将只复制被程序引用的目标模块，减少了可执行文件在磁盘和内存中的大小。
- 应用程序员只需要包含较少的库文件的名字。

------

在Linux系统中，静态库以一种称为存档(**archive**) 的特殊文件格式存放在磁盘中。

存档文件是一组连接起来的可重定位目标文件的集合，有一个头部用来描述每个成员目标文件的大小和位置。存档文件名由后缀`.a`标识。

以下面两个向量例程说明：

```c
/* accvec.c */
int addcnt=0;
void addvec(int *x,int *y,int *z,int n){
	int i;
	addcnt++;
	for(i=0;i<n;++i){
		z[i]=x[i]+y[i];
	}
}
```

```c
/* multvec.c */
int multcnt=0;
void multvec(int *x,int *y,int *z,int n){
	int i;
	multcnt++;
	for(i=0;i<n;++i){
		z[i]=x[i]*y[i];
	}
}
```

使用**AR工具**创建这些函数的一个静态库。

```bash
linux> gcc -c addvec.c multvec.c
linux> ar rcs libvector.a addvec.o multvec.o
```

我们使用静态链接库：

```c
#include <stdio.h>
int x[2]={1,2};
int y[2]={3,4};
int z[2];
int main(){
	addvec(x,y,z,2);
	printf("%d %d",z[0],z[1]);
	return 0;
}
```

```bash
linux> gcc -c main.c
linux> gcc -static -o prog main.o ./libvector.a
或
linux> gcc -static -o prog main.o -L. -lvector
```

- `-static`参数告诉编译器驱动程序，链接器应该构建一个完全链接的可执行目标文件，它可以加载到内存并运行，在加载时无须更进一步的链接。
- `-lvector`参数是`libvector.a`的缩写，`-L`参数告诉链接器在当前目录下查找`libvector.a`。

当链接器运行时，它判定`main.o`引用了`addvec.o`定义的`addvec`符号，所以复制`addvec.o`到可执行文件。

因为程序不引用任何由`multvec.o`定义的符号，所以链接器就不会复制这个模块到可执行文件。

链接器还会复制许多C运行时系统中的其他模块。

在此还复制了`libc.a`中的`printf.o`模块。

### 7.6.3链接器如何使用静态库来解析引用

在符号解析阶段，链接器从左到右按照它们在编译器驱动程序命令行上出现的顺序来扫描**可重定位目标文件（.o文件）**和**存档文件（.a文件）**。（驱动程序自动将命令行中所有的`.c`文件翻译为`.o`文件。）

在这次扫描中，链接器维护一个**可重定位目标文件的集合**$E$（这个集合中的文件会被合并起来形成可执行文件），一个**未解析的符号**（即引用了但是尚未定义的符号）集合$U$，以及一个**在前面输入文件中已定义的符号集合**$D$ 。初始时，$E$、$U$和$D$均为空。

- 对于输入文件$f$​，如果是一个**目标文件**：链接器把$f$添加到$E$，修改$U$和$D$来反映$f$中的符号定义和引用，并继续下一个输入文件。
- 对于输入文件$f$​，如果是一个**存档文件**：链接器尝试匹配$U$中未解析的符号和由存档文件成员定义的符号。如果某个存档文件成员$m$，定义了一个符号来解析$U$中的一个引用，那么就将$m$加到$E$中，并且链接器修改$U$和$D$来反映$m$中的符号定义和引用。对存档文件中所有的成员目标文件都依次进行这个过程，直到$U$和$D$都不再发生变化。此时，**任何不包含在$E$中的成员目标文件都简单地被丢弃，而链接器将继续处理下一个输入文件**。
- 如果当链接器完成对命令行上输入文件的扫描后，$U$是非空的，那么链接器就会输出一个错误并终止。否则，它会合并和重定位$E$中的目标文件，构建输出的可执行文件。

因此输入顺序很重要，例如：

```bash
linux> gcc -static ./libvector.a main.c
/tmp/cc9XH6Rp.o: In function 'main':
/tmp/cc9XH6Rp.o(.text+0x18): undefined reference to 'addvec'
```

在处理`libvector.a`时，$U$是空的，所以没有`libvector.a`中的成员目标文件会添加到$E$中。因此，对`addvec`的引用是绝不会被解析的，所以链接器会产生一条错误信息并终止。

------

关于库的一般准则是**将它们放在命令行的结尾**。如果各个库的成员是相互独立的（也就是说没有成员引用另一个成员定义的符号），那么这些库就可以以任何顺序放置在命令行的结尾处。另一方面，如果库不是相互独立的，那么必须对它们**排序**，使得对于每个被存档文件的成员外部引用的符号$s$在命令行中至少有一个$s$的定义是在对$s$的引用之后的。（类似于搭积木）

如果需要满足依赖需求，可以在命令行上重复库。

另一种方法是，我们可以**将`libx.a`和`liby.a`合并成一个单独的存档文件**。

## 7.7重定位

一旦链接器完成了符号解析这一步，就把代码中的每个**符号引用**和正好一个**符号定义**（即它的一个输入目标模块中的一个符号表条目）关联起来。

此时，链接器就知道它的输入目标模块中的代码节和数据节的确切大小。现在就可以开始**重定位**步骤了，在这个步骤中，将合并输入模块，并为每个符号分配运行时地址。

1. **重定位节和符号定义**。在这一步中，链接器将**所有相同类型的节**合并为**同一类型的新的聚合节**。例如，来自所有输入模块的`.data`节被全部合并成一个节，这个节成为输出的可执行目标文件的`.data`节。然后，链接器将**运行时内存地址**赋给**新的聚合节**，赋给**输入模块定义的每个节**，以及赋给**输入模块定义的每个符号**。当这一步完成时，程序中的每条指令和全局变量都有唯一的运行时内存地址了。

   | 符号         | 原始 | 分配后地址 |
   | ------------ | ---- | ---------- |
   | `main`       | 未知 | 0x400560   |
   | `global_vat` | 未知 | 0x601040   |

   

2. **重定位节中的符号引用**。在这一步中，链接器修改**代码节和数据节中对每个符号的引用**，使得它们指向正确的运行时地址。要执行这一步，链接器依赖于可重定位目标模块中称为**重定位条目(relocation entry)**的数据结构，我们接下来将会描述这种数据结构。

   把`.text`和`.data`里所有“用到符号”的地方（比如函数调用、变量访问）进行替换。

   替换用的数据就来自`.rel.text`、`.rel.data`这样的重定位表。

   比如：

   原来代码中有个调用`call printf`，位置在`.text`的某个偏移处。

   链接器查到`printf`的实际地址是`0x7ffff7e4b170`。

   链接器就把`call ??`的问号，补上为相对地址偏移

### 7.7.1重定位条目

当汇编器生成一个**目标模块**时，它并不知道数据和代码最终将放在内存中的什么位置。它也不知道这个模块引用的任何外部定义的函数或者全局变量的位置。所以，无论何时汇编器遇到对最终位置未知的目标引用，它就会生成一个**重定位条目**，告诉链接器在将目标文件合并成可执行文件时如何修改这个引用。

代码的重定位条目放在`.rel.text`中。
已初始化数据的重定位条目放在`.rel.data`中。

下面是一个ELF重定位条目格式示意图：

```c
typedef struct{
	long offset;
	long type:32,
		 symbol:32;
	long addend;
}Elf64_Rela;
```

- `offset`是需要被修改的引用的节偏移。
- `symbol`标识被修改引用应该指向的符号。
- `type`告知链接器如何修改新的引用。
- `addend`是一个有符号常数，一些类型的重定位要使用它对被修改引用的值做偏移调整。

------

ELF定义了32种不同的重定位类型，我们只介绍两种：

- **`R_X86_64_PC32`** 。**重定位一个使用32位PC相对地址的引用**。（~~一个PC相对地址就是距程序计数器(PC)的当前运行时值的偏移量~~）。当CPU执行一条使用PC相对寻址的指令时，它就将在指令中编码的32位值加上PC的当前运行时值，得到有效地址（如call指令的目标），~~PC值通常是下一条指令在内存中的地址~~。
- **`R_X86_64_32`**。**重定位一个使用32位绝对地址的引用**。通过绝对寻址，CPU直接使用在指令中编码的32位值作为有效地址，不需要进一步修改。

------

这两种重定位类型支持**x86-64小型代码模型(small code model)**。

该模型假设可执行目标文件中的代码和数据的总体大小小于2GB，因此在运行时可以用32位PC相对地址来访问。
GCC默认使用**小型代码模型**。

大于2GB的程序可以用**-mcmodel=medium（中型代码模型）**和**-mcmodel=large（大型代码模型）**标志来编译。

### 7.7.2重定位符号引用

用下面的伪代码解释：

```c
foreach section s {
	foreach relocation entry r {
		refptr = s + r.offset; // 计算的是需要被重定位的4字节引用的数组s中的地址

	if (r.type == R_X86_64_PC32) {
		refaddr = ADDR(s) + r.offset;
		*refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr);
    }
	if (r.type == R_X86_64_32) {
		*refptr = (unsigned) (ADDR(r.symbol) + r.addend);
	}
}
```

例如：

```bash
0000000000000000 <main>:
   0: 48 83 ec 08                sub   $0x8,%rsp
   4: be 02 00 00 00             mov   $0x2,%esi
   9: bf 00 00 00 00             mov   $0x0,%edi      #edi = $array
                      a: R_X86_64_32 array
   e: e8 00 00 00 00             callq 13 <main+Ox13> #sum()
                      f: R_X86_64_PC32 sum-0x4
  13: 48 83 c4 08                add   $0x8,%rsp
  17: c3                         retq
```

main函数引用了两个全局符号：`array`和`sum`。为每个引用，汇编器产生一个**重定位条目**，显示在引用的后面一行上。这些重定位条目告诉链接器对sum的引用要使用**32位PC相对地址**进行重定位，而对array的引用要使用**32位绝对地址**进行重定位。

1. **重定位PC相对引用**
   相应的重定位条目`r`：

   ```bash
   r.offset = 0xf
   r.symbol = sum
   r.type   = R_X86_64_PC32
   r.addend = -4
   ```

   假设链接器已经确定：

   ```bash
   ADDR(s) = ADDR(.text) = 0x4004d0
   ADDR(r.symbol) = ADDR(sum) = 0x4004e8
   ```

   首先计算出引用的运行时地址：

   ```bash
   refaddr = ADDR(s) + r.offset
           = 0x4004d0 + 0xf
           = 0x4004df
   ```

   然后，更新该引用，使得它在运行时指向sum程序：

   ```bash
   *refptr = (unsigned) (ADDR(r.symbol) + r.addend - refaddr)
           = (unsigned) (0x4004e8)      + (-4)     - 0x4004df)
           = (unsigned) (0x5)
   ```

   在得到的可执行目标文件中，`call`指令有如下的重定位的形式：

   ```bash
   4004de:  e8 05 00 00 00         callq  4004e8 <sum>
   ```

   在运行时，`call`指令将存放在地址`0x4004de`处。当CPU执行`call`指令时，PC的值为0x4004e3（`call`指令是5字节），即紧随在call指令之后的指令的地址。为了执行这条指令，CPU 执行以下的步骤：

   1) 将PC压入栈中。
   2) `PC=PC+0x5=0x4004e3+0x5=0x4004e8`

   因此，要执行的下一条指令就是`sum`例程的第一条指令。

2. **重定位绝对引用**

   相应的重定位条目`r`：

   ```bash
   r.offset = 0xa
   r.symbol = array
   r.type   = R_X86_64_32
   r.addend = 0
   ```

   假设链接器已经确定：

   ```bash
   ADDR(r.symbol) = ADDR(array) = 0x601018
   ```

   修改引用：

   ```bash
   *refptr = (unsigned) (ADDR(r.symbol) + r.addend)
           = (unsigned) (0x601018)      + 0)
           = (unsigned) (0x601018)
   ```

   在得到的可执行目标文件中，`call`指令有如下的重定位的形式：

   ```bash
   4004d9:  bf 18 10 60 00         mov    $0x601018,%edi
   ```

得到最终可执行目标文件中已重定位的`.text`节和`.data`节后。在加载的时候，加载器会把这些节中的字节直接复制到内存，不再进行任何修改地执行这些指令。

## 7.8可执行目标文件

类似地，我们给出一个ELF可执行目标文件的各类信息。

|                      ELF头                       |
| :----------------------------------------------: |
| **段头部表**（将连续的文件节映射到运行时内存段） |
|                    **.init**                     |
|                    .**text**                     |
|                   **.rodata**                    |
|                    **.data**                     |
|                     **.bss**                     |
|                   **.symtab**                    |
|                    **.debug**                    |
|                    **.line**                     |
|                   **.strtab**                    |
|         **节头部表**（描述目标文件的节）         |

-  从**ELF头**到**.rodata**是只读内存段（代码段）。
-  从**.data**到**.bss**是读/写内存段（数据段）。
-  从**.symtab**到**.节头部表**是不加载到内存的符号表和调试信息。

与可重定位目标文件不同的是：

1. **ELF头**包括程序的**入口点(entry point)**，也就是当程序运行时要执行的第一条指令的地址。
2. **.text**、**.rodata**和**.data**节已经被重定位到它们最终的运行时内存地址。
3. **.init**节定义了一个小函数，叫做`_init`，程序的初始化代码会调用它。
4. 可执行文件是完全链接的（已被重定位），不再需要**rel**节。

**ELF可执行文件**被设计得很容易加载到内存，可执行文件的连续的片(chunk)被映射到连续的内存段。

~~你可以用`objdump -d `指令观察程序头部表来观察这个效果。~~

**程序头部表**：

```bash
LOAD off    Ox0000000000000000 vaddr Ox0000000000400000 paddr Ox0000000000400000 align 2**21
     filesz Ox000000000000069c memsz Ox000000000000069c flags r-x
```

上面是一个代码段的示例。

对于任何段s，链接器必须选择一个起始地址$vaddr$，使得$vaddr \mod align = off \mod align$

这个对齐要求是一种优化，使得当程序执行时，目标文件中的段能够很有效率地传送到内存中。

## 7.9加载可执行目标文件

使用`linux> ./prog`运行可执行目标文件prog。

`shell`会通过调用某个驻留在存储器中称为**加载器(loader)**的操作系统代码来运行它。

加载器将可执行目标文件中的代码和数据从磁盘复制到内存中，然后通过跳转到程序的第一条指令或入口点来运行该程序。

这个将程序复制到内存并运行的过程叫做加载。

当加载器运行时，它创建类似于下图所示的**内存映像**。在**程序头部表**的引导下，加载器将可执行文件的**片(chunk)**复制到代码段和数据段。

接下来，加载器跳转到程序的入口点， 也就是`_start`函数的地址。这个函数是在系统目标文件`ctrl.o`中定义的，对所有的C程序都是一样的。

`_start`函数调用系统启动函数`__libc_start_main`，该函数定义在`libc.so`中。它初始化执行环境，调用用户层的`main`函数，处理`main`函数的返回值，并且在需要的时候把控制返回给内核。

![image-20250426105703485](D:/黄羽翔/大学/计算机系统基础/pictures/image-20250426105703485.png)

## 7.10动态链接共享库

**共享库(shared library)**是一个目标模块，在运行或加载时，可以加载到任意的内存地址，并和一个在内存中的程序链接起来。这个过程称为**动态链接(dynamic linking)**，是由一个叫做动态链接器**(dynamic linker)**的程序来执行的。共享库也称为**共享目标(shared object)**，在Linux系统中通常用**.so**后缀来表示。微软的操作系统大量地使用了共享库，它们称为DLL（动态链接库）。

- 共享库其实是所有引用该库的可执行目标文件共享这个`.so`文件中的代码和数据。

操作示例

```bash
linux> gcc -shared -fpic -o libvector.so addvec.c multvec.c
```

注：`-fpic`选项指示编译器生成与位置无关的代码，`-shared`选项指示链接器创建一个共享的目标文件。

```bash
linux> gcc -o prog21 main2.c ./libvector.so
```

这样就创建了一个可执行目标文件`prog21`，而此文件的形式使得它在运行时可以和`libvector.so`链接。

同时链接器复制了一些重定位和符号表信息，它们使得运行时可以解析对`libvector.so`中代码和数据的引用：

- prog21包含一个`.interp`节，这一节包含动态链接器的路径名。
- 加载器加载和运行**动态链接器**（其实它本身就是个共享目标）。
- 动态链接器执行下面的任务：
  - 重定位`libc.so`的文本和数据到某个内存段。
  - 重定位`libvector.so`的文本和数据到另一个内存段。
  - 重定位`prog21`中所有对由`libc.so`和`libvector.so`定义的符号的引用。

最后，共享库的位置（地址等）就固定了。

## 7.11从应用程序中加载和链接共享库

应用程序还可能在它运行时要求动态链接器加载和链接某个共享库，而无需在编译时将那些库链接到应用中，例如：

- **分发软件**。微软Windows应用的开发者常常利用共享库来分发软件更新。他们生成一个共享库的新版本，然后用户可以下载，并用它替代当前的版本。下一次他们运行应用程序时，应用将自动链接和加载新的共享库。

- **构建高性能Web服务器**。许多Web 服务器生成动态内容，比如个性化的Web页面、账户余额和广告标语。

  - 早期的Web服务器通过使用fork和execve创建一个子进程，并在该子进程的上下文中运行CGI程序来生成动态内容。

  - 现代高性能的Web服务器可以使用基于动态链接的更有效和完善的方法来生成动态内容。

    其思路是**将每个生成动态内容的函数打包在共享库**中。当一个来自Web浏览器的请求到达时，服务器**动态地加载和链接适当的函数，然后直接调用它**，而不是使用fork和execve在子进程的上下文中运行函数。函数会一直**缓存在服务器的地址空间**中，所以只要一个简单的函数调用的开销就可以处理随后的请求了。这对一个繁忙的网站来说是有很大影响的。更进一步地说，在运行时无需停止服务器，就可以更新已存在的函数，以及添加新的函数。

------

Linux让我们可以用一个简单的接口，允许应用程序在运行时加载和链接共享库。

```c
#include <dlfcn.h>
void *dlopen(const char *filename, int flag);
```

用已用带**RTLD_GLOBAL**选项打开了的库解析filename中的外部符号。

如果当前可执行文件是带`-rdynamic`选项编译的，那么对符号解析而言，它的全局符号也是可用的。

| flag参数    | 效果                                                         |
| ----------- | ------------------------------------------------------------ |
| RTLD_GLOBAL | 通过`dlopen()`加载的动态库（`.so`）中的符号会被加入全局符号表，**后续加载的库或程序自身可以直接引用这些符号**。 |
| RTLD_LOCAL  | 动态库的符号仅对当前加载的库可见。                           |
| RTLD_NOW    | 在调用`dlopen()`时立即解析动态库的所有符号引用。**优点**：立即发现符号缺失或版本冲突（启动时失败，而非运行时崩溃）。**缺点**：增加启动时间（尤其是大型库）。 |
| RTLD_LAZY   | 延迟解析符号，仅在首次调用函数或访问变量时解析。**优点**：减少启动开销（按需解析符号）。**缺点**：首次调用可能因符号问题崩溃（运行时风险）。 |

后两个参数可以与前两个参数取或。

------

```c
#include <dlfcn.h>
void *dlsym(void *handle, char *symbol);
```

`dlsym`函数的输入是一个指向前面巳经打开了的共享库的句柄和一个`symbol`名字，如果该符号存在，就返回符号的地址，否则返回`NULL`。

------

```c
#include <dlfcn.h>
int dlclose (void *handle);
```

如果没有其他共享库还在使用这个共享库， `dlclose`函数就卸载该共享库。

------

```c
#include <dlfcn.h>
const char *dlerror(void);
```

`dlerror`函数返回一个字符串，它描述的是调用`dlopen`、`dlsym`或者`dlclose`函数时发生的最近的错误，如果没有错误发生，就返回`NULL`。

------

例如我们以下面的方式调用GCC：

```bash
linux> gcc -rdynamic -o prog2r dll.c -ldl
```

~~这里`-ldl`是链接动态库`libdl.so`，提供动态加载功能（如`dlopen`、`dlsym`）~~

## 7.12位置无关代码

**位置无关代码（PIC）**是一种编译后的机器代码，其执行不依赖于固定的内存地址。

多个进程可能同时使用同一个动态库（如 `libc.so`），但它们的地址空间不同。PIC允许动态库被加载到不同进程的任意位置，无需为每个进程单独重定位代码。

------

1. **PIC数据引用**
   事实：**无论我们在内存中的何处加载一个目标模块（包括共享目标模块），数据段与代码段的距离总是保持不变**。
   编译器在数据段开始的地方创建了一个表，叫做**全局偏移量表(Global Offset Table，GOT)**。在GOT中，每个被这个目标模块引用的**全局数据目标（过程或全局变量）**都有一个8字节条目。编译器还为GOT中每个条目生成一个重定位记录。在加载时，动态链接器会重定位GOT中的每个条目，使得它包含目标的正确的绝对地址。每个引用全局目标的目标模块都有自己的GOT。
   例如：

   ```bash
   addvec: # 下面GOT[3]和addl指令之间固定距离是0x2008b9,编译时已经确定
     mov 0x2008b9(%rip), %rax # rax=*GOT[3]=&addcnt
     addl $0x1,(%rax)         # addcnt++
   ```

   其中GOT表中`GOT[3]=&addcnt`。

2. **PIC函数调用**
   **延迟绑定(lazy binding)**：
   只在第一次调用某函数的时候解析函数地址，这个过程涉及两个表：

   - **过程链接表（PLT）**：

     每个条目是16字节代码。
     `PLT[0]`跳转到动态链接器。
     `PLT[1]`调用系统启动函数。
     之后的条目调用用户代码调用的函数。

   - **全局偏移量表（GOT）**：
     和PLT联用时，`GOT[0]`和`GOT[1]`包含动态链接器在解析函数地址时会使用的信息。
     `GOT[2]`是动态链接器在`ld-linux.so`模块中的入口点。
     其余每个条目对应于一个被调用的函数。
     每个GOT条目初始时都对应PLT条目的第二条指令。
     以下是一个明确的过程，延迟调用`addvec()`：

     ```bash
     GOT表:
     GOT[0]: addr of .dynamic
     GOT[1]: addr of reloc entries
     GOT[2]: addr of dynamic linker
     GOT[3]: 0x4005b6 # sys startup
     GOT[4]: 0x4005c6 # addvec()
     GOT[5]: 0x4005d6 # printf()
     ```

     ```bash
     PLT表:
     # PLT[0]: call dynamic linker
     4005a0: pushq *GOT[1]
     4005a6: jmpq *GOT[2]
     ...
     # PLT[2]: call addvec()
     4005c0: jmpq *GOT[4]
     4005c6: pushq $0x1
     4005cb: jmpq 4005a0
     ```

     - 不直接调用`addvec`而是进入`PLT[2]`。
     - 通过`GOT[4]`间接跳转，把控制传送回`PLT[2]`中的下一条指令。
     - 把`addvec`的ID(`0x1`)压入栈中，`PLT[2]`跳转回`PLT[0]`。
     - `PLT[0]`通过`GOT[1]`间接地把动态链接器的一个参数压入栈中，然后通过`GOT[2]`间接跳转进动态链接器中。动态链接器使用两个栈条目来确定`addvec`的运行时位置，用这个地址重写`GOT[4]`，再把控制传递给`addvec` 。

     日后调用`addvec`，传递到`PLT[2]`，直接通过`GOT[4]`的间接跳转转移到`addvec`。

## 7.13库打桩机制

**库打桩机制**它允许你截获对共享库函数的调用，取而代之执行自己的代码。使用打桩机制，你可以追踪对某个特殊库函数的调用次数，验证和追踪它的输入和输出值，或者甚至把它替换成一个完全不同的实现。

### 7.13.1编译时打桩

通过预处理器宏或条件编译：

```c
int foo(int x){return x*2;}
#define foo(x) (x*3) // 编译时替换所有foo调用
```

```c
#ifdef STUB_MODE
  int foo(int x){return 0;}
#else
  int foo(int x){return x*2;}
#endif
```

### 7.13.2链接时打桩

```bash
# 将原函数foo替换为__wrap_foo,原函数重命名为__real_foo
gcc -Wl,--wrap=foo main.c -o program
```

```c
// 桩函数定义
int __wrap_foo(int x){return x+1;}
// 可调用原函数(可选)
int __real_foo(int x);
```

### 7.13.3运行时打桩

在程序运行时，通过**动态链接拦截**或**函数指针替换**，覆盖目标函数。

```c
# 1.编写桩动态库
// stublib.c
#define _GNU_SOURCE
#include <dlfcn.h>
int foo(int x){
    typedef int (*RealFoo)(int);
    RealFoo real_foo=dlsym(RTLD_NEXT,"foo"); // 获取原函数
    return real_foo(x)+100; // 修改行为
}
```

```bash
# 2. 编译为动态库
gcc -shared -fpic -o stublib.so stublib.c -ldl
```

```bash
# 3. 运行程序时加载桩库
linux> LD_PRELOAD=./stublib.so ./program
#动态链接器(LD-LINUX.SO)会先搜索LO_PRELOAD库,然后才搜索任何其他的库
```

## 7.14处理目标文件的工具

- `AR`：创建静态库，插入、删除、列出和提取成员。
- `STRINGS`：列出一个目标文件中所有可打印的字符串。
- `STRIP`：从目标文件中删除符号表信息。
- `NM`：列出一个目标文件的符号表中定义的符号。
- `SIZE`：列出目标文件中节的名字和大小。
- `READELF`：显示一个目标文件的完整结构，包括ELF头中编码的所有信息。包含SIZE和NM的功能。
- `OBJDUMP`：所有二进制工具之母。能够显示一个目标文件中所有的信息。它最大的作用是反汇编`.text`节中的二进制指令。

`Linux`系统为操作共享库还提供了`LDD`程序：

- `LDD`：列出一个可执行文件在运行时所需要的共享库。

# 8.异常控制流

现代系统通过使控制流发生 **突变** 来对 **系统状态的变化** 做出反应 。一般而言 ，我们把这些 **突变** 称为 **异常控制流(Exceptional Control Flow, ECF)**。

异常控制流发生在计算机系统的各个层次。比如，在硬件层，硬件检测到的事件会触发控制突然转移到异常处理程序。

在操作系统层，内核通过上下文切换将控制从一个用户进程转移到另一个用户进程。

在应用层，一个进程可以发送信号到另一个进程，而接收者会将控制突然转移到它的一个信号处理程序。

一个程序可以通过回避通常的栈规则，执行到其他函数中任意位置的本地跳转来对错误做出反应。

## 8.1 异常

> [!NOTE]
>
> 异常是异常控制流的一种形式，它一部分由硬件实现，一部分由操作系统实现。
> **异常(exception)** 就是控制流中的突变，用来响应处理器状态中的某些变化。
> 状态变化称为 **事件(event)**。事件可能和当前指令的执行直接相关（虚拟内存缺页、算术溢出）。事件也可能和当前指令的执行没有关系（一个系统定时器产生信号）。

在任何情况下，当处理器检测到有事件发生时，它就会通过一张 **异常表（exception table）** 的跳转表，进行一个间接过程调用（异常），到一个专门设计用来处理这类事件的 **操作系统子程序（异常处理程序（exception handler））**。

当异常处理程序完成处理后，根据引起异常的事件的类型，会发生以下情况中的一种：

1. 处理程序将控制返回给当前指令 $I_{curr}$，即当事件发生时正在执行的指令。
2. 处理程序将控制返回给 $I_{next}$，如果没有发生异常将会执行的下一条指令。
3. 处理程序终止被中断的程序。

### 8.1.1 异常处理

系统中可能的每种类型的异常都分配了一个唯一的非负整数的 **异常号（exception number）**，其中一些是 **处理器设计者** 分配的（**被零除、缺页、内存访问违例、断点以及算术运算溢出**），一些是 **操作系统内核设计者** 分配的（**系统调用和来自外部设备的信号**）。

系统启动时，操作系统分配和初始化一张 **异常表**，使得表目 $k$ 包含异常 $k$ 的处理程序的地址。当 **运行时** 检测到一个事件并确定异常号 $k$，会通过异常表间接过程调用 **异常处理程序**。

> 异常表的起始地址放在一个叫做 **异常表基址寄存器** 的特殊 CPU 寄存器。

| 异常和过程调用的区别 | 异常                                                         | 过程调用           |
| -------------------- | ------------------------------------------------------------ | ------------------ |
| 返回地址             | 当前指令或下一条指令                                         | 返回地址被压入栈中 |
| 记录状态             | 将一些额外的处理器状态压到栈里                               | [none]             |
| 控制转移             | 如果控制从用户程序转移到内核，所有项目都被压到内核栈中，而不是用户栈 | 压到用户栈         |
| 访问权限             | **内核模式**（对所有的系统资源都有完全的访问权限）           | [none]             |

### 8.1.2 异常的类别

| 类别 | 原因                       | 异步/同步 | 返回行为             |
| ---- | -------------------------- | --------- | -------------------- |
| 中断 | 来自 $\ce{I/O}$ 设备的信号 | 异步      | 总是返回到下一条指令 |
| 陷阱 | 有意的异常                 | 同步      | 总是返回到下一条指令 |
| 故障 | 潜在可恢复的错误           | 同步      | 可能返回到当前指令   |
| 终止 | 不可恢复的错误             | 同步      | 不会返回             |


> [!NOTE]
>
> **异步**：无法预知何时触发，例如用户突然按下键盘。
>
> **同步**：程序刻意触发，例如调用 `printf` 时会陷入内核。

- **中断**：
  **由外部硬件设备（如键盘、磁盘、定时器）主动触发**，通知 CPU 处理异步事件。

- **陷阱**：
  **陷阱是有意的异常，是执行一条指令的结果**。陷阱最重要的用途是在用户程序和内核之间提供一个像过程一样的接口，叫做 **系统调用**：
  当向内核请求服务，比如：

  - **读个文件(read)**。
  - **创建一个新的进程(fork)** 。
  - **加载一个新的程序(execve)**。
  - **终止当前进程(exit)**

  为了允许对这些内核服务的受控的访问，处理器提供了 `syscall` 指令，用户程序想要请求服务 $n$ 时，执行 $syscall n$。

- **故障**：
  当故障发生时，处理器将控制转移给 **故障处理程序**，如果处理程序能够修正这个错误情况，它就将控制返回到引起故障的指令，从而重新执行它。
  否则，处理程序返回到内核中的 `abort` 例程，`abort` 例程终止引起故障的应用程序。

- **终止**：
  终止是不可恢复的致命错误造成的结果，通常是一些硬件错误。终止处理程序从不将控制返回给应用程序，而可能会终止这个应用程序。

### 8.1.3Linux/x86-64 系统中的异常

> 这里介绍部分异常作为示例。

| 异常号 | 描述                             | 异常类别   | 处理                                                         |
| ------ | -------------------------------- | ---------- | ------------------------------------------------------------ |
| 0      | 除法错误                         | 故障       | 终止程序                                                     |
| 13     | 一般保护故障(Segmentation fault) | 故障       | [none]                                                       |
| 14     | 缺页                             | 故障       | 处理程序将适当的磁盘上虚拟内存的一个页面映射到物理内存的一个页面，然后重新执行这条产生故障的指令 |
| 18     | 机器检查                         | 终止       | 机器检查处理程序从不返回控制给应用程序。                     |
| 32~255 | 操作系统定义的异常               | 中断或陷阱 | [none]                                                       |

C 程序用 `syscall` 函数可以直接调用任何系统调用。然而，实际中几乎没必要这么做。对于大多数系统调用，标准库提供了一组方便的包装函数。这些包装函数将参数打包到一起，以适当的系统调用指令陷入内核，然后将系统调用的返回状态传递回调用程序。

| 编号 | 名字    | 描述               | 编号 | 名字     | 描述                 |
| ---- | ------- | ------------------ | ---- | -------- | -------------------- |
| 0    | `read`  | 读文件             | 33   | `pause`  | 挂起进程直到信号到达 |
| 1    | `write` | 写文件             | 37   | `alarm`  | 调度告警信号的传送   |
| 2    | `open`  | 打开文件           | 39   | `getpid` | 获得进程 ID          |
| 3    | `close` | 关闭文件           | 57   | `fork`   | 创建进程             |
| 4    | `stat`  | 获得文件信息       | 59   | `execve` | 执行一个程序         |
| 9    | `mmap`  | 将内存页映射到文件 | 60   | `_exit`  | 终止进程             |
| 12   | `brk`   | 重置堆顶           | 61   | `wait4`  | 等待一个进程终止     |
| 32   | `dup2`  | 复制文件描述符     | 62   | `kill`   | 发送信号到一个进程   |

## 8.2 进程

异常是允许操作系统内核提供 **进程(process)** 概念的基本构造块，进程是计算机科学中最深刻、最成功的概念之一。

**进程的经典定义就是一个执行中程序的实例**。系统中的每个程序都运行在某个进程的 **上下文(context)** 中。
上下文是由程序正确运行所需的状态组成的。这个状态包括：

- 存放在内存中的程序的代码和数据。
- 它的栈。
- 通用目的寄存器的内容。
- 程序计数器。
- 环境变量。
- 打开文件描述符的集合。

每次用户通过向 shell 输入一个可执行目标文件的名字，运行程序时，shell 就会创建一个新的进程，然后在这个新进程的上下文中运行这个可执行目标文件。

应用程序也能够创建新进程，并且在这个新进程的上下文中运行它们自己的代码或其他应用程序。

进程提供给应用程序的关键抽象：

- 一个独立的逻辑控制流，它提供一个假象，好像我们的程序独占地使用处理器。
- 一个私有的地址空间，它提供一个假象，好像我们的程序独占地使用内存系统。

### 8.2.1 逻辑控制流

**逻辑控制流**：里面的 **程序计数器(PC)** 的值唯一地对应于包含在程序的可执行目标文件中的指令，或是包含在运行时动态链接到程序的共享对象中的指令。

**事实上**：进程是轮流使用处理器的。每个进程执行它的流的一部分，然后被 **抢占(preempted)（暂时挂起）**，然后轮到其他进程。

![image-20250508085948263](D:/黄羽翔/大学/计算机系统基础/pictures/image-20250508085948263.png)

### 8.2.2 并发流

一个 **逻辑流** 的执行在时间上与另一个流重叠，称为 **并发流(concurrent flow)**，这两个流被称为并发地运行。

多个流并发地执行的一般现象被称为 **并发(concurrency)**。一个进程和其他进程轮流运行的概念称为 **多任务(multitasking)**。一个进程执行它的控制流的一部分的每一时间段叫做 **时间片(time slice)**。因此，多任务也叫做 **时间分片(time slicing)**。

> 如果流 $X$ 在 $Y$ 开始之后和 $Y$ 结束之前开始，则称流 $X$ 和 $Y$ 互相并发。

如果两个流并发地运行在不同的处理器核或者计算机上，那么我们称它们为 **并行流(parallel flow)**，它们并行地 **运行(running in parallel)** ，且 **并行地执行(parallel execution)**。

### 8.2.3 私有地址空间

在一台 $n$ 位地址的机器上，地址空间是 $2^n$ 个可能地址的集合，进程为每个程序提供它自己的私有地址空间。

一般来说：**和这个空间中某个地址相关联的那个内存字节是不能被其他进程读或者写的**。

一般地址空间都有相同的通用结构，~~经典老图~~。

![image-20250508182149415](D:/黄羽翔/大学/计算机系统基础/pictures/image-20250508182149415.png)

### 8.2.4 用户模式和内核模式

为了 **保护操作系统内核**，处理器必须提供一种机制，限制一个应用可以执行的指令以及它可以访问的地址空间范围。

**模式位(mode bit)**：

> 模式位是处理器状态寄存器(如 x86 的 EFLAGS、ARM 的 CPSR)中的一个或多个二进制位，用于指示 CPU 当前所处的执行模式。

- 当设置了 **模式位** 时，进程就运行在 **内核模式** 中（有时叫做超级用户模式）。一个运行在内核模式的进程可以执行指令集中的任何指令，并且可以访问系统中的任何内存位置。
- 没有设置模式位时，进程就运行在 **用户模式** 中。用户模式中的进程不允许执行 **特权指令(privileged instruction)**，比如停止处理器、改变模式位，或者发起一个 I/0 操作。也不允许用户模式中的进程直接引用地址空间中内核区内的代码和数据。任何这样的尝试都会导致致命的保护故障。
  反之，用户程序必须通过 **系统凋用接口** 间接地访问内核代码和数据。

进程从 **用户模式变为内核模式** 的唯一方法是通过诸如 **中断、故障或者陷入系统调用** 这样的异常。
当异常发生时，控制传递到异常处理程序，处理器将模式从用户模式变为内核模式。处理程序运行在内核模式中，当它返回到应用程序代码时，处理器就把模式从内核摸式改回到用户模式。

**/proc 文件系统**：/proc 文件系统将许多内核数据结构的内容输出为一个用户程序可以读的文本文件的层次结构，它不占用实际磁盘空间，而是由内核动态生成的，提供了一种访问内核数据和系统信息的接口。

```bash
/proc/cpuinfo      # CPU信息
/proc/meminfo      # 内存使用情况
/proc/version      # 内核版本
/proc/uptime       # 系统运行时间
/proc/loadavg      # 系统负载平均值
/proc/interrupts   # 中断信息
/proc/modules      # 已加载内核模块
/proc/filesystems  # 支持的文件系统
```

每个运行进程都有一个以其 PID 命名的目录。

```bash
/proc/1234/        # PID为1234的进程信息
    ├── cmdline    # 启动命令
    ├── cwd        # 当前工作目录(符号链接)
    ├── exe        # 执行文件路径(符号链接)
    ├── fd/        # 打开的文件描述符
    ├── status     # 进程状态信息
    ├── statm      # 内存使用统计
    └── ...

```

### 8.2.5 上下文切换

操作系统内核使用一种称为 **上下文切换(context switch)** 的较高层形式的异常控制流来实现多任务。

**上下文**：

> 上下文就是内核重新启动一个被抢占的进程所需的状态，它由一些对象的值组成：
>
> - 目的寄存器。
> - 浮点寄存器。
> - 程序计数器。
> - 用户栈。
> - 状态寄存器。
> - 内核栈。
> - 各种内核数据结构。
>   - 描述地址空间的页表。
>   - 包含有关当前进程信息的进程表。
>   - 包含进程已打开文件的信息的文件表。

**调度**：

> 在进程执行的某些时刻，内核可以决定抢占当前进程，并重新开始一个先前被抢占了的进程。这是由由内核中称为 **调度器(scheduler)** 的代码处理的。
> 在内核调度了一个新的进程运行后，它就抢占当前进程，并使用一种称为 **上下文切换** 的机制来将控制转移到新的进程。
>
> 1. 保存当前进程的上下文。
> 2. 恢复某个先前被抢占的进程被保存的上下文。
> 3. 将控制传递给这个新恢复的进程。

如果系统调用因为等待某个事件发生而阻塞，那么内核可以让当前进程休眠，切换到另一个进程，以此来 **优化进程调用**。

**中断也可能引发上下文切换**。比如，所有的系统都有某种产生周期性定时器中断的机制，通常为每 1 毫秒或每 10 毫秒。每次发生定时器中断时，内核就能判定当前进程已经运行了足够长的时间，并切换到一个新的进程。

## 8.3 系统调用错误处理

当 Unix 系统级函数遇到错误时，它们通常会返回-1，并设置全局整数变量 errno 来表示什么出错了。

例如：

```c
if((pid=fork())<0){
	fprintf(stderr,"fork error: %s\n",strerror(errno));
	exit(0);
}
```

当然我们可以把这个错误函数封装成 **错误报告函数**，以保持代码示例简洁。

## 8.4 进程控制

### 8.4.1 获取进程 ID

`getpid`函数返回调用进程的 PID。
`getppid`函数返回它的父进程的 PID（创建调用进程的进程）。

```c
#include <sys/types.h>
#include <unistd.h>

pid_t getpid(void)
pid_t getppid(void)
```

> 在Linux上`pid_t`被定义为`int`。

### 8.4.2创建和终止进程

从程序员的角度，我们可以认为进程总是处于下面三种状态之一：

- **运行**。进程要么在CPU上执行，要么在等待被执行且最终会被内核调度。
- **停止**。进程的执行**被挂起(suspended)**，且不会被调度。当收到`SIGSTOP`、`SIGTSTP`、`SIGTTIN`或者`SIGTTOU`信号时，进程就停止，并且保待停止直到它收到一个`SIGCONT`信号，在这个时刻，进程再次开始运行。
- **终止**。进程永远地停止了。进程会因为三种原因终止：
  -  收到一个信号，该信号的默认行为是终止进程。
  -  从主程序返回。
  -  调用`exit`函数。

```c
#include <stdlib.h>
void exit(int status);
```

`exit`函数以`status`退出状态来终止进程（另一种设置退出状态的方法是从主程序中返回一个整数值）。

```c
#include <sys/types.h>
#include <unistd.h>

pid_t fork(void);
```

父进程通过调用`fork`函数创建一个新的运行的子进程。

> [!NOTE]
>
> **子进程得到与父进程用户级虚拟地址空间相同的（但是独立的）一份副本，包括代码和数据段、堆、共享库以及用户栈。子进程还获得与父进程任何打开文件描述符相同的副本。**
> **这就意味着当父进程调用fork时，子进程可以读写父进程中打开的任何文件。父进程和新创建的子进程之间最大的区别在于它们有不同的PID。**

```c
int main(){
	pid_t pid;
	int x=1;
	pid=Fork();
	if(pid==0){ /* Child */
		printf("child : x＝%d\n",++x);
		exit(0);
	}
	/* Parent */
	printf("parent : x＝%d\n",--x);
	exit(0);
}
```

```bash
linux> ./fork
parent: x=0
child : x=2
```

这个简单的例子有一些微妙的方面：

- **调用一次，返回两次**。`fork`函数被父进程调用一次，但是却返回两次，一次是返回到父进程，一次是返回到新创建的子进程。
- **并发执行**。父进程和子进程是并发运行的独立进程。内核能够以任意方式交替执行它们的逻辑控制流中的指令。在我们的系统上运行这个程序时，父进程先完成它的`printf`语句，然后是子进程。然而，在另一个系统上可能正好相反。
- **相同但是独立的地址空间**。父进程和子进程有相同的用户栈、相同的本地变量值、相同的堆、相同的全局变量值，以及相同的代码。
  然而，因为父进程和子进程是独立的进程，它们都有自己的私有地址空间。父进程和子进程做的任何改变不会反映在另一个进程的内存中。
- **共享文件**。子进程继承了父进程所有的打开文件。当父进程调用`fork`时，`stdout`文件是打开的，并指向屏幕。子进程继承了这个文件，因此它的输出也是指向屏幕的。

### 8.4.3回收子进程

当一个进程由于某种原因终止时，被保持在一种已终止的状态中，直到被它的父进程**回收(reaped)** 。当父进程回收己终止的子进程时，内核将子进程的退出状态传递给父进程，然后抛弃己终止的进程，从此时开始，该进程就不存在了。

一个终止了但还未被回收的进程称为**僵死进程(zombie)**。

> init进程的PID为1，是在系统启动时由内核创建的，它不会终止，是所有进程的祖先。

如果父进程没有回收它的僵死子进程就终止了，那么内核会安排init进程去回收它们。

一个进程可以通过调用`waitpid`函数来等待它的子进程终止或者停止。

```c
#include <sys/types.h>
#include <sys/wait.h>

pid_t waitpid(pid_t pid, int *statusp, int options);
```

当`options=0`时，`waitpid`挂起调用进程的执行，直到它的**等待集合(wait set)**中的一个子进程终止，返回已终止子进程的PID。

1. **判定等待集合的成员**：
   如果`pid>0`，那么等待集合就是一个单独的子进程，进程ID等于`pid`。

   如果`pid=-1`，那么等待集合就是由父进程所有的子进程组成的。

2. **修改默认行为**：
   将`options`设置为以下常量来修改默认行为：
   `WNOHANG`：如果等待集合中的任何子进程都还没有终止，那么就立即返回0。默认的行为是挂起调用进程，直到有子进程终止。在等待子进程终止的同时，如果还想做些有用的工作，这个选项会有用。

   `WUNTRACED`：挂起调用进程的执行，直到等待集合中的一个进程变成已终止或者被停止。返回的`PID`为导致返回的已终止或被停止子进程的`PID`。默认的行为是只返回己终止的子进程。当你想要检查己终止和被停止的子进程时，这个选项会有用。

   `WCONTINUED`：挂起调用进程的执行，直到等待集合中一个正在运行的进程终止或等待集合中一个被停止的进程收到`SIGCONT`信号重新开始执行。

3. **检查已回收子进程的退出状态**：

   如果`statusp`参数是非空的，那么`waitpid`就会在`status`中放上关于导致返回的子进程的状态信息，`status`是`statusp`指向的值。`wait.h`头文件定义了解释`status`参数的几个宏：

   - **WIFEXITED(status)**：如果子进程通过调用`exit`或者一个**返回(return)**正常终止，就返回真。
   - **WEXITSTATUS(status)**：返回一个正常终止的子进程的退出状态。只有在**WIFEXITED()**返回为真时，才会定义这个状态。
   - **WIFSIGNALED(status)**：如果子进程是因为一个未被捕获的信号终止的，那么就返回真。
   - **WTERMSIG(status)**：返回导致子进程终止的信号的编号。只有在**WIFSIGNALED()**返回为真时，才定义这个状态。
   - **WIFSTOPPED(status)**：如果引起返回的子进程当前是停止的，那么就返回真。
   - **WSTOPSIG(status)**：返回引起子进程停止的信号的编号。只有在**WIFSTOPPED()**返回为真时，才定义这个状态。
   - **WIFCONTINUED(status)**：如果子进程收到**SIGCONT**信号重新启动，则返回真。

4. **错误条件**：

   如果调用进程没有子进程，那么`waitpid`返回`-1`，并且设置`errno`为`ECHILD`。如果`waitpid`函数被一个信号中断，那么它返回`-1`，并设置`errno`为`EINTR`。

5. **wait函数**：
   `wait`函数是`waitpid`函数的简单版本：

   ```c
   #include <sys/types.h>
   #include <sys/wait.h>
   
   pid_t wait(int *statusp);
   // wait(&status)等价于 waitpid(-1,&status,0);
   ```

6. **使用waitpid的示例**：

   以下展示了一个程序，它使用`waitpid`，不按照特定的顺序等待它的所有N个子进程终止。

   ```c
   #include "csapp.h"
   #define N 2
   
   int main()
   {
   	int status, i;
   	pid_t pid;
       
   	/* Parent creates N children */
   	for (i = 0; i < N; i++)
   		if ((pid = Fork()) == 0) /* Child */
   			exit(100+i);
   
   	/* Parent reaps N children in no particular order */
   	while ((pid = waitpid(-1, &status, 0)) > 0) { //-1表示等待任意子进程
   		if (WIFEXITED(status)) printf("child %d terminated normally with exit status=%d\n",pid, WEXITSTATUS(status));
   		else printf("child %d terminated abnormally\n", pid);
   	}
   	
   	/* The only normal termination is if there are no more children */
   	if (errno ! = ECHILD)unix_error("waitpid error");
   	exit(0);
   }
   ```

   它可能输出：

   ```bash
   linux> ．/waitpid1
   child 22966 terminated normally with exit status=100
   child 22967 terminated normally with exit status=101
   ```

   或：

   ```bash
   linux> ．/waitpid1
   child 22966 terminated normally with exit status=101
   child 22967 terminated normally with exit status=100
   ```

   只需稍作改动即可让它不具有不确定性：

   ```c
   #include "csapp.h"
   #define N 2
   
   int main()
   {
   	int status, i;
   	pid_t pid[N], retpid;
       
   	/* Parent creates N children */
   	for (i = 0; i < N; i++)
   		if ((pid[i] = Fork()) == 0) /* Child */
   			exit(100+i);
   
   	/* Parent reaps N children in no particular order */
   	i = 0;
   	while ((retpid = waitpid(pid[i++], &status, 0)) > 0) { //-1表示等待任意子进程
   		if (WIFEXITED(status)) printf("child %d terminated normally with exit status=%d\n",retpid, WEXITSTATUS(status));
   		else printf("child %d terminated abnormally\n", retpid);
   	}
   	
   	/* The only normal termination is if there are no more children */
   	if (errno ! = ECHILD)unix_error("waitpid error");
   	exit(0);
   }
   ```

   

### 8.4.4让进程休眠

`sleep`函数将一个进程挂起一段指定的时间。

如果请求的时间量已经到了，`sleep`返回`0`，否则返回还剩下的要休眠的秒数。后一种情况是可能的，如果因为`sleep`函数被一个信号中断而过早地返回。

```c
#include <unistd.h>
unsigned int sleep(unsigned int secs);
```

`pause`函数让调用函数休眠，直到该进程收到一个信号。

```c
#include <unistd.h>
int pause(void);
```

### 8.4.5加载并运行程序

`execve`函数在当前进程的上下文中加载并运行一个新程序。

**该函数调用一次从不返回**。

```c
#include <unistd.h>
int execve(const char *filename, const char *argv[], const char *envp[]);
```

那么`argv[]`和`envp[]`是什么呢？

![image-20250509231550396](D:/黄羽翔/大学/计算机系统基础/pictures/image-20250509231550396.png)

`execve`加载`filename`后，调用**启动代码**，然后设置**栈**，将控制传递给新程序的主函数。

```c
int main(int argc, char*argv[], char *envp[]);
```

![image-20250509232158656](D:/黄羽翔/大学/计算机系统基础/pictures/image-20250509232158656.png)

1. **argc**：给出`argv[]`数组中非空指针的数量。
2. **argv**：指向`argv[]`数组中的第一个条目。
3. **envp**：指向`envp[]`数组中的第一个条目。

Linux提供了几个函数来操作环境数组：

```c
#include <stdlib.h>
char *getenv(const char *name);
```

将返回一个环境数组中指向`value`的指针或`NULL`。

```c
#include <stdlib.h>
int setenv(const char *name, const char *newvalue, int overwrite);

void unsetenv(const char *name);
```

前者在`overwrite`非零时，会用`newvalue`代替`oldvalue`。如果`name`不存在，那么把`name=newvalue`添加到数组中。

后者回删除形如`name=oldvalue`的字符串。

### 8.4.6利用fork和execve运行程序

> [!IMPORTANT]
>
> 下面展示一个简单`shell`的`main`例程：`shell`打印一个命令行提示符，等待用户在`stdin`上输入命令行，然后对这个命令行求值。

```c
#include "csapp.h"
#define MAXARGS 128

/* Function prototypes */
void eval(char *cmdline);
int parseline(char *buf, char **argv);
int builtin_command(char **argv);

int main()
{
	char cmdline[MAXLINE]; /* Command line */

	while (1) {
	/* Read */
	printf("> ");
	Fgets(cmdline, MAXLINE, stdin);
	if (feof (stdin))
		exit(0);

	/* Evaluate */
	eval (cmdline);
	}
}
```

> [!IMPORTANT]
>
> 下面展示了对命令行求值的代码。

```c
/* eval - Evaluate a command line */
void eval (char * cmdline)
{
	char *argv[MAXARGS]; /* Argument list execve() */
	char buf[MAXLINE];   /* Holds modified command line */
	int bg;              /* Should the job run in bg or fg? */
	pid_t pid;           /* Process id */

	strcpy(buf, cmdline);
	bg = parseline(buf, argv);
    /* Parses the space-delimited command line arguments and constructs the argv vector that will eventually be passed to execve */
    /* bg will be 1 if the last parameter is '&' or bg will be 0 */
	if (argv[0] == NULL)
		return; /* Ignore empty lines */
	if (!builtin_command(argv)) { /* It is a built-in command or not. */
		if ((pid = Fork()) == 0) { /* Child runs user job */
			if (execve(argv[0], argv, environ) < 0) {
				printf("%s: Command not found.\n", argv[0]);
				exit(0);
			}
		}

		/* Parent waits for foreground job to terminate */
		if (!bg) {
			int status;
			if (waitpid(pid, &status, 0) < 0)
				unix_error("waitfg: waitpid error");
		}
		else
			printf("%d %s", pid, cmdline);
	}
	return;
}

/* If first arg is a builtin command, run it and return true */
int builtin_command(char **argv) /* Actual builtin_command includes numerous other commands */
{
	if (!strcmp(argv[0], "quit")) /* quit command */
		exit(0);
	if (!strcmp(argv[0], "&"))    /* Ignore singleton & */
		return 1;
	return 0;                     /* Not a builtin command */
}
```

```c
/* parseline - Parse the command line and build the argv array */
int parseline(char *buf, char **argv)
{
	char *delim;        /* Points to first space delimiter */
	int argc;           /* Number of args */
	int bg;             /* Background job? */

	buf[strlen(buf)-1] = ' '; /* Replace trailing '\n' with space */
	while (*buf && (*buf == ' ')) /* Ignore leading spaces */
		buf++;

	/* Build the argv list */
	argc = 0;
	while ((delim = strchr(buf, ' '))) {
		argv[argc++] = buf;
		*delim = '\0';
		buf = delim + 1;
		while (*buf && (*buf == ' ')) /* Ignore spaces */
			buf++;
	}
	argv[argc] = NULL;

	if (argc == 0) /* Ignore blank line */
		return 1;
	/* Should the job run in the background? */
	if ((bg = (*argv[argc-1] == '&')) != 0)
		argv[--argc] = NULL;
		
	return bg;
}
```

注意这个shell并不回收后台子进程，我们将在下一节讨论这个问题。

## 8.5信号

> 在本节中，我们将研究一种更高层的软件形式的异常，称为**Linux信号**，它允许进程和内核中断其他进程。
>
> 一个信号就是一条小消息，它通知进程系统中发生了一个某种类型的事件。
>
> 每种信号类型都对应于某种系统事件。低层的硬件异常是由内核异常处理程序处理的，正常情况下，对用户进程而言是不可见的。信号提供了一种机制，通知用户进程发生了这些异常。
> 比如，如果当进程在前台运行时，你键入Ctrl+C，那么内核就会发送一个`SIGINT`信号(号码2)给这个前台进程组中的每个进程。

| 序号 | 名称      | 默认行为              | 相应事件                       |
| ---- | --------- | --------------------- | ------------------------------ |
| 1    | SIGHUP    | 终止                  | 终端线挂断                     |
| 2    | SIGINT    | 终止                  | 来自键盘的中断                 |
| 3    | SIGQUIT   | 终止                  | 来自键盘的退出                 |
| 4    | SIGILL    | 终止                  | 非法指令                       |
| 5    | SIGTRAP   | 终止并转储内存        | 跟踪陷阱                       |
| 6    | SIGABRT   | 终止并转储内存        | 来自abort函数的终止信号        |
| 7    | SIGBUS    | 终止                  | 总线错误                       |
| 8    | SIGFPE    | 终止并转储内存        | 浮点异常                       |
| 9    | SIGKILL   | 终止                  | 杀死程序                       |
| 10   | SIGUSR1   | 终止                  | 用户定义的信号1                |
| 11   | SIGSEGV   | 终止并转储内存        | 无效的内存引用(段故障)         |
| 12   | SIGUSR2   | 终止                  | 用户定义的信号2                |
| 13   | SIGPIPE   | 终止                  | 向一个没有读用户的管道做写操作 |
| 14   | SIGALRM   | 终止                  | 来自alarm函数的定时器信号      |
| 15   | SIGTERM   | 终止                  | 软件终止信号                   |
| 16   | SIGSTKFLT | 终止                  | 协处理器上的栈故障             |
| 17   | SIGCHLD   | 忽略                  | 一个子进程停止或者终止         |
| 18   | SIGCONT   | 忽略                  | 继续进程如果该进程停止         |
| 19   | SIGSTOP   | 停止直到下一个SIGCONT | 不是来自终端的停止信号         |
| 20   | SIGTSTP   | 停止直到下一个SIGCONT | 来自终端的停止信号             |
| 21   | SIGTTIN   | 停止直到下一个SIGCONT | 后台进程从终端读               |
| 22   | SIGTTOU   | 停止直到下一个SIGCONT | 后台进程向终端写               |
| 23   | SIGURG    | 忽略                  | 套接字上的紧急情况             |
| 24   | SIGXCPU   | 终止                  | CPU时间限制超出                |
| 25   | SIGXFSZ   | 终止                  | 文件大小限制超出               |
| 26   | SIGVTALRM | 终止                  | 虚拟定时器期满                 |
| 27   | SIGPROF   | 终止                  | 剖析定时器期满                 |
| 28   | SIGWINCH  | 忽略                  | 窗口大小变化                   |
| 29   | SIGIO     | 终止                  | 在某个描述符上可执行I/O操作    |
| 30   | SIGPWR    | 终止                  | 电源故障                       |

> **转储内存**：把代码和数据内存段的映像写到磁盘上。

### 8.5.1信号术语

**传送一个信号到目的进程**：

- **发送信号**：

  - 内核检测到一个系统事件，比如除零错误或者子进程终止。
  - 一个进程调用`kill`函数时。

  内核会通过更新目的进程上下文中的某个状态，发送一个信号给目的进程。

- **接收信号**：
  当目的进程被内核~~强迫以某种方式~~对信号的发送做出反应时，它**接收信号**。进程可以

  - **忽略这个信号**。
  - **终止**。
  - 通过执行一个称为**信号处理程序(signal handler)**的用户层函数捕获这个信号。

**待处理信号**：一个发出而没有被接收的信号。

> 在任何时刻，一种类型至多只会有一个待处理信号。
>
> 当一个信号被进程阻塞时，它仍可以被发送，但是产生的待处理信号不会被接收，直到进程取消对这种信号的阻塞。

**一个待处理信号最多只能被接收一次**。

内核为每个进程在`pending`位向量中维护着待处理信号的集合，而在`blocked`位向量中维护着被阻塞的信号集合。

只要发送了一个类型为K的信号，内核就会设置`pending`中的第K位，而只要接收了一个类型为K的信号，内核就会清除`pending`中的第`K`位。

### 8.5.2发送信号

**进程组**：

每个进程都只属于一个进程组，进程组是由一个正整数进程组ID来标识的。

```c
#include <unistd.h>
pid_t getpgrp(void); 
```

`getpgrp`返回当前进程的进程组ID。

```c
#include <unistd.h>
int setpgid(pid_t pid, pid_t pgid);
```

`segpgid`将进程`pid`的进程组改为`pgid`。

> `pid`为0时表示当前进程，`pgid`为0时就用`pid`指定的进程的`PID`作为进程组ID。

**用/bin/kill程序发送信号**：

`/bin/kill`程序可以向另外的进程发送任意的信号。

```bash
linux> /bin/kill -9 -15213
```

是发送一个`SIGKILL`信号给进程组15213中的每个进程。

> 为负的PID会导致信号被发送到进程组PID中的每个进程。
>
> 在此我们使用完整路径`/bin/kill`，因为有些Unix shell有自己内置的`kill`命令。

**从键盘发送信号**：

> **作业(job)**：表示为对一条命令行求值而创建的进程。
>
> 任何时刻，至多只有一个前台作业和0个或多个后台作业。

```bash
linux> ls | sort
```

会创建一个由两个进程组成的前台作业。这两个进程是通过Unix管道连接起来的：**一个进程运行ls程序，另一个运行sort程序**。
shell为每个作业创建一个独立的进程组。进程组ID通常取自作业中父进程中的一个。

![image-20250511160814308](D:/黄羽翔/大学/计算机系统基础/pictures/image-20250511160814308.png)

- 输入`Ctrl+C`会导致内核发送一个`SIGINT`信号到前台进程组中的每个进程。默认情况下，结果是**终止**前台作业。
- 输入`Ctrl + Z`会发送一个SIGTSTP信号到前台进程组中的每个进程。默认情况下，结果是**停止（挂起）**前台作业。

**用kill函数发送信号**：

进程通过调用`kill`函数发送信号给其他进程（包括它们自己）：

```c
#include <sys/types.h>
#include <signal.h>
int kill(pid_t pid, int sig);
```

> 如果`pid`大于零，那么`kill`函数发送信号号码`sig`给进程`pid`。
>
> 如果`pid`等于零，那么`kill`发送信号`sig`给调用进程所在进程组中的每个进程，包括调用进程自己。
>
> 如果`pid`小于零，`kill`发送信号`sig`给进程组`|pid|`中的每个进程。

```c
#include "csapp.h"

int main()
{
	pid_t pid;

	/* Child sleeps until SIGKILL signal received, then dies */
	if ((pid = Fork()) == 0) {
	Pause(); /* Wait for a signal to arrive */
	printf("control should never reach here!\n");
	exit(0);
}

	/* Parent sends a SIGKILL signal to a child */
	Kill (pid, SIGKILL);
	exit(0);
}
```

**用alram函数发送信号**：

进程可以通过调用`alarm`函数向它自己发送`SIGALRM`信号。

```c
#include <unistd.h>
unsigned int alarm(unsigned int secs);
```

> `alarm`函数安排内核在`secs`秒后发送一个`SIGALRM`信号给调用进程。
>
> 如果secs是零，那么不会调度安排新的**闹钟(alarm)**。在任何情况下，对`alarm`的调用都将取消任何待处理的**(pending)闹钟**，并且返回其在被发送前还剩下的秒数，如果没有任何待处理的闹钟，就返回零。

### 8.5.3接收信号

当内核把进程`p`从内核模式切换到用户模式时（例如，从系统调用返回或是完成了一次上下文切换），它会检查进程p的**未被阻塞的待处理信号的集合(pending&~blocked)**。

如果这个集合为空，那么内核将控制传递到**p的逻辑控制流中的下一条指令**($I_{next}$)。

如果集合非空，那么内核选择集合中的某个信号`k`(通常是最小的`k`)，强制`p`接收信号`k`。收到这个信号会触发进程采取某种行为。一旦进程完成了这个行为，那么控制就传递回**p的逻辑控制流中的下一条指令**($I_{next}$)。

每个信号类型都有一个预定义的默认行为，是下面中的一种：

- 进程终止。
- 进程终止并转储内存。
- 进程停止（挂起）直到被`SIGCONT`信号重启。
- 进程忽略该信号。

> 进程可以通过使用`signal`函数修改和信号相关联的默认行为，除了`SIGSTOP`和`SIGKILL`。

```c
#include <signal.h>
typedef void (*sighandler_t)(int);

sighandler_t signal(int signum, sighandler_t handler);
```

- 如果`handler`是`SIG_IGN`，那么忽略类型为`signum`的信号。
- 如果`handler`是`SIG_DFL`，那么类型为`signum`的信号行为恢复为默认行为。
- 否则，`handler`就是用户定义的函数的地址，这个函数被称为**信号处理程序**，只要进程接收到一个类型为`signum`的信号，就会调用这个程序。
  通过把处理程序的地址传递到`signal`函数从而改变默认行为，这叫做**设置信号处理程序(installing the handler)**。**调用信号处理程序被称为捕获信号。执行信号处理程序被称为处理信号。**

下面展示了一个程序，它捕获`SIGINT`信号(由键盘`Ctrl + C`发送)，修改为输出错误信息然后退出。

```c
#include "csapp.h"

void sigint_handler(int sig) /* SIGINT handler */
{
	printf("Caught SIGINT!\n");
	exit(0);
}

int main()
{
	/* Install the SIGINT handler */
	if (signal(SIGINT, sigint_handler) == SIG_ERR)unix_error("signal error");
	
	pause(); /* Wait for the receipt of a signal */
	
	return 0;
}
```

### 8.5.4阻塞和解除阻塞信号

**隐式阻塞机制**：内核默认阻塞任何当前处理程序正在处理信号类型的待处理的信号。

**显式阻塞机制**：应用程序可以使用`sigprocmask`函数和它的辅助函数，明确地阻塞和解除阻塞选定的信号。

```c
#include <signal.h>
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
int sigemptyset(sigset_t *set); // 初始化set为空集合。
int sigfillset(sigset_t *set); // 把每个信号都添加到set中。
int sigaddset(sigset_t *set, int signum); // 把signum添加到set中。
int sigdelset(sigset_t *set, int signum); // 从set中删除signum。
// 返回:如果成功则为0,若出错则为-1
int sigismember(const sigset_t *set, int signum);
// 返回:若signum是set的成员则为1,如果不是则为0,若出错则为-1
```

其中：

```c
int sigprocmask(int how, const sigset_t *set, sigset_t *oldset);
```

- `how`：用于指定信号修改的方式，可能选择有三种
  - `SIG_BLOCK`：把`set`中的信号添加到`blocked`中(`blocked=blockedIset`)。
  - `SIG_UNBLOCK`：从`blocked`中删除`set`中的信号(`blocked=blocked&~set`)。
  - `SIG_SETMASK`：`block=set`。
- 如果`oldset`非空，那么`blocked`位向量之前的值保存在`oldset`中。

下面一个例子演示如何**临时阻塞接收SIGINT信号**。

```c
sigset_t mask, prev_mask;

Sigemptyset(&mask);
Sigaddset(&mask, SIGINT);

/* Block SIGINT and save previous blocked set */
Sigprocmask(SIG_BLOCK, &mask, &prev_mask);
/* Code region that will not be interrupted by SIGINT */
/* Restore previous blocked set, unblocking SIGINT */
Sigprocmask(SIG_SETMASK, &prev_mask, NULL);
```

### 8.5.5编写信号处理程序

- **安全的信号处理**：
  这里引入一些原则，为您安全处理信号提供参考：

  - **处理程序要尽可能简单**。

  - **在处理程序中只调用异步信号安全的函数**。
    因为这些函数是**可重入的**（例如只访问局部变量）。
    或者它不能被信号处理程序中断。

    > `printf`、`sprintf`、`malloc`和`exit`不在其中。

    ![image-20250512191003117](D:/黄羽翔/大学/计算机系统基础/pictures/image-20250512191003117.png)

  - **保存和恢复errno**：
    在进入处理程序时把errno保存在一个局部变量中，在**处理程序返回**前恢复它。

  - **阻塞所有的信号，保护对共享全局数据结构的访问**：
    保证主程序在访问数据结构的时候，处理程序不会中断指令序列。

  - **用volatile声明全局变量。考虑一个处理程序和一个main函数，它们共享一个全局变量g**：`volatile`限定符强迫编译器每次在代码中引用`g`时，都要从内存中读取`g`的值。否则如果编译器进行了优化，`main`函数可能**不会察觉到全局变量的变化**。

  - **用sig_atomic _t声明标志**：

    ```c
    volatile sig_atomic_t flag;
    ```

    这样的数据类型对其读写会是原子的（不可中断的），所以可以直接读写，但要求是单个指令的读写，而`flag++`这种不是。

- **正确的信号处理**：
  `pending`位向量中每种类型的信号只对应有一位。~~也就是信号不会排队~~。
  ~~书本例子太长了，反正建议我们**每接收一个信号就完成尽可能多的事**~~。

- **可移植的信号处理**：
  基于以下问题：

  - **signal函数的语义在各个系统上各有不同**
  - **系统调用可以被中断**

  `Posix`标准定义了`sigaction`函数，它允许用户在设置信号处理时，明确指定他们想要的信号处理语义。

  ```c
  #include <signal.h>
  
  int sigaction(int signum, struct sigaction *act, struct sigaction *oldact);
  /*
  参数1:要捕获的信号
  参数2:接收到信号之后对信号进行处理的结构体
  参数3:接收到信号之后,保存原来对此信号处理的各种方式与信号。
  成功时:返回0
  出错时:返回-1,并将errno设置为指示错误
  */
  ```

  其中：

  ```c
  struct sigaction {
      void (*sa_handler)(int); // 信号处理函数,也可以设置为SIG_IGN(向内核表示忽略此信号)或是SIG_DFL(表示接到此信号后的动作是系统默认动作)
      void (*sa_sigaction)(int, siginfo_t *, void *); // 当sa_flags成员是SA_SIGINFO标志时,就调用此函数,可以来获取该信号的很多详细信息,具体不介绍
      sigset_t sa_mask; // 用来设置在处理该信号时暂时将sa_mask指定的信号集搁置
      int sa_flags; // 用来设置信号处理的其他相关操作,具体不介绍
      void (*sa_restorer)(void); // (废弃)
  }
  ```

  我们可以封装如下：

  ```c
  handler_t  *Signal(int signum, handler_t *handler) 
  {
      struct sigaction action, old_action;
  
      action.sa_handler = handler;  
      sigemptyset(&action.sa_mask); /* block sigs of type being handled */
      action.sa_flags = SA_RESTART; /* restart syscalls if possible */
  
      if (sigaction(signum, &action, &old_action) < 0)
          unix_error("Signal error");
      return (old_action.sa_handler);
  }
  ```

### 8.5.6同步流以避免讨厌的并发错误

**竞争**：由父进程和子进程交错运行带来的错误。

例如：

```c
void handler(int sig)
{
	int olderrno = errno;
	sigset_t mask_all, prev_all;
	pid_t pid;

	Sigfillset(&mask_all);
	while ((pid = waitpid(-1, NULL, 0)) > 0) { /* Reap a zombie child */
		Sigprocmask(SIG_BLOCK, &mask_all, &prev_all);
		deletejob(pid); /* Delete the child from the job list */
		Sigprocmask(SIG_SETMASK, &prev_all, NULL);
	}
	if (errno != ECHILD)
		Sio_error("waitpid error");
	errno = olderrno;
}

int main(int argc, char **argv)
{
	int pid;
	sigset_t mask_all, prev_all;

	Sigfillset(&mask_all);
	Signal(SIGCHLD, handler);
	initjobs(); /* Initialize the job list */

	while (1) {
		if ((pid = Fork()) == 0) { /* Child process */
			Execve("/bin/date", argv, NULL);
		}
		Sigprocmask(SIG_BLOCK, &mask_all, &prev_all); /* Parent process */
		addjob(pid); /* Add the child to the job list */
		Sigprocmask(SIG_SETMASK, &prev_all, NULL);
	}
	exit(0);
}
```

> 如果子进程在父进程能够开始运行前就结束了，那么`addjob`和`deletejob`会以错误的方式被调用。

我们可以把`while(1)`循环中更改为如下，以避免这个烦人的错误。

```c
Sigemptyset(&mask_one);
Sigaddset(&mask_one, SIGCHLD);
/* ... */
while (1) {
	Sigprocmask(SIG_BLOCK, &mask_one, &prev_one); /* Block SIGCHLD */
	if ((pid = Fork()) == 0) { /* Child process */
		Sigprocmask(SIG_SETMASK, &prev_one, NULL); /* Unblock SIGCHLD */
		Execve("/bin/date", argv, NULL);
	}
	Sigprocmask(SIG_BLOCK, &mask_all, NULL); /* Parent process */
	addjob(pid); /* Add the child to the job list */
	Sigprocmask(SIG_SETMASK, &prev_all, NULL);
}
```

### 8.5.7显式地等待信号

例如：

```c
#include "csapp.h"

volatile sig_atomic_t pid;

void sigchld_handler(int s)
{
	int olderrno = errno;
	pid = waitpid(-1, NULL, 0);
	errno = olderrno;
}

void sigint_handler(int s)
{
}

int main(int argc, char **argv)
{
	sigset_t mask, prev;

	Signal(SIGCHLD, sigchld_handler);
	Signal(SIGINT, sigint_handler);
	Sigemptyset(&mask);
	Sigaddset(&mask, SIGCHLD);

	while (1) {
		Sigprocmask(SIG_BLOCK, &mask, &prev); /* Block SIGCHLD */
		if (Fork() == 0) /* Child */
			exit (0);

		/* Parent */
		pid = 0;
		Sigprocmask(SIG_SETMASK, &prev, NULL); /* Unblock SIGCHLD */

		/* Wait for SIGCHLD to be received (wasteful) */
		while (!pid)
			;

		/* Do some work after receiving SIGCHLD */
		printf(".");
	}
	exit(0);
}
```

显然循环`while(!pid)`在浪费处理器资源，我们可以想到把它改成：

```c
while(!pid) /* Race! */
	pause();
```

但是在进入该循环之前，如果收到`SIGCHLD`信号，那么`pause()`会永远睡眠。

所以我们可以改成：

```c
while(!pid) /* Too slow! */
	sleep(1);
```

但是太慢。

------

最好的方法是使用`sigsuspend`。

```c
#include <signal.h>
int sigsuspend(const sigset_t *mask);
```

`sigsuspend`函数暂时用`mask`替换当前的阻塞集合，然后挂起该进程，直到收到一个信号。

其行为要么是运行一个处理程序，要么是终止该进程。

如果它的行为是终止，那么该进程不从`sigsuspend`返回就直接终止。

如果它的行为是运行一个处理程序，那么`sigsuspend`从处理程序返回，恢复调用`sigsuspend`时原有的阻塞集合。

```c
#include "csapp.h"

volatile sig_atomic_t pid;

void sigchld_handler(int s)
{
	int olderrno = errno;
	pid = waitpid(-1, NULL, 0);
	errno = olderrno;
}

void sigint_handler(int s)
{
}

int main(int argc, char **argv)
{
	sigset_t mask, prev;

	Signal(SIGCHLD, sigchld_handler);
	Signal(SIGINT, sigint_handler);
	Sigemptyset(&mask);
	Sigaddset(&mask, SIGCHLD);

	while (1) {
		sigprocmask(SIG_BLOCK, &mask, &prev); /* Block SIGCHLD */
		if (Fork() == 0) /* Child */
			exit (0);

		/* Wait for SIGCHLD to be received */
		pid = 0;
		while (!pid)
			sigsuspend(&prev);

		/* Optionally unblock SIGCHLD */
		sigprocmask(SIG_SETMASK, &prev, NULL);
		
		/* Do some work after receiving SIGCHLD */
		printf(".");
	}
	exit(0);
}
```

## 8.6非本地跳转

> **非本地跳转**是通过`setjmp`和`longjmp`实现的将控制直接从一个函数转移到另一个当前正在执行的函数。

```c
#include <setjmp.h>

int setjmp(jmp_buf env);
int sigsetjmp(sigjmp_buf env,int savesigs);
```

`setjmp`函数在`env`缓冲区中保存当前调用环境，以供后面的`longjmp`使用，并返回0。调用环境包括程序计数器、栈指针和通用目的寄存器

```c
#include <setjmp.h>

void longjmp(jmp_buf env, int retval);
void siglongjmp(sigjmp_buf env, int retval);
```

`longjmp`函数从`env`缓冲区中恢复调用环境，然后触发一个从最近一次初始化`env`的`setjmp`调用的返回。然后`setjmp`返回，并带有非零的返回值`retval`。

> `sigsetjmp`和`siglongjmp`函数是`setjmp`和`longjmp`的可以被信号处理程序使用的版本。

------

非本地跳转的一个重要应用就是**允许从一个深层嵌套的函数调用中立即返回**，通常是由检测到某个错误情况引起的。

如果在一个**深层嵌套的函数调用中发现了一个错误情况**，我们可以使用非本地跳转**直接返回到一个普通的本地化的错误处理程序**，而不是费力地解开调用栈。

------

`longjmp`类似于`goto`，可能会导致分配的某些数据结构最终没有被释放。

## 8.7操作进程的工具

Linux系统提供了大量的监控和操作进程的有用工具：
`STRACE`：**打印一个正在运行的程序和它的子进程调用的每个系统调用的轨迹**。
`PS`：**列出当前系统中的进程（包括僵死进程）**。
`TOP`：**打印出关于当前进程资源使用的信息**。
`PMAP`：**显示进程的内存映射**。
`/proc`：**一个虚拟文件系统，以ASCII文本格式输出大量内核数据结构的内容，用户程序可以读取这些内容**。比如，输入`“cat/proc/loadavg"`，可以看到你的Linux系统上当前的平均负载。

# 10.系统级I/O

## 10.1Unix I/O

一个Linux文件就是一个m字节的序列：
$$
B_0,B_1,\dots,B_k,\dots,B_{m-1}
$$
**所有的`I/O`设备（例如网络、磁盘和终端）都被模型化为文件，而所有的输入和输出都被当作对相应文件的读和写来执行。**

这种将设备优雅地映射为文件的方式，允许Linux内核引出一个简单、低级的应用接口，称为**Unix I/O**，这使得所有的输入和输出都能以一种统一且一致的方式来执行：

- **打开文件**：应用程序请求内核打开**相应文件**，内核返回一个小的非负整数，叫做**描述符**，它在后续对此文件的所有操作中标识这个文件。
  内核**记录有关这个打开文件的所有信息**。
  应用程序只需**记住这个描述符**。
- `Linux shell`创建的进程开始时有三个打开的文件：标准输入（描述符为0`STDIN_FILENO`）、标准输出（描述符为1`STDOUT_FILENO`）和标准错误（描述符为2`STDERR_FILENO`）。
- **改变当前的文件位置**：对于每个打开的文件，内核保持着一个文件位置$k$，初始为0。这个文件位置是从文件开头起始的字节偏移量。应用程序能够通过执行`seek`操作，显式地设置文件的当前位置为$k$。
- **读写文件**：一个读操作就是从文件复制$n>0$个字节到内存，从当前文件位置$k$开始，然后将$k$增加到$k+n$ 。
  给定一个大小为$m$字节的文件，当$k\ge m$ 时执行读操作会触发一个称为`end-of-file(EOF)`的条件，应用程序能检测到这个条件。尽管在文件结尾处并没有明确的EOF符号。
  类似地，写操作就是从内存复制$n>0$个字节到一个文件，从当前文件位置$k$开始，然后更新$k$。
- **关闭文件**：当应用完成了对文件的访问之后，它就通知内核关闭这个文件：**内核释放文件打开时创建的数据结构，并将这个描述符恢复到可用的描述符池中**。无论一个进程因为何种原因终止时，内核都会关闭所有打开的文件并释放它们的内存资源。

## 10.2文件

- **普通文件(regular file)**：包含**文本文件**和**二进制文件**。应用程序要区分它们，内核则不需要。
- **目录(directory)**：包含一组**链接(link)**的文件，每个链接都将一个文件名(filename)映射到一个文件。$.$是到该目录自身的链接，$..$是到父目录的链接。
- **套接字(socket)**：是用来与另一个进程进行跨网络通信的文件。

> 其他还有**命名通道(named pipe)**、**符号链接(symbolic link)**，以及**字符**和**块设备(character and block device)**，不在讨论范畴。

## 10.3打开和关闭文件

进程是通过调用`open`函数来打开一个已存在的文件或者创建一个新文件的：

```c
#include <sys/types.h> 
#include <sys/stat.h> 
#include <fcntl.h> 
int open(char *filename, int flags, mode_t mode);
//成功返回新文件描述符,出错为-1
```

`open`函数将`filename`转换为一个文件描述符，并且返回描述符数字。返回的描述符总是在进程中当前没有打开的最小描述符。

`flags`参数指明了进程打算如何访问这个文件：

- `O_RDONLY`：只读。
- `O_WRONLY`：只写。
- `O_RDWR`：可读可写。
- `O_CREAT`：如果文件不存在，就创建它的一个截断的(truncated)（空）文件。
- `O_TRUNC`：如果文件已经存在，就截断它。
- `O_APPEND`：在每次写操作前，设置文件位置到文件的结尾处。

`mode`参数指定了新文件的访问权限位。

| 掩码      | 描述                               |
| --------- | ---------------------------------- |
| `S_IRUSR` | 使用者（拥有者）能够读这个文件     |
| `S_IWUSR` | 使用者（拥有者）能够写这个文件     |
| `S_IXUSR` | 使用者（拥有者）能够执行这个文件   |
| `S_IRGRP` | 拥有者所在组的成员能够读这个文件   |
| `S_IWGRP` | 拥有者所在组的成员能够写这个文件   |
| `S_IXGRP` | 拥有者所在组的成员能够执行这个文件 |
| `S_IROTH` | 其他人（任何人）能够读这个文件     |
| `S_IWOTH` | 其他人（任何人）能够写这个文件     |
| `S_IXOTH` | 其他人（任何人）能够执行这个文件   |

作为上下文的一部分，每个进程都有一个`umas`，`mode`是通过调用`umask`函数来设置的。

例如：

```c
#define DEF_MODE S_IRUSR|S_IWUSR|S_IRGRP|S_IWGRP|S_IROTH|S_IWOTH 
#define DEF_UMASK S_IWGRP|S_IWOTH 
umask(DEF_UMASK); // mode = mode&~umask
fd = Open("foo.txt", O_CREATIO_TRUNCIO_WRONLY, DEF_MODE); // 权限设置为mode &~ umask
```

实现文件的拥有者有读写权限，而所有其他的用户都有读权限。

------

最后，进程通过涸用`close`函数关闭一个打开的文件。

```c
#include <unistd.h>
int close(int fd);
```

## 10.4读和写文件

应用程序是通过分别调用`read`和`write`函数来执行输入和输出的。

```c
#include <unistd.h>
ssize_t read(int fd, void *buf, size_t n);
ssize_t write(int fd, const void *buf, size_t n);
// 若成功则为读或写的字节数，若出错则为-1
```

`read`函数从描述符为`fd`的当前文件位置复制最多`n`个字节到内存位置`buf`。返回0表示`EOF`。否则，返回值表示的是实际传送的字节数量。

`write`函数从内存位置`buf`复制至多`n`个字节到描述符`fd`的当前文件位置。

------

通过调用`lseek`函数，应用程序能够显示地修改当前文件的位置。

------

在某些情况下，`read`和`write`传送的字节比应用程序要求的要少。这些**不足值(short count)**不表示有错误。出现这样情况的原因有：

- **读时遇到`EOF`**。
- **从终端读文本行**。如果打开文件是与终端相关联的（如键盘和显示器），那么每个`read`函数将一次传送一个文本行，返回的不足值等于文本行的大小。
- 读和写**网络套接字(socket)**。对Linux**管道(pipe)**调用`read`和`write`时，也有可能出现不足值。

实际上，除了`EOF`，**当你在读写磁盘文件时，将不会遇到不足值**。 然而，如果你想创建健壮的诸如Web服务器这样的网络应用，就必须通过反复调用`read`和`write`处理不足值，直到所有需要的字节都传送完毕。

## 10.5用RIO包健壮地读写

### 10.5.1RIO的无缓冲的输入输出函数

> 这些函数直接在内存和文件之间传送数据，没有应用级缓冲。它们对将二进制数据读写到网络和从网络读写二进制数据尤其有用。

通过调用`rio_readn`和`rio_writen`函数，应用程序可以在内存和文件之间直接传送数据。

```c
#include "csapp.h" 
ssize_t rio_readn(int fd, void *usrbuf, size_t n);
ssize_t rio_writen(int fd, void *usrbuf, size_t n);
// 若成功则为传送的宇节数,若EOF则为0(只对rio_readn而言),若出错则为-1
```

这两个函数实现**描述符fd的当前文件位置**和**内存位置usrbuf**的字节传递。

> 注意，如果`rio_readn`和`rio_writen`函数被一个从应用信号处理程序的返回中断，那么每个函数都会手动地重启`read`或`write`。

### 10.5.2RIO的带缓冲的输入函数

> 这些函数允许你高效地从文件中读取文本行和二进制数据，这些文件的内容缓存在应用级缓冲区内，~~类似于为`printf`这样的标准`I/O`函数提供的缓冲区~~。带缓冲的RIO输入函数是线程安全的，即它在同一个描述符上可以被交错地调用。

**包装函数(rio_readlineb)**，它从一个内部**读缓冲区**复制一个文本行，当缓冲区变空时，会自动地调用`read`重新填满缓冲区。对于既包含文本行也包含二进制数据的文件，我们也提供了一个`rio_readn`带缓冲区的版本，叫做`rio_readnb`，它从和`rio_readlineb`一样的读缓冲区中传送原始字节。

```c
#include "csapp.h" 
#define RIO_BUFSIZE 4096
typedef struct{
    int rio_fd; // 与缓冲区绑定的文件描述符的编号
    int rio_cnt; // 缓冲区中还未读取的字节数
    char *rio_bufptr; // 当前下一个未读取字符的地址
    char rio_buf[RIO_BUFSIZE];
}rio_t;
void rio_readinitb(rio_t *rp, int fd);
// 无返回值,可以将文件描述符与rio数据结构绑定起来
ssize_t rio_readlineb(rio_t *rp, void *usrbuf, size_t maxlen);
ssize_t rio_readnb(rio_t *rp, void *usrbuf, size_t n);
// 若成功则为读的宇节数,若EOF则为0,若出错则为—1
```

> 对这些带缓冲的函数的调用不应和无缓冲的`rio_readn`函数交叉使用。

------

RIO读程序的核心是`rio_read`函数。`rio_read`函数是**`read`函数的带缓冲的版本**。当调用`rio_read`要求读`n`个字节时，读缓冲区内有`rp->rio_cnt`个未读字节。**如果缓冲区为空**，那么会通过调用`read`再填满它。这个`read`调用会收到一个不足值，因为**读缓冲区填充了一部分**。**一旦缓冲区非空**，`rio_read`就从读缓冲区复制`n`和`rp->rio_cnt`中较小值个字节到用户缓冲区，并返回复制的字节数。

欣赏一下:

```c
static ssize_t rio_read(rio_t *rp, char *usrbuf, size_t n) 
{ 
	int cnt; 
	while (rp->rio_cnt <= 0) { /* Refill if buf is empty */
		rp->rio_cnt = read(rp->rio_fd, rp->rio_buf, 
						   sizeof(rp->rio_buf));
		if (rp->rio_cnt < 0) {
			if (errno != EINTR) /* Interrupted by sig handler return */
				return -1; 
		}
		else if (rp->rio_cnt == 0) /* EOF */
			return 0;
		else
			rp->rio_bufptr = rp->rio_buf; /* Reset buffer ptr */
	}
	
	/* Copy min(n, rp->rio_cnt) bytes from internal buf to user buf */
	cnt = n;
	if (rp->rio_cnt < n)
		cnt = rp->rio_cnt;
	memcpy(usrbuf, rp->rio_bufptr, cnt);
	rp->rio_bufptr += cnt;
	rp->rio_cnt -= cnt;
	return cnt;
}
```

## 10.6读取文件元数据

应用程序能够通过调用`stat`和`fstat`函数，检索到关于文件的信息（文件的**元数据(metadata)**）。

```c
#include <unistd.h>
#include <sys/stat.h>
int stat(const char *filename, struct stat *buf); // 接收文件名
int fstat(int fd, struct stat *buf); // 接收文件描述符
// 成功返回0,出错为-1
```

其中`stat`数据结构的定义：

```c
/* Metadata returned by the stat and fstat functions */
struct stat { 
	dev_t st_dev; /* Device */
	ino_t st_ino; /* inode */
	mode_t st_mode; /* Protection and file type */
	/*
	相关宏谓词:
	S_ISREG(m) Is simple file.
	S_ISDIR(m) Is dir file.
	S_ISSOCK(m) Is web socket.
	*/
	nlink_t st_nlink; /* Number of hard links*/
	uid_t st_uid; /* User ID of owner */
	gid_t st_gid; /* Group ID of owner*/
	dev_t st_rdev; /* Device type (if inode device)*/
	off_t st_size; /* Total size, in bytes */
	unsigned long st_blksize; /* Block size for filesystem I/O */
	unsigned long st_blocks; /* Number of blocks allocated */
	time_t st_atime; /* Time of last access */
	time_t st_mtime; /* Time of last modification */
	time_t st_ctime; /* Time of last change */
}; 
```

## 10.7读取目录内容

函数`opendir`以路径名为参数，返回指向**目录流(directory stream)**的指针。 

应用程序可以用`readdir`系列函数来读取目录的内容。

```c
#include <sys/types.h> 
#fnclude <dirent.h> 
DIR *opendir(const char *name);
// 成功则返回处理的指针,否则NULL
struct dirent *readdir(DIR *dirp);
// 成功,则返回指向下一个目录项的指针;若没有更多的目录项或出错,则为NULL,并设置errno
struct __dirstream
{   
    void *__fd;
    char *__data;
    int __entry_data;
    char *__ptr;
    int __entry_ptr;
    size_t __allocation;
    size_t __size;
    __libc_lock_define (, __lock)
};
typedef struct __dirstream DIR;
struct dirent {
    ino_t d_ino; /* inode number */
    char d_name[256]; /* Filename */
}
```

------

函数`closedir`关闭流并释放其所有的资源。

```c
#include <dirent.h> 
int closedir(DIR *dirp); 
// 成功返回0,错误返回-1
```

## 10.8共享文件

内核用三个相关的数据结构来表示打开的文件：

- **描述符表(descriptor table)**：每个进程都有它独立的描述符表，它的表项是由进程打开的文件描述符来索引的。 每个打开的描述符表项指向文件表中的一个表项。
  **人话：每一项指向文件表中的某个文件。**
- **文件表(file table)**：打开文件的集合是由一张文件表来表示的，所有的进程共享这张表。
  表项组成包括
  - **当前的文件位置**。
  - **引用计数(reference count)，（即当前指向该表项的描述符表项数）**。
  - **一个指向`v-node`表中对应表项的指针。**关闭一个描述符会减少相应的文件表表项中的引用计数。 内核不会删除这个文件表表项，直到它的引用计数为零。
- **v-node 表(v-node table)**。同文件表一样，所有的进程共享这张`v-node`表。每个表项包含`stat`结构中的大多数信息，包括`st_mode`和`st_size`成员。

![image-20250517181914154](D:\黄羽翔\大学\计算机系统基础\pictures\image-20250517181914154.png)

下面的图解释了父子进程是如何共享文件的。

![image-20250517182631961](D:\黄羽翔\大学\计算机系统基础\pictures\image-20250517182631961.png)

## 10.9I/O重定向

```bash
linux> ls > foo.txt
```

实现了将标准输出重定向到磁盘文件`foo.txt`。

------

`dup2`函数复制描述符表表项`oldfd`到描述符表表项`newfd`，覆盖描述符表表项`new fd`以前的内容。如果`newfd`已经打开了，`dup2`会在复制`oldfd`之前关闭`newfd`。

```c
#include <unistd.h>
int dup2(int oldfd, int newfd);
// 若成功则返回非负的描述符,若出错则为-1
```

例如在图`10-12`基础上调用`dup2(4,1)`，就会得到。

![image-20250517183134714](D:\黄羽翔\大学\计算机系统基础\pictures\image-20250517183134714.png)

## 10.10标准I/O

~~高程A里的东西~~。
        </textarea>
        <script>
            $m.innerHTML = marked.parse($t.value);
            window.MathJax && MathJax.typeset();
        </script>
        <div class="player" id="audioPlayer">
      <div class="d-flex justify-content-between align-items-center">
        <div class="d-flex align-items-center">
          <button class="control-button" id="previousBtn">
            <i class="fas fa-backward"></i>
          </button>
          <button class="control-button" id="playPauseBtn">
            <i class="fas fa-play"></i>
          </button>
          <button class="control-button" id="nextBtn">
            <i class="fas fa-forward"></i>
          </button>
          <span id="currentSong" class="ml-3">sasakure.UK - uzumakinoharu.mp3</span>
        </div>
      </div>
	    <div id="progressBarControl">
        <img class="music_img" src="static\img\music.ico" width="30" height="30" alt="" id="music_img"></img>
        <input id="progressBar" type="range" min="0" max="100" step="0.1" value="0"></input>
	    </div>
      <div id="volumeControl">
        <img class="volume_img" src="static\img\volume-up.svg" width="30" height="30" alt="" id="volume_img"></img>
        <input id="progressBar_volume" type="range" id="volume" min="0" max="1" step="0.01" value="1" onchange="setVolume(this.value)"></input>
      </div>
      <audio id="audio">
        <source src="./static/audio/sasakure.UK - uzumakinoharu.mp3" type="audio/mp3"></source>
        Your browser does not support the audio element.
      </audio>
    </div>
    <script src="static\js\audio.js" rel="stylesheet"></script>
    </body>
</html>