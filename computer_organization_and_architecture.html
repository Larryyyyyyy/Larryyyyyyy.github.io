<!doctype html>
<html lang="en">
    <head>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <title>Larry's garden</title>
        <link href="static\css\mainpage.css" rel="stylesheet"></link>
        <link href="static\plugins\bootstrap-5.3.3-dist\css\bootstrap.min.css" rel="stylesheet"></link>
        <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet"></link>
        <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown-dark.min.css">
        <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
        <script src="static\plugins\bootstrap-5.3.3-dist\js\bootstrap.bundle.min.js"></script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js"></script>
        <style>
            @media (max-width: 767px) { body { padding: 15px; } }
            :root {
                --bs-body-bg: #1a1a1a;
                --bs-body-color: #e0e0e0;
                --bs-card-bg: #2d2d2d;
                --bs-border-color: #444;
            }
            body { 
                box-sizing: border-box;
                margin: 0 auto;
                color: black;
            }
            .text-muted {
                color: #bbb7b7 !important;
                opacity: 0.8;
            }
            ::placeholder {
                color: #918d8d !important;
            }
            :-ms-input-placeholder {
                color: #918d8d !important; /* IE兼容 */
            }
            ::-ms-input-placeholder {
                color: #918d8d !important; /* Edge兼容 */
            }
            html, body {
                background-color: #0d1117;
                color: #c9d1d9;
            }
            .markdown-body {
                background-color: transparent;
                min-width: 200px;
                max-width: 980px;
                padding: 40px;
                position: relative;
                left: 120px;
            }
            html {
                scroll-behavior: smooth;
            }
            #toc a:hover {
                color: #c9d1d9;
                font-weight: bold;
            }
            .content {
                margin-right: 280px;
            }
            #toc a {
                color: white;
            }
            #toc a:hover {
                color: #ffc107; /* 黄色悬停高亮 */
                font-weight: bold;
            }
            #toc .list-group-item {
                background-color: #333;
                border: none;
            }
            #toc .list-group-item:hover {
                background-color: #444;
            }
            .player {
                position: fixed;
                bottom: -100px;
                left: 0;
                width: 100%;
                background-color: #333;
                padding: 15px;
                border-radius: 10px;
                transition: bottom 0.3s ease;
            }
            .player.active {
                bottom: 0;
            }
            .player .control-button {
                color: white;
                border: none;
                background: transparent;
            }
            .player .control-button:hover {
                color: #f39c12;
            }
        </style>
        <script>
            window.MathJax = {
                tex: {
                    inlineMath: [['$', '$'], ['\\(', '\\)']],
                    displayMath: [['$$', '$$'], ['\\[', '\\]']]
                },
                svg: {
                    fontCache: 'global'
                }
            };
        </script>
        <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
    </head>
    <body>
        <div class="stars"></div>
        <nav class="navbar navbar-expand-lg bg-body-tertiary" data-bs-theme="dark" style="width: -100px;">
            <div class="container-fluid">
                <a class="navbar-brand" href="#">Larry的小花园</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse justify-content-between" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a class="nav-link" aria-current="page" href="index.html">首页</a>
                        </li>
                    <li class="nav-item">
                        <a class="nav-link" href="chat.html">聊天</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle active" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">资源</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="advanced_programing.html">高等程序设计A</a></li>
                            <li><a class="dropdown-item" href="computer_basic.html">计算机系统基础</a></li>
                            <li><a class="dropdown-item" href="data_structure.html">数据结构A</a></li>
                            <li><a class="dropdown-item" href="computer_organization_and_architecture.html">计算机组成与体系结构A</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="more_resources.html">更多...</a></li>
                        </ul>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">游戏</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="pac_man.html">吃豆人</a></li>
                            <li><a class="dropdown-item" href="2048.html">2048</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="#">更多...</a></li>
                        </ul>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link disabled" aria-disabled="true"></a>
                    </li>
                    </ul>
                </div>
            </div>
        </nav>
        <form class="d-flex ms-auto" role="search">
            <input class="form-control me-2" type="search" placeholder="搜索" aria-label="search" style="position: relative; left: 150px; width: 920px;"></input>
            <button class="btn btn-outline-success me-3" type="submit" style="position: relative; left: 150px;">
			    <img src="static\img\search.png" alt="Search" style="width: 20px; height: 20px; background-color: dark;">
			</button>
        </form>
        <script>
            const form = document.querySelector("form[role='search']");
            const input = form.querySelector("input[type='search']");
            form.addEventListener("submit", function (e) {
            e.preventDefault();
            const keyword = input.value.trim().toLowerCase();
            if (!keyword) return;
            const contentBlocks = document.querySelectorAll(".markdown-body p, .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6");
            let found = false;
            contentBlocks.forEach(block => {
                if (block.textContent.toLowerCase().includes(keyword)) {
                    block.scrollIntoView({ behavior: "smooth", block: "center" });
                    block.style.backgroundColor = "#fffa90";
                    setTimeout(() => block.style.backgroundColor = "", 2000);
                    found = true;
                }
            });
            if (!found) {
                alert("没有找到匹配的内容。");
            }
        });
        </script>
        <div id="toc" class="position-fixed border rounded shadow p-3" style="top: 100px; width: 350px; max-height: 70vh; overflow-y: auto; z-index: 1000; position: relative; right: 30px;">
            <strong class="mb-2 d-block">目录</strong>
            <ul class="list-group list-group-flush" id="toc-list"></ul>
        </div>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                const tocList = document.getElementById("toc-list");
                const headers = document.querySelectorAll("h1, h2, h3");
                let index = 0;
                headers.forEach(header => {
                    if (!header.id) {
                        header.id = "heading-" + index++;
                    }
                    const li = document.createElement("li");
                    li.className = "list-group-item px-2 py-1";
                    const indent = header.tagName === "H2" ? "ms-3" :
                    header.tagName === "H3" ? "ms-5" : "";
                    li.innerHTML = `<a class="${indent} text-decoration-none" href="#${header.id}">${header.innerText}</a>`;
                    tocList.appendChild(li);
                });
            });
        </script>
        <div id="$m" class="markdown-body"></div>
        <textarea id="$t" style="display:none">
# 1.计算机抽象及相关技术 

## 1.2计算机体系结构中的8个伟大思想

### 1.2.1摩尔定律

**单芯片上所集成的晶体管资源每18-24个月翻一番**。

> 计算机架构师必须预测其设计完成时的工艺水平而不是设计开始时的工艺水平。

### 1.2.2抽象

**隐藏低层细节以提供给高层一个更简单的模型**以提高硬件和软件生产率。

### 1.2.3加速经常性事件

加速经常性事件远比优化罕见情形能够更好地优化性能。

### 1.2.4通过并行提高性能

### 1.2.5通过流水线提高性能

### 1.2.6通过预测提高性能

### 1.2.7存储层次

在存储层次中，速度最快、容量最小并且每位价格最昂贵的存储器处于顶层，而速度最慢容量最大旦每位价格最便宜的存储器处于底层。

### 1.2.8通过冗余提高可靠性

冗余组件在系统发生故障时替代失效组件并帮助检测故障。

## 1.3程序表象之下

**系统软件**：操作系统和编译器。

**高级程序语言**$\stackrel{编译器}\rightarrow$**汇编语言**$\stackrel{汇编器}\rightarrow$**机器语言**。

## 1.4箱盖后的硬件

> 组成计算机的五个经典部件是**输入、输出、存储器、数据通路(在计算机中也称运算器)和控制器**，其中后两个部件通常合称为处理器。

### 1.4.1显示器

计算机硬件采用 **光栅刷新缓冲区(又称为帧缓冲区)** 来保存位图以支持图像。要显示的图像保存在帧缓冲区中，每个像素的二进制值以刷新频率读出到显示设备。

### 1.4.2触摸屏

### 1.4.3打开机箱

- **集成电路**（**芯片**）：一种集成了几十个至上亿个晶体管的设备。
- **中央处理单元**（**CPU**)：包括**数据通路**和**控制器**。
- **数据通路**：负责完成算术运算。
- **控制器**：负责指导数据通路、存储器和I/O设备按照程序的指令正确执行。
- **内存**：程序运行时的存储空间，同时还存储程序运行时所需的数据。
- **DRAM**：动态随机访问存储器。
- **SRAM**：静态随机访问存储器。
- **高速缓存**：一种小而快的存储器，作为大而慢的存储器的缓冲。
- **计算机指令系统体系结构**：低层次软件和硬件之间的抽象接口，包含了需要编写正确运行的机器语言程序所需要的全部信息，包括指令、寄存器、存储器访问和I/O等。
- **应用二进制接口**：用户部分的指令加上应用程序员调用的操作系统接口，定义了二进制层次可移植的计算机的标准。

### 1.4.4数据安全

- **易失性存储**（主存）：类似**DRAM**，仅在加电时保存数据。
- **非易失性存储**（辅存）：掉电时仍可保持数据的存储器。
- **闪存**（flash memory）：个人移动设备中替代了**磁盘**。非易失性，比**DRAM**慢，更便宜，每位价格高于磁盘，在体积、电容、可靠性和能耗方面都更优。多次写入后可能老化或损坏。

### 1.4.5与其他计算机通信

**以太网**：最为普遍的网络类型，它连接计算机形成了**局域网**，局域网通过交换机进行连接，形成**广域网**。

## 1.5处理器和存储制造技术

| 年份 | 采用技术         | 相对性价比   |
| ---- | ---------------- | ------------ |
| 1951 | 真空管           | 1            |
| 1965 | 晶体管           | 35           |
| 1975 | 集成电路         | 900          |
| 1995 | 超大规模集成电路 | 2400000      |
| 2013 | 甚大规模集成电路 | 250000000000 |

**晶体管**：一种受电流控制的开关。

**集成电路**：由成千上万个晶体管组成的芯片。

## 1.6性能

### 1.6.1性能的定义

**响应时间（执行时间）**：从开始一个任务到该任务完成的时间。

**吞吐率（带宽）**：在给定时间内完成的任务数。

对于某个计算机$X$：

$性能_X=\frac{1}{执行时间_X}$

### 1.6.2性能的度量

**挂钟时间（响应时间、运行时间）**：完成某项任务所需的总时间。

**CPU执行时间（CPU时间）**：执行某一任务在CPU上所花费的时间。

**用户CPU时间**：程序本身所花费的CPU时间。

**系统CPU时间**：为执行程序而花费在操作系统上的时间。

$CPU执行时间=用户CPU时间+系统CPU时间。$

我们将使用**系统性能**表示空载系统的响应时间，**CPU性能**表示用户CPU时间。

**时钟周期数**：离散时间间隔。

**时钟周期**：一段时间。

**时钟频率**：时钟周期的倒数。

### 1.6.3CPU性能及其度量因素。

$程序的CPU执行时间=程序的CPU时钟周期数\times 时钟周期长度$。

$程序的CPU执行时间=\frac{程序的CPU时钟周期数}{时钟频率}$

### 1.6.4指令性能

**指令平均时钟周期数（CPI）**：执行每条指令所需的时钟周期平均数。它与计算机各种设计细节密切相关，对于不同应用程序、指令系统是不同的。

**每秒百万条指令数（MIPS）**：$MIPS=\frac{指令数}{执行时间\times 10^6}$

$CPU时钟周期数=程序的指令数\times 指令平均时钟周期数$。

### 1.6.5经典的CPU性能公式

**指令数**：程序执行所需要的指令总数。

**指令分布**：在程序中对指令的动态使用频度的评价指标。

$CPU时间=指令数\times CPI\times时钟周期长度$。

$CPU时间=\frac{指令数\times CPI}{时钟频率}$。

$CPI=\frac{CPU时钟周期数}{指令数}$。

## 1.7甄误

**在改进计算机的某个方面时期望总性能的提高与改进大小成正比**。

基于**Amdahl定律**：

$改进后的执行时间=\frac{受改进影响的执行时间}{改进量}+不受影响的执行时间$。

------

**低利用率的计算机具有更低功耗**。

由于服务器的工作负载时变化的，所以低利用率情况下的功率很重要。

------

**面向性能的设计和面向能效的设计具有不相关的目标**。

------

**用性能公式的一个子集去度量性能**。
# 2.指令:计算机的语言

我们介绍$\mathbf{RISC-V}$。

## 2.1引言

**存储程序概念**：指令与多种类型的数据不加区别地存储在存储器中并因此易于更改，因此产生了存储程序计算机。

**RISC-V操作数**

| 名字       | 示例                                                  | 注解                                                         |
| ---------- | ----------------------------------------------------- | ------------------------------------------------------------ |
| 32个寄存器 | $x_0\sim x_{31}$                                      | 快速定位数据。在RISC-V中，只对在寄存器中的数据执行算术运算   |
| $2^{61}$   | $\mathrm{Memory[0],...,Memory[18446744073709551608]}$ | 只能被数据传输指令访问。RISC-V使用字节寻址，因此顺序双字访问相差8。存储器保存数据结构、数组和换出的寄存器的内容 |

**RISC-V汇编语言**

| 类别           | 指令                   | 示例                | 含义                      | 注解                                                     |
| -------------- | ---------------------- | ------------------- | ------------------------- | -------------------------------------------------------- |
| **算术运算**   | 加                     | `add x5, x6, x7`    | `x5=x6+x7`                | 三寄存器操作数：加                                       |
|                | 减                     | `sub x5, x6, x7`    | `x5=x6-x7`                | 三寄存器操作数：减                                       |
|                | 立即数加               | `addi x5, x6, x7`   | `x5=x6+20`                | 用于加常数                                               |
| **数据传输**   | 取双字                 | `ld x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取双字到寄存器                                   |
|                | 存双字                 | `sd x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存双字到存储器                                   |
|                | 取字                   | `lw x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取字到寄存器                                     |
|                | 取字(无符号)           | `lwu x5, 40(x6)`    | `x5=Memory[x6+40]`        | 从存储器取无符号字到寄存器                               |
|                | 存字                   | `sw x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存字到存储器                                     |
|                | 取半字                 | `lh x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取半字到寄存器                                   |
|                | 取半字(无符号)         | `lhu x5, 40(x6)`    | `x5=Memory[x6+40]`        | 从存储器取无符号半字到寄存器                             |
|                | 存半字                 | `sh x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存半字到存储器                                   |
|                | 取字节                 | `lb x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取字节到寄存器                                   |
|                | 取字节(无符号)         | `lbu x5, 40(x6)`    | `Memory[x6+40]=x5`        | 从寄存器存字节到存储器                                   |
|                | 存字节                 | `sb x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存字节到存储器                                   |
|                | 取保留字               | `lr.d x5, (x6)`     | `x5=Memory[x6]`           | 取；原子交换的前半部分                                   |
|                | 存条件字               | `sc.d x7, x5, (x6)` | `Memory[x6]=x5;x7=0/1`    | 存；原子交换的后半部分                                   |
|                | 取立即数高位           | `lui x5, 0x12345`   | `x5=0x12345000`           | 取左移12位后的20位立即数                                 |
| **逻辑运算**   | 与                     | `and x5, x6, x7`    | `x5=x6&x7`                | 三寄存器操作数：按位与                                   |
|                | 或                     | `or x5, x6, x8`     | `x5=x6|x8`                | 三寄存器操作数：按位或                                   |
|                | 异或                   | `xor x5, x6, x9`    | `x5=x6^x9`                | 三寄存器操作数：按位异或                                 |
|                | 与立即数               | `andi x5, x6, 20`   | `x5=x6&20`                | 寄存器与常数按位与                                       |
|                | 或立即数               | `ori x5, x6, 20`    | `x5=x6|20`                | 寄存器与常数按位或                                       |
|                | 异或立即数             | `xori x5, x6, 20`   | `x5=x6^20`                | 寄存器与常数按位异或                                     |
| **移位操作**   | 逻辑左移               | `sll x5, x6, x7`    | `x5=x6<<x7`               | 按寄存器给定位数左移                                     |
|                | 逻辑右移               | `srl x5, x6, x7`    | `x5=x6>>x7`               | 按寄存器给定位数右移                                     |
|                | 算术右移               | `sra x5, x6, x7`    | `x5=x6>>x7`               | 按寄存器给定位数算术右移                                 |
|                | 逻辑左移立即数         | `slli x5, x6, 3`    | `x5=x6<<3`                | 根据立即数给定位数左移                                   |
|                | 逻辑右移立即数         | `srli x5, x6, 3`    | `x5=x6>>3`                | 根据立即数给定位数右移                                   |
|                | 算术右移立即数         | `srai x5, x6, 3`    | `x5=x6>>3`                | 根据立即数给定位数算术右移                               |
| **条件分支**   | 相等即跳转             | `beq x5, x6, 100`   | `if(x5==x6) go to PC+100` | 若寄存器数值相等则跳转到PC相对地址                       |
|                | 不等即跳转             | `bne x5, x6, 100`   | `if(x5!=x6) go to PC+100` | 若寄存器数值不等则跳转到PC相对地址                       |
|                | 小于即跳转             | `blt x5, x6, 100`   | `if(x5<x6) go to PC+100`  | 若寄存器数值比较结果小于则跳转到PC相对地址               |
|                | 大于等于即跳转         | `bge x5, x6, 100`   | `if(x5>=x6) go to PC+100` | 若寄存器数值比较结果大于或等于则跳转到PC相对地址         |
|                | 小于即跳转(无符号)     | `bltu x5, x6, 100`  | `if(x5<x6) go to PC+100`  | 若寄存器数值比较结果小于则跳转到PC相对地址(无符号)       |
|                | 大于等于即跳转(无符号) | `bgeu x5, x6, 100`  | `if(x5>=x6) go to PC+100` | 若寄存器数值比较结果大于或等于则跳转到PC相对地址(无符号) |
| **无条件跳转** | 跳转-链接              | `jal x1, 100`       | `x1=pc+4; go to PC+100`   | 用于PC相关的过程调用                                     |
|                | 跳转-链接(寄存器地址)  | `jalr x1, 100(x5)`  | `x1=PC+4; go to x5+100`   | 用于过程返回；非直接调用                                 |

## 2.2计算机硬件的操作

**设计原则1：简单源于规整**：操作数不可变。

## 2.3计算机硬件的操作数

**字**：访问基本单位，32位一组。

**双字**：访问基本单位，64位一组，对应RISC-V中寄存器大小。

**设计原则2：更少则更快**：数量过多的寄存器可能会增加时钟周期，因为电信号传输的距离越远，所花费的时间就越长。

### 2.3.1存储器操作数

算术运算操作只作用于寄存器，而**数据传输指令**用于内存和寄存器之间传输数据。

**基址寄存器**：存放基址的寄存器。

**结构内存分配**：编译器会将数组和结构体这样的数据结构分配到内存中的相应位置，将正确的起始地址放入数据传输指令中。

> RISC-V是小端寻址。

**对齐限制**：数据在内存中要与自然边界对齐的要求，字和双字的起始地址必须分别是4和8的倍数。但是在**RISC-V**没有对齐限制。

**寄存器换出**：编译器会尽量把最常用的变量存放在寄存器中，剩下的存放在内存中。

### 2.3.2常数或立即数操作数

**x0寄存器硬连线到常数0**。

> 尽管RISC-V寄存器为64位宽，但作者仍构思了ISA的多种变体：RV32变体就是32位宽，成本较低。

## 2.4有符号数与无符号数

**原码**：最高位为符号位的数据表示方法，例如$10000010$表示$-2$。

**补码**：一种美妙的有符号数表示方法，使得有符号数的计算可以直接进行。对于补码表示的负数$z$，其值为$z$各位取反再加$1$的相反数，例如$11111100$表示$-4$。

**符号扩展**：用符号位填充扩展的位。

## 2.5计算机中的指令表示

**指令格式**：一条汇编指令通常会被$Assembler$转化为机器指令，这个指令可以被CPU直接读取。在RISC-V中，机器指令都是32位长。

**机器语言**：为了区分汇编语言，我们将指令的数字表示为**机器语言**，这样的指令序列叫作**机器码**。

下面我们具体地介绍**RISC-V字段**：

**R型**：

| funct7 | rs2  | rs1  | funct3 | rd   | opcode |
| ------ | ---- | ---- | ------ | ---- | ------ |
| 7位    | 5位  | 5位  | 3位    | 5位  | 7位    |

- **funct7**：一个另外的操作码字段。
- **rs2**：第二个源操作数寄存器。
- **rs1**：第一个源操作数寄存器。
- **funct3**：一个另外的操作码字段。
- **rd**：目的操作数寄存器，用来存放操作结果。
- **opcode(操作码)**：指令的基本操作，这个缩写是它的惯用名称。

**I型**：

| immediate | rs1  | funct3 | rd   | opcode |
| --------- | ---- | ------ | ---- | ------ |
| 12位      | 5位  | 3位    | 5位  | 7位    |

- **immediate**：补码值。

**S型**：

| immediate[11:5] | rs2  | rs1  | funct3 | immediate[4:0] | opcode |
| --------------- | ---- | ---- | ------ | -------------- | ------ |
| 7位             | 5位  | 5位  | 3位    | 5位            | 7位    |

- 把**immediate**拆成了两部分，使得**rs**字段在相同的位置，降低硬件的复杂性。

**设计原则3：优秀的设计需要适当的折中**：设计人员保持所有的指令长度相同，对于不同的指令使用不同的指令格式。

## 2.6逻辑操作

**移位指令使用I型格式**。因为不适用于对64位寄存器移动大于63位，所以**immediate**只有低6位被使用，高6位被用作额外的操作码字段。

| fcunt6 | immediate | rs1  | funct3 | rd   | opcode |
| ------ | --------- | ---- | ------ | ---- | ------ |
| 6位    | 6位       | 5位  | 3位    | 5位  | 7位    |

> 按位取反是只有一个操作数的指令，为了保持三操作数的格式，决定用异或$-1$来实现按位取反。

## 2.7用于决策的指令

**条件分支指令**：一条指令，先检测一个值，然后根据检测结果允许后续控制流转移到程序中的一个新地址。`beq`代表**相等则分支**，`bne`代表**不等则分支**。这样带有判断和分支的指令通常称作**条件分支**指令。

> 编译器经常产生分支和标签，它们不出现在编程语言中。

### 2.7.1循环

**基本块**：一个没有分支的指令序列(除了可能在结尾处)，同时没有分支目标或分支标签(除了可能在起始处)。编译的基础工作之一就是将程序划分为基本块。

> ARM指令系统通常保留额外的位来记录指令执行期间发生的情况，这些额外的位称为**条件代码**或**标志位**。就像我们学习过的X86一样。

### 2.7.2边界检查的简便方法

我们要求下标是$0$到$n$之间的整数。显然可以通过无符号比较的方法完成这个边界检查。

### 2.7.3case/switch语句

**分支地址表(分支表)**：一种包含了不同指令序列地址的表，相当于一个双字数组，包含与代码中标签对应的地址。

RISC-V中跳转-链接指令(`jalr`)可以对寄存器中指定的地址执行无条件跳转。

## 2.8计算机硬件对过程的支持

**过程**：一个根据给定参数执行特定任务的已存储的子程序，相当于函数。

**跳转-链接指令**：跳转到某个地址的同时将下一条指令的地址保存在寄存器。(RISC-V中通常是`x1`中的指令)。

在执行过程时，通常有以下步骤：

1. 将参数放在过程可以访问到的位置。
2. 将控制转交给过程。
3. 获取过程所需的存储资源。
4. 执行所需的任务。
5. 将结果值放在调用程序可以访问到的位置。
6. 将控制返回到初始点，因为过程可以从程序中的多个点调用。

RISC-V为过程调用分配寄存器有如下约定：

- `x10` ~ `x17`：八个参数寄存器，用于传递参数或返回值。
- `x1`：一个返回地址寄存器，用于返回到起始点。

**跳转-链接指令(`jal`)**：跳转并将返回地址写入`x1`。

**程序计数器(PC)**：用来保存当前执行指令的地址。

### 2.8.1使用更多的寄存器

**栈**：被用于寄存器换出。

**栈指针**：`x2`，也叫做`sp`。

通常是向低地址**压栈**，向高地址**弹栈**。

于是又引出更多寄存器的规定：

- `x5` ~ `x7`和`x28` ~ `x31`：临时寄存器，在过程调用中不被被调用者保存。
- `x8` ~ `x9`和`x18` ~ `x27`：保存寄存器，在过程调用中必须被保存。(一旦使用，由被调用者保存并恢复)。

### 2.8.2嵌套过程

**函数调用**：

1. 调用者将所有调用后还需要的参数寄存器(`x10` ~ `x17`)或临时寄存器(`x5` ~ `x7`和`x28` ~ `x31`)压栈。
2. 被调用者将返回地址寄存器`x1`和被调用者使用的保存寄存器(`x8` ~ `x9`和`x18` ~ `x27`)压栈。
3. 调整栈指针`sp`以计算压栈寄存器的数量。返回时，从存储器中恢复寄存器并重新调整栈指针。

| 保存                               | 不保存                            |
| ---------------------------------- | --------------------------------- |
| 保存寄存器：`x8` ~ `x9`，`x18` ~ `x27` | 临时寄存器:`x5` ~ `x7`，`x28` ~ `x31` |
| 栈指针寄存器：`x2(sp)`             | 参数/结果寄存器：`x10` ~ `x17`      |
| 帧指针：`x8(fp)`                   |                                   |
| 返回地址：`x1(ra)`                 |                                   |
| 栈指针以上的栈                     | 栈指针以下的栈                    |

### 2.8.3在栈中为新数据分配空间

**过程帧(活动记录)**：栈中包含过程保存的寄存器和局部变量的段。

**帧指针**：指向给定过程的局部变量和保存的寄存器地址的值。

**过程调用之中**：帧指针(`fp`或`x8`)指向帧的第一个双字，通常是**保存的参数寄存器**，栈指针(`sp`)指向栈顶，调整栈以容纳所有**保存的寄存器**和**常驻存储器的局部变量**。

如果在过程中栈内没有局部变量，编译器将不设置和不恢复帧指针以节省时间。

当使用帧指针时，在调用中使用`sp`的地址进行初始化，且可以使用`fp`恢复`sp`。

### 2.8.4在堆中为新数据分配空间

**代码段**：UNIX目标文件的段，包含源文件中例程的机器语言代码。

**静态数据段**：用于存放常量和其他静态变量的段。

**堆**：存放数组和链表这类的数据结构的段。

堆和栈在动态数据段相向而长。

以下是寄存器约定，这个约定是**加速经常性事件**的另一个例子：

| 名称        | 寄存器号 | 用途                 | 调用时是否保存 |
| ----------- | -------- | -------------------- | -------------- |
| `x0`        | 0        | 常数0                | 不适用         |
| `x1(ra)`    | 1        | 返回赋值(链接寄存器) | 是             |
| `x2(sp)`    | 2        | 栈指针               | 是             |
| `x3(gp)`    | 3        | 全局指针             | 是             |
| `x4(tp)`    | 4        | 线程指针             | 是             |
| `x5` ~ `x7`   | 5~7      | 临时                 | 否             |
| `x8` ~ `x9`   | 8~9      | 保存                 | 是             |
| `x10` ~ `x17` | 10~17    | 参数/结果            | 否             |
| `x18` ~ `x27` | 18~27    | 保存                 | 是             |
| `x28` ~ `x31` | 28~31    | 临时                 | 否             |

## 2.9人机交互

**加载无符号字节(lbu)** 指令从内存加载一个字节，将其放在寄存器的最右边8位。

**存储字节(sb)** 指令从寄存器的最右边8位取一个字节，并将其写入内存。

**加载无符号半字(lhu)** 指令从内存中读取一个半字，将它放在寄存器的最右边16位，用零填充最左边的48位。

**存储半字(sh)** 指令从寄存器的最右边16位取半字并将其写入内存。

## 2.10对大立即数的RISC-V编址和寻址

### 2.10.1大立即数

**取立即数高位(lui)** 指令用于将20位常数加载到寄存器的第31位到第12位。将第31位的值复制填充到最左边32位，最右边的12位用0填充。

> **lui**使用新的指令格式-U型。

### 2.10.2分支中的寻址

**SB型**：这种格式可以表示从-4096到4094的偶数分支地址。

> 地址必须是偶数地址，这是因为RISC-V的地址是两字节对齐的（就像结构体中`short`类型对齐地址一样）。

| imm[12] | imm[10:5] | rs2  | rs1  | funct3 | imm[4:1] | imm[11] | opcode |
| ------- | --------- | ---- | ---- | ------ | -------- | ------- | ------ |
| 1位     | 6位       | 5位  | 5位  | 3位    | 4位      | 1位     | 7位    |

**UJ型**：只有 **无条件跳转-链接(jal)** 指令使用这种格式，同样只能跳转到偶数分支地址。

| imm[20] | imm[10:1] | imm[11] | imm[19:12] | rd   | opcode |
| ------- | --------- | ------- | ---------- | ---- | ------ |
| 1位     | 10位      | 1位     | 8位        | 5位  | 7位    |

**UJ型**寻址最多可以寻址到$2^{20}$，这是远远不够的。为此我们引入**PC相对寻址**。

**PC相对寻址**：一种寻址方式，它的地址是**PC**和指令中的常量之和。

RISC-V允许使用**双指令序列**来非常长距离地跳转到任何32位地址：

`lui`将地址的第12位至第31位写入临时寄存器，`jalr`将地址的低12位加到临时寄存器并跳转到目标位置。

### 2.10.3RISC-V寻址模式总结

1. **立即数寻址**：

   **I型指令**

   操作数是指令本身的常量。

2. **寄存器寻址**：

   **R型指令**

   操作数在寄存器中。

3. **基址寻址**：

   **I型指令**

   操作数于内存中，其地址是寄存器和指令中的常量之和。

4. **PC相对寻址**

   **S型指令**

   分支地址是PC和指令中常量之和。

### 2.10.4机器语言译码

以下是指令格式。

| 类型 | 字段            |                |              |              |               |        | 备注            |
| ---- | --------------- | -------------- | ------------ | ------------ | ------------- | ------ | --------------- |
|      | 7位             | 5位            | 5位          | 3位          | 5位           | 7位    |                 |
| R型  | funct7          | rs2            | rs1          | funct3       | rd            | opcode | 算术指令格式    |
| I型  | immediate[11:5] | immediate[4:0] | rs1          | funct3       | rd            | opcode | 加载&立即数算术 |
| S型  | immed[11:5]     | rs2            | rs1          | funct3       | immed[4:0]    | opcode | 存储            |
| SB型 | immed[12,10:5]  | rs2            | rs1          | funct3       | immed[4:1,11] | opcode | 条件分支格式    |
| UJ型 | immed[20,10:5]  | immed[4:1,11]  | immed[19:15] | immed[14:12] | rd            | opcode | 无条件跳转      |
| U型  | immed[31:25]    | immed[24:20]   | immed[19:15] | immed[14:12] | rd            | opcode | 大立即数格式    |

以下是汇编语言与机器语言的对译。

| 类型 | 指令 | opcode  | funct3 | funct7  |
| ---- | ---- | ------- | ------ | ------- |
| R型  | add  | 0110011 | 000    | 0000000 |
|      | sub  | 0110011 | 000    | 0100000 |
|      | sll  | 0110011 | 001    | 0000000 |
|      | xor  | 0110011 | 100    | 0000000 |
|      | srl  | 0110011 | 101    | 0000000 |
|      | sra  | 0110011 | 101    | 0100000 |
|      | or   | 0110011 | 110    | 0000000 |
|      | and  | 0110011 | 111    | 0000000 |
|      | lr.d | 0110011 | 011    | 0001000 |
|      | sc.d | 0110011 | 011    | 0001100 |
| I型  | lb   | 0000011 | 000    | n.a.    |
|      | lh   | 0000011 | 001    | n.a.    |
|      | lw   | 0000011 | 010    | n.a.    |
|      | ld   | 0000011 | 011    | n.a.    |
|      | lbu  | 0000011 | 100    | n.a.    |
|      | lhu  | 0000011 | 101    | n.a.    |
|      | lwu  | 0000011 | 110    | n.a.    |
|      | addi | 0010011 | 000    | n.a.    |
|      | slli | 0010011 | 001    | 0000000 |
|      | xori | 0010011 | 100    | n.a.    |
|      | srli | 0010011 | 101    | 0000000 |
|      | srai | 0010011 | 101    | 0100000 |
|      | ori  | 0010011 | 110    | n.a.    |
|      | andi | 0010011 | 111    | n.a.    |
|      | jalr | 1100111 | 000    | n.a.    |
| S型  | sb   | 0100011 | 000    | n.a.    |
|      | sh   | 0100011 | 001    | n.a.    |
|      | sw   | 0100011 | 010    | n.a.    |
|      | sd   | 0100011 | 111    | n.a.    |
| SB型 | beq  | 1100011 | 000    | n.a.    |
|      | bne  | 1100011 | 001    | n.a.    |
|      | blt  | 1100011 | 100    | n.a.    |
|      | bge  | 1100011 | 101    | n.a.    |
|      | bltu | 1100011 | 110    | n.a.    |
|      | bgeu | 1100011 | 111    | n.a.    |
| U型  | lui  | 0110111 | n.a.   | n.a.    |
| UJ型 | jal  | 1101111 | n.a.   | n.a.    |

## 2.11指令与并行性：同步

**数据竞争**：如果来自两个不同的线程的访存请求访问同一个位置，至少有一个是写，且连续出现，那么这两次存储访问形成了数据竞争。

**硬件原语**：指的是由硬件直接支持的一类**最小且不可分割的操作**，它们可以在多处理器或多线程环境下保证执行过程不会被打断。

**LR/SC**：RISC-V使用**保留加载双字（lr.d）**的特殊加载指令和**条件存储双字（sc.d）**的特殊存储指令。如果**lr**指令指定的内存位置的内容在**sc**指令执行到同一地址之前发生了变化，则**sc**指令失败且不会将值写入内存。

**sc指令**：将（可能是不同的）寄存器的值存储在内存中，如果成功则将另一个寄存器的值更改为0，如果失败则更改为非零值。

因此，**sc.d**指定了三个寄存器：第一个用于指示原子操作失败或成功，第二个用于保存地址，第三个用于如果成功则将值存储在内存中。

## 2.12翻译并启动程序

### 2.12.1编译器（Compiler）

编译器将C程序转换为机器能理解的符号形式**汇编语言程序**。

当今的优化编译器生成的汇编语言程序很优越，有时候甚至优于人工优化。

### 2.12.2汇编器（Assembler）

**伪指令**：汇编指令的一种常见变体，可以把它看作汇编语言指令。在RISC-V中是汇编器提供的真指令的简化写法。

例如伪指令`li x1, imm`，不同的`imm`可能会采取不同的真指令写法。

**符号表**：用于匹配标签名和指令所在内存的地址的表。

汇编器会跟踪分支中使用的标签和符号表中的数据传输指令。

**UNIX系统的目标文件通常包含**：

- **目标文件头**，描述了目标文件的其他部分的大小和位置。
- **代码段**，包含机器语言代码。
- **静态数据段**，包含在程序生命周期内分配的数据（UNIX允许程序使用静态数据，它在整个程序中都存在；也允许使用动态数据，它可以根据程序的需要增长或缩小。）
- **重定位信息**，标记了在程序加载到内存时依赖于绝对地址的指令和数据。
- **符号表**，包含剩余的未定义的标签，例如外部引用。
- **调试信息**，包含有关如何编译目标模块的简明描述，以便调试器可以将机器指令与源文件相关联并使数据结构可读。

### 2.12.3链接器（Linker）

**链接器**：也叫链接编辑器，是一个系统程序，它将独立汇编的机器语言程序组合起来，并解析所有未定义的标签，最终生成可执行文件。

链接器的工作有三个步骤：

1. 将代码和数据模块按符号特征放入内存。在放入内存之后必须重定位所有模块的绝对引用。
2. 决定数据和指令标签的地址。
3. 修正内部和外部引用。

链接器生成可在计算机上运行的**可执行文件**，它不包含任何未解析的引用。

### 2.12.4加载器（Loader）

1. 读取可执行文件首部以确定正文段和数据段的大小。
2. 为正文和数据创建足够大的地址空间。
3. 将可执行文件中的指令和数据复制到内存中。
4. 将主程序的参数（如果有）复制到栈顶，
5. 初始化处理器寄存器并将栈指针指向第一个空闲位置。
6. 跳转到启动例程，将参数复制到参数寄存器中并调用程序的主例程。当主例程返回时，启动例程通过exit系统调用终止程序。

**加载器**：将目标程序放在主存中以准备执行的系统程序。

### 2.12.5动态链接库

**动态链接库**：在执行期间链接到程序的库例程。

1. 第一次调用库例程时，程序调用虚入口并执行**间接跳转**。
2. 这个跳转指向一段代码，它将一个数字放入寄存器来识别所需的库例程。
3. 跳转到**动态链接器/加载器**，**动态链接器/加载器**找到所需的例程，重新映射它，并更改间接跳转位置中的地址以指向该例程。
4. 跳转到该例程。此后调用该库例程都会直接跳转到该例程。

### 2.12.6启动Java程序

**Java字节码**：为解释Java程序而设计的指令系统中的指令。

Java代码首先被编译成**Java字节码指令系统**，没有进行任何优化。

**解释器（Interpreter）**：一个模拟指令系统体系结构的程序。逐行读取源代码，解析并立即执行，而无需事先将代码转换为机器码。

**即时编译器（JIT）**：该类编译器在运行时将已解释过的代码段翻译为宿主机上的机器语言。

> Java的转换层次结构：Java程序首先被编译成Java字节码的二进制版本，所有地址都由编译器定义。Java程序现在可以在解释器上运行，称为Java虚拟机(JVM)。程序运行时，JVM链接到Java库中所需的方法。为了获得更高的性能，JVM可以调用JIT，该编译器有选择地将方法编译为运行它的机器的本地机器语言。编译过的部分将在下次运行程序时保存，以便每次运行时速度更快。

## 2.13以C排序程序为例的汇总整理

把C翻译为汇编语言时，遵循：

1. 为变量分配寄存器。
2. 为过程体生成汇编代码。
3. 保存过程调用间的寄存器。

### 2.13.1swap过程

```c
void swap(int v[], size_t k) {
	int temp;
	temp = v[k];
	v[k] = v[k + 1];
	v[k + 1] = temp;
}
```

`x5`作为临时寄存器，`x10`和`x11`作为参数寄存器。

```bash
swap:
  slli    x6, x11, 2   // reg x6 = k * 4
  add     x6, x10, x6  // reg x6 = v + k * 4
  lw      x5, 0(x6)    // reg x5 (temp) = v[k]
  lw      x7, 4(x6)    // reg x7 = v[k + 1]
  sw      x7, 0(x6)    // v[k] = reg x7
  sw      x5, 4(x6)    // v[k + 1] = reg x5 (temp)
  jalr    x0, 0(x1)    // return to calling routine
```

### 2.13.2sort过程

这里不予展示`sort`过程。

以下是编译器优化对`sort`（冒泡排序）各项性能的影响。（具体参数省略，排序个数为`n=100000`）

| gcc优化 | 相对性能 | 时钟周期（百万） | 指令数（百万） | CPI  |
| ------- | -------- | ---------------- | -------------- | ---- |
| 无优化  | 1.00     | 158615           | 114938         | 1.38 |
| O1      | 2.37     | 66990            | 37470          | 1.79 |
| O2      | 2.38     | 66521            | 39993          | 1.66 |
| O3      | 2.41     | 65747            | 44993          | 1.46 |

同一段代码在JAVA上的表现和快速排序的表现。

| 语言 | 执行模式   | 优化选项 | 冒泡排序相对性能 | 快速排序相对性能 | 快速排序与冒泡排序加速比 |
| ---- | ---------- | -------- | ---------------- | ---------------- | ------------------------ |
| C    | 编译器     | 无优化   | 1.00             | 1.00             | 2468                     |
|      | 编译器     | O1       | 2.37             | 1.50             | 1562                     |
|      | 编译器     | O2       | 2.38             | 1.50             | 1555                     |
|      | 编译器     | O3       | 2.41             | 1.91             | 1955                     |
| Java | 解释器     | ---      | 0.12             | 0.05             | 1050                     |
|      | 即时编译器 | ---      | 2.13             | 0.29             | 388                      |

## 2.14数组与指针

在一个形如实现`v.assign(n, 0)`的程序中，比较数组和指针的区别。

在不加入优化的时候，后者相比于前者有**移位替代乘法**和**消除循环内的数组地址计算**的编译优化。

## 2.16MIPS和ARM指令集

| 特征         | RISC-V                               | MIPS                             | ARM                                              |
| ------------ | ------------------------------------ | -------------------------------- | ------------------------------------------------ |
| **性质**     | **开源免费**ISA                      | **商业授权**ISA                  | **商业授权**ISA                                  |
| **设计哲学** | 模块化、可扩展、简洁                 | 经典 RISC、流水线优化            | 高能效比、广泛应用、生态成熟                     |
| **指令集**   | 模块化 (核心+标准/自定义扩展)        | 相对固定，但有不同版本           | 演进式，有不同版本 (ARMv7, ARMv8/AArch64, ARMv9) |
| **生态系统** | **快速发展中**，潜力巨大             | 相对萎缩                         | 极其庞大成熟                                     |
| **主要优势** | 灵活性、低成本、定制化、无专利壁垒   | 历史悠久，特定领域性能不错       | **市场领导者**，能效比高，生态最完善             |
| **主要应用** | 嵌入式、IoT、AI、HPC、通用计算       | 过去是路由器、消费电子；现在较少 | 移动设备、嵌入式、服务器、汽车                   |
| **商业模式** | 使用免费，可自己设计核心或使用第三方 | 购买授权                         | 购买架构/核心 IP 授权                            |

## 2.17RISC-V指令系统的剩余部分

| 名称    | 格式 | 描述                                                         |
| ------- | ---- | ------------------------------------------------------------ |
| `auipc` | U    | 立即数高20位与PC相加；将结果写到寄存器                       |
| `slt`   | R    | 比较寄存器，如果小于就设置，将布尔结果写到寄存器             |
| `sltu`  | R    | 比较寄存器，如果小于就设置（无符号），将布尔结果写到寄存器   |
| `slti`  | I    | 比较寄存器，如果小于就设置（立即数）；将布尔结果写到寄存器   |
| `sltiu` | I    | 比较寄存器，如果小于就设置（无符号立即数）；将布尔结果写到寄存器 |

下面列出了五个标准扩展：

| 助记符 | 描述          | 指令数 |
| ------ | ------------- | ------ |
| **I**  | 基本体系结构  | 51     |
| **M**  | 整数乘法/除法 | 13     |
| **A**  | 原子操作      | 22     |
| **F**  | 单精度浮点    | 30     |
| **D**  | 双精度浮点    | 32     |
| **C**  | 压缩指令      | 36     |

我们会在第三章讲述**M,F,D**三种扩展。

**A**扩展包括`lr.d`，`sc.d`以及它们的32位版本`lr.w`，`sc.w`。剩余18条指令是常见同步模式的优化。

**C**扩展会缩短指令位数以对于部分操作提高性能。

## 2.22谬误与陷阱

**谬误：更强大的指令意味着更高的性能**

**谬误：用汇编语言编程以获得最高性能**

**谬误：商用计算机二进制兼容的重要性意味着成功的指令系统无需改变**

**陷阱：忘记在字节寻址的机器中，连续的字地址相差不为1**

**陷阱：在变量的定义过程外，使用一个指针指向该变量**

# 3.计算机的算术运算 

## 3.1引言

本章涉及**表示小数和其它实数**，**表示特大数**，**硬件真正实现乘除法**。

## 3.2加法和减法

加法就是传统的逐位相加进位。

减法：取反再加法操作。

**溢出**：

- 有符号数：当两个操作数：同号$\land$之和与原操作数异号$\Rightarrow$溢出
- 无符号数：
  - 加法：总和小于加数中的任何一个$\Rightarrow$溢出
  - 减法：差大于被减数$\Rightarrow$溢出

> **饱和**：当计算溢出时，自动设置为极大值或极小值。这可能会出现在多媒体设备。

> **加法速度**：加法的速度取决于向高位进位的计算速度。这里介绍**超前进位加法器**：
>
> - **进位产生**：$G_i=A_i⋅B_i$ (当$A_i$和 $B_i$都是$1$时，本位产生进位)
>
> - **进位传递**：$P_i=A_i⊕B_i$ (当$A_i$和$B_i$相异时，本位将前一级的进位传递过来)
>
> 利用这两个信号，任何一位的进位输入$C_{i+1}$ 都可以用逻辑表达式表示，而无需等待前一级的进位计算结果。例如：
>
> $C_1=G_0+P_0⋅C_0$
>
> $C_2=G_1+P_1⋅C_1=G_1+P_1⋅(G_0+P_0⋅C_0)$

## 3.3乘法

### 3.3.1串行版的乘法算法及其硬件实现

<img src=".\pictures\image-20250925100703653.png">

<img src=".\pictures\image-20250925100914102.png">

<img src=".\pictures\image-20250925101411096.png">

### 3.3.2带符号乘法

独立处理符号位即可。

事实上，**直接**使用补码形式的数，再迭代执行移位和加法，**每次右移时进行符号扩展（对于负数进行算术右移）**。

### 3.3.3快速乘法

可以为每个乘数位提供一个32位加法器：一个输入是被乘数和一个乘数位相与的结果，另一个输入是上一个加法器的输出。

- 用64个32位加法器形成一个高64位的加法器栈。

- 第二种是

<img src=".\pictures\image-20250925105036839.png">

由于使用**进位保留加法器**，乘法速度比5次加法还快。

> 进位保留加法器：
>
> `input(A, B, C)`
>
> `output(sum, carry)`
>
> 公式上：$A+B+C=\text{sum}+\text{carry<<1}$
>
> 分开计算`sum`和`carry`，从而各位都能并行计算。

### 3.3.4RISC-V中的乘法

RISC-V中有四条乘法指令：

- `mul`：乘。
- `mulh`：乘法取高位。
- `mulhu`：无符号乘法取高位。
- `mulhsu`：有符号同无符号乘法取高位。

## 3.4除法

### 3.4.1除法算法及其硬件实现

<img src="./pictures/image-20250925110559938.png">

<img src="./pictures/image-20250925110642133.png">

<img src="./pictures/image-20250925112533800.png">

### 3.4.2有符号除法

单独处理符号位。

### 3.4.3快速除法

**SRT除法**：根据被除数和余数的高位来查找表，以预测每步的多个商的位数。

### 3.4.4RISC-V中的除法

RISC-V中有四条除法指令：

- `div`：除。
- `divu`：无符号除。
- `rem`：余数。
- `remu`：无符号余数。

### 3.4.5总结

下表相比上一章表格基础上给出了**RISC-V**体系结构的优化处理。



| 类别           | 指令                     | 示例                | 含义                      | 注解                                                     |
| -------------- | ------------------------ | ------------------- | ------------------------- | -------------------------------------------------------- |
| **算术运算**   | 加                       | `add x5, x6, x7`    | `x5=x6+x7`                | 三寄存器操作数：加                                       |
|                | 减                       | `sub x5, x6, x7`    | `x5=x6-x7`                | 三寄存器操作数：减                                       |
|                | 立即数加                 | `addi x5, x6, 20`   | `x5=x6+20`                | 用于加常数                                               |
|                | 小于置位                 | `slt x5, x6, x7`    | `x5=1 if x6<x7, else 0`   | 两个寄存器比较                                           |
|                | 小于置位（无符号数）     | `sltu x5, x6, x7`   | `x5=1 if x6<x7, else 0`   | 两个寄存器比较                                           |
|                | 小于置位（立即数）       | `slti x5, x6, 20`   | `x5=1 if x6<20, else 0`   | 与立即数比较                                             |
|                | 小于置位（无符号立即数） | `sltiu x5, x6, 20`  | `x5=1 if x6<20, else 0`   | 与立即数比较                                             |
|                | 乘                       | `mul x5, x6, x7`    | `x5=x6*x7`                | 64位乘积的低32位                                         |
|                | 高位乘                   | `mulh x5, x6, x7`   | `x5=(x6*x7)>>32`          | 64位有符号乘积的高32位                                   |
|                | 高位乘（无符号数）       | `mulhu x5, x6, x7`  | `x5=(x6*x7)>>32`          | 64位无符号乘积的高32位                                   |
|                | 高位乘（有-无符号数）    | `mulhsu x5, x6, x7` | `x5=(x6*x7)>>32`          | 64位有-无符号乘积的高32位                                |
|                | 除                       | `div x5, x6, x7`    | `x5=x6/x7`                | 除有符号32位数字                                         |
|                | 无符号除                 | `divu x5, x6, x7`   | `x5=x6/x7`                | 除无符号32位数字                                         |
|                | 取余                     | `rem x5, x6, x7`    | `x5=x6%x7`                | 对有符号32位除法取余                                     |
|                | 无符号取余               | `remu x5, x6, x7`   | `x5=x6%x7`                | 对无符号32位除法取余                                     |
| **数据传输**   | 取双字                   | `ld x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取双字到寄存器                                   |
|                | 存双字                   | `sd x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存双字到存储器                                   |
|                | 取字                     | `lw x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取字到寄存器                                     |
|                | 取字(无符号)             | `lwu x5, 40(x6)`    | `x5=Memory[x6+40]`        | 从存储器取无符号字到寄存器                               |
|                | 存字                     | `sw x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存字到存储器                                     |
|                | 取半字                   | `lh x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取半字到寄存器                                   |
|                | 取半字(无符号)           | `lhu x5, 40(x6)`    | `x5=Memory[x6+40]`        | 从存储器取无符号半字到寄存器                             |
|                | 存半字                   | `sh x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存半字到存储器                                   |
|                | 取字节                   | `lb x5, 40(x6)`     | `x5=Memory[x6+40]`        | 从存储器取字节到寄存器                                   |
|                | 取字节(无符号)           | `lbu x5, 40(x6)`    | `Memory[x6+40]=x5`        | 从寄存器存字节到存储器                                   |
|                | 存字节                   | `sb x5, 40(x6)`     | `Memory[x6+40]=x5`        | 从寄存器存字节到存储器                                   |
|                | 取保留字                 | `lr.d x5, (x6)`     | `x5=Memory[x6]`           | 取；原子交换的前半部分                                   |
|                | 存条件字                 | `sc.d x7, x5, (x6)` | `Memory[x6]=x5;x7=0/1`    | 存；原子交换的后半部分                                   |
|                | 取立即数高位             | `lui x5, 0x12345`   | `x5=0x12345000`           | 取左移12位后的20位立即数                                 |
|                | 加立即数高位到`PC`       | `auipc x5, 0x12345` | `x5=PC+0x12345000`        | 用作程序计数器相对寻址                                   |
| **逻辑运算**   | 与                       | `and x5, x6, x7`    | `x5=x6&x7`                | 三寄存器操作数：按位与                                   |
|                | 或                       | `or x5, x6, x8`     | `x5=x6|x8`                | 三寄存器操作数：按位或                                   |
|                | 异或                     | `xor x5, x6, x9`    | `x5=x6^x9`                | 三寄存器操作数：按位异或                                 |
|                | 与立即数                 | `andi x5, x6, 20`   | `x5=x6&20`                | 寄存器与常数按位与                                       |
|                | 或立即数                 | `ori x5, x6, 20`    | `x5=x6|20`                | 寄存器与常数按位或                                       |
|                | 异或立即数               | `xori x5, x6, 20`   | `x5=x6^20`                | 寄存器与常数按位异或                                     |
| **移位操作**   | 逻辑左移                 | `sll x5, x6, x7`    | `x5=x6<<x7`               | 按寄存器给定位数左移                                     |
|                | 逻辑右移                 | `srl x5, x6, x7`    | `x5=x6>>x7`               | 按寄存器给定位数右移                                     |
|                | 算术右移                 | `sra x5, x6, x7`    | `x5=x6>>x7`               | 按寄存器给定位数算术右移                                 |
|                | 逻辑左移立即数           | `slli x5, x6, 3`    | `x5=x6<<3`                | 根据立即数给定位数左移                                   |
|                | 逻辑右移立即数           | `srli x5, x6, 3`    | `x5=x6>>3`                | 根据立即数给定位数右移                                   |
|                | 算术右移立即数           | `srai x5, x6, 3`    | `x5=x6>>3`                | 根据立即数给定位数算术右移                               |
| **条件分支**   | 相等即跳转               | `beq x5, x6, 100`   | `if(x5==x6) go to PC+100` | 若寄存器数值相等则跳转到PC相对地址                       |
|                | 不等即跳转               | `bne x5, x6, 100`   | `if(x5!=x6) go to PC+100` | 若寄存器数值不等则跳转到PC相对地址                       |
|                | 小于即跳转               | `blt x5, x6, 100`   | `if(x5<x6) go to PC+100`  | 若寄存器数值比较结果小于则跳转到PC相对地址               |
|                | 大于等于即跳转           | `bge x5, x6, 100`   | `if(x5>=x6) go to PC+100` | 若寄存器数值比较结果大于或等于则跳转到PC相对地址         |
|                | 小于即跳转(无符号)       | `bltu x5, x6, 100`  | `if(x5<x6) go to PC+100`  | 若寄存器数值比较结果小于则跳转到PC相对地址(无符号)       |
|                | 大于等于即跳转(无符号)   | `bgeu x5, x6, 100`  | `if(x5>=x6) go to PC+100` | 若寄存器数值比较结果大于或等于则跳转到PC相对地址(无符号) |
| **无条件跳转** | 跳转-链接                | `jal x1, 100`       | `x1=pc+4; go to PC+100`   | 用于PC相关的过程调用                                     |
|                | 跳转-链接(寄存器地址)    | `jalr x1, 100(x5)`  | `x1=PC+4; go to x5+100`   | 用于过程返回；非直接调用                                 |

> **RISC-V除法**中有两种异常要求软件进行判断：
>
> 1. 除法溢出。
> 2. 除数为0。

## 3.5浮点运算

> **规格化**：没有前导0的浮点表示法。

> **浮点**：二进制小数点不固定的数的计算机表示。

支持浮点数的计算机运算称为**浮点**运算。

### 3.5.1浮点表示

> **尾数**：该值通常在0和1之间，放置在尾数字段中。

> **指数**：在浮点运算的数值表示系统中，放置在指数字段中的值。

于是乎我们有上学期就了解到的熟悉的单/双精度浮点表示。（来自IEEE754标准）

> **上/下溢出**：正/负指数太大而无法用指数字段表示的情况。

单精度的表示范围$2.0\times10^{-38}\sim2.0\times10^{38}$。

双精度的表示范围$2.0\times10^{-308}\sim2.0\times10^{308}$。

### 3.5.2例外和中断

> **例外**：也叫中断。打扰程序执行的意外事件；用于检测溢出。
>
> **中断**：来自处理器之外的例外。

有些计算机会通过**例外**告知问题的出现。

造成溢出的指令的地址会被保留在寄存器，然后计算机跳转到预定义的地址以调用相应的例外处理程序。中断的地址被保存下来，以便处理完后继续执行程序。

**RISC-V**不会在溢出引发例外。软件可以通过 **浮点控制** 和 **状态寄存器(fscr)** 来检测是否溢出。

### 3.5.3IEEE754浮点数标准

[Larry's garden](http://larryyyyyyy.me/computer_basic.html#heading-0)

### 3.5.4浮点加法

1. 将**较小数**的有效数位进行右移，直到它的指数与**较大数**的指数相等。
2. 有效数位相加。
3. 调整**指数**，把它变为规格化的形式。这一步需要检测上溢。
4. **舍入**。如果这个结果不是规格化数，重新进行上一步。

<img src="./pictures/image-20250928200613724.png">

### 3.5.5浮点乘法

1. 指数相加。这里要以移码表示指数，两个指数相加后减去一个偏移值。

   > **移码**：对于$n$位字段，偏移量$offset=2^{n-1}$移码就是原来的数加上$offset$。

2. 有效数位相乘。

3. 调整**指数**，把它变为规格化的形式。这一步需要检测上溢和下溢。

4. **舍入**。如果这个结果不是规格化数，重新进行上一步。

5. 根据操作数的符号确定结果的符号。

<img src="./pictures/image-20250930184251036.png">

### 3.5.6RISC-V中的浮点指令

> [!NOTE]
>
> 浮点数据传输指令的基址寄存器仍为整点寄存器。
>
> 浮点寄存器`f0`不像`x0`硬连接0。
>
> 载入指令使用`I`型指令，存储指令使用`S`型指令，算术指令使用`R`型指令。

| 名称             | 示例                                        | 注解                                                         |
| ---------------- | ------------------------------------------- | ------------------------------------------------------------ |
| 32个浮点寄存器   | `f0`~`f31`                                  | 一个`f`寄存器可以保存一个单精度浮点数或一个双精度浮点数      |
| $2^{30}$个存储字 | `Memory[0], Memory[4],…,Memory[4294967292]` | 只能被数据传输指令访问。RISC-V使用字节地址，因此顺序字相差4。存储器保存数据结构、数组和换出的寄存器的内容 |

| 类别         | 指令                 | 示例                | 含义                       | 注解                               |
| ------------ | -------------------- | ------------------- | -------------------------- | ---------------------------------- |
| **算术**     | 单精度浮点加法       | `fadd.s f0, f1, f2` | `f0=f1+f2`                 | （单精度）浮点数加法               |
|              | 单精度浮点减法       | `fsub.s f0, f1, f2` | `f0=f1-f2`                 | （单精度）浮点数减法               |
|              | 单精度浮点乘法       | `fmul.s f0, f1, f2` | `f0=f1*f2`                 | （单精度）浮点数乘法               |
|              | 单精度浮点除法       | `fdiv.s f0, f1, f2` | `f0=f1/f2`                 | （单精度）浮点数除法               |
|              | 单精度浮点平方根     | `fsqrt.s f0, f1`    | `f0=sqrt(f1)`              | （单精度）浮点数平方根             |
|              | 双精度浮点加法       | `fadd.d f0, f1, f2` | `f0=f1+f2`                 | （双精度）浮点数加法               |
|              | 双精度浮点减法       | `fsub.d f0, f1, f2` | `f0=f1-f2`                 | （双精度）浮点数减法               |
|              | 双精度浮点乘法       | `fmul.d f0, f1, f2` | `f0=f1*f2`                 | （双精度）浮点数乘法               |
|              | 双精度浮点除法       | `fdiv.d f0, f1, f2` | `f0=f1/f2`                 | （双精度）浮点数除法               |
|              | 双精度浮点平方根     | `fsqrt.d f0, f1`    | `f0=sqrt(f1)`              | （双精度）浮点数平方根             |
| **比较**     | 单精度浮点相等       | `feq.s x5, f0, f1`  | `x5=1 if f0 == f1, else 0` | （单精度）浮点数比较               |
|              | 单精度浮点小于       | `fit.s x5, f0, f1`  | `x5=1 if f0 < f1, else 0`  | （单精度）浮点数比较               |
|              | 单精度浮点小于或等于 | `fle.s x5, f0, f1`  | `x5=1 if f0 <= f1, else 0` | （单精度）浮点数比较               |
|              | 双精度浮点相等       | `feq.d x5, f0, f1`  | `x5=1 if f0 == f1, else 0` | （双精度）浮点数比较               |
|              | 双精度浮点小于       | `fit.d x5, f0, f1`  | `x5=1 if f0 < f1, else 0`  | （双精度）浮点数比较               |
|              | 双精度浮点小于或等于 | `fle.d x5, f0, f1`  | `x5=1 if f0 <= f1, else 0` | （双精度）浮点数比较               |
| **数据传输** | 浮点取字             | `flw f0, 4(x5)`     | `f0=Memory[x5+4]`          | 从内存中取单精度字到浮点寄存器     |
|              | 浮点取双字           | `fld f0, 8(x5)`     | `f0=Memory[x5+8]`          | 从内存中取双精度字到浮点寄存器     |
|              | 浮点存字             | `fsw f0, 4(x5)`     | `Memory[x5+4]=f0`          | 将浮点寄存器中的单精度字存储到内存 |
|              | 浮点存双字           | `fsd f0, 8(x5)`     | `Memory[x5+8]=f0`          | 将浮点寄存器中的双精度字存储到内存 |

### 3.5.7精确算术

显然双精度浮点数能精确表示的最多只有$2^{53}$个数，我们不可能精确地表示每个实数。IEEE754在中间计算时，总是在右边保留两个额外的位，分别是**保护位**和**舍入位**。

> **保护位**：在浮点运算的中间计算中，保留在右侧的两个额外位的第一位，用于提高舍入精度。

> **舍入位**：使中间结果符合浮点格式的方法，目标通常是找到符合格式的最接近的数。它也是在浮点运算的中间运算中保留在右侧的两个额外位的第二位，可以提高舍入精度。

以浮点加法为例：**保护位**和**舍入位**会在有效位数右移的时候充当占位，减少可能被丢掉的位。

> **最后位置单位**：用于表示在实际数和可表示数之间的有效位数中最低有效位上的误差位数。

浮点的精度通常以有效数位中最低有效位的错误位数来衡量，这种衡量方式称为**最后位置单位的数目**，即**ulp**。

在没有**上溢**、**下溢**或**无效操作**引发例外的情况下，IEEE754标准保证计算机使用的数的误差在半个**ulp**以内。

---

乘法可能需要两个额外位。因为二进制积可能有一个前导0，因此，规格化时必须将积左移一位。这就将保护位转换为积的最低有效位，留下舍入位来帮助进行精确舍入。

### 3.5.8总结

**无序比较**：设计`NaN`的比较。

RISC-V不提供无序比较的指令，但经过设计的有序比较序列具有相同的效果。

具体为：**比较的其中一个数涉及`NaN`，会将标记寄存器设为0**。

## 3.6并行性与计算机算术：子字并行

**子字并行**：通过在128位加法器内划分进位链，处理器可以同时对16个8位操作数、8个16位操作数、4个32位操作数、2个64位操作数的短向量进行并行操作。

## 3.7x86中的SIMD扩展和高级向量扩展

x86的原始 **MMX（MultiMedia eXtension,多媒体扩展）** 包含操作整数短向量的指令。

而后， **SSE（StreamingSIMDExtension，流式SIMD扩展）** 提供了操作单精度浮点数短向量的指令。

2011年，Intel使用**高级向量扩展（Advanced Vector Extensions，AVX）**将寄存器的位宽再次翻倍，现称为**YMM**。

2015年，英特尔将寄存器扩展至512位，现在称为**ZIMM**，在某些微处理器中使用了**AVX512**。英特尔已官布计划在x86架构的最新版本中将AVX寄存器扩展到1024位。

## 3.9谬误与陷阱

**谬误：正如左移指令可以代替一个乘以2的幂的整数，右移等同于除以一个2的幂的整数**

**陷阱：浮点加法不满足结合律**

**谬误：适用于整型数据类型的并行执行策略也适用于浮点数据类型**

**谬误：只有理论数学家关心浮点精度**
        </textarea>
        <script>
            $m.innerHTML = marked.parse($t.value);
            window.MathJax && MathJax.typeset();
        </script>
        <!-- 评论展示容器 -->
         <div class="container" style="max-width: 900px; padding: 20px; transform: translateX(-150px);">
            <div id="comments-container"></div>
            <!-- 评论输入框 -->
            <div class="card mb-4">
                <div class="card-body">
                    <h5 class="card-title">发表评论</h5>
                    <form id="comment-form">
                        <input type="text" id="comment-username" class="form-control mb-2" placeholder="您的昵称" required></input>
                        <div class="mb-3">
                            <textarea id="comment-text" class="form-control" rows="3" placeholder="写下您的评论..." required></textarea>
                        </div>
                        <button type="submit" class="btn btn-secondary me-2">发送</button>
                    </form>
                </div>
            </div>
            <!-- 引入 Supabase -->
            <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
            <script>
                const SUPABASE_URL = 'https://iuywungpuuxkdjlnkhge.supabase.co';
                const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml1eXd1bmdwdXV4a2RqbG5raGdlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg4NzMwNjAsImV4cCI6MjA2NDQ0OTA2MH0.m7Sm50pXOYFB9vgHz0XlBhzu75HvT7kLX64UUD6C6Ts';
                const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                // 提交评论
                document.getElementById('comment-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const text = document.getElementById('comment-text').value.trim();
                    const username = document.getElementById('comment-username').value.trim();
                    if (!text || !username) return;
                    const { error } = await supabaseClient
                    .from('Comments')
                    .insert([{ username, message: text, page: 'data_structure'}]);
                    if (error) {
                        alert('提交失败！');
                        console.error(error);
                    }
                    else {
                        document.getElementById('comment-form').reset();
                        loadComments();
                    }
                });
                // 加载评论并展示
                async function loadComments() {
                    const { data, error } = await supabaseClient
                    .from('Comments')
                    .select('*')
                    .order('created_at', { ascending: false });
                    if (error) return console.error('加载失败', error);
                    const container = document.getElementById('comments-container');
                    container.innerHTML = '';
                    data.forEach(({ username, message, created_at, page}) => {
                        const date = new Date(created_at)
                        const timeAgo = new Date(date.getTime() + 8 * 60 * 60 * 1000).toLocaleString(); // 北京时间
                        const rand = Math.floor(Math.random() * 21) + 1;
                        const commentHtml = `
                        <div class="card mb-4 rounded-3 shadow-sm">
                            <div class="card-body d-flex">
                                <img src="./static/img/${rand}.jpg" class="rounded-circle me-3" width="40" height="40" alt="用户头像">
                                <div>
                                    <h6 class="mb-1">${username} <small class="text-muted">· ${timeAgo}</small></h6>
                                    <p class="mb-1">${message}</p>
                                </div>
                            </div>
                        </div>
                    `;
                    if (page == 'data_structure') container.innerHTML += commentHtml;
                    });
                }
                // 初次加载
                loadComments();
            </script>
        </div>
        <br></br>
        <br></br>
        <div class="player" id="audioPlayer">
      <div class="d-flex justify-content-between align-items-center">
        <div class="d-flex align-items-center">
          <button class="control-button" id="previousBtn">
            <i class="fas fa-backward"></i>
          </button>
          <button class="control-button" id="playPauseBtn">
            <i class="fas fa-play"></i>
          </button>
          <button class="control-button" id="nextBtn">
            <i class="fas fa-forward"></i>
          </button>
          <span id="currentSong" class="ml-3">sasakure.UK - uzumakinoharu.mp3</span>
        </div>
      </div>
	    <div id="progressBarControl">
        <img class="music_img" src="static\img\music.ico" width="30" height="30" alt="" id="music_img"></img>
        <input id="progressBar" type="range" min="0" max="100" step="0.1" value="0"></input>
	    </div>
      <div id="volumeControl">
        <img class="volume_img" src="static\img\volume-up.svg" width="30" height="30" alt="" id="volume_img"></img>
        <input id="progressBar_volume" type="range" id="volume" min="0" max="1" step="0.01" value="1" onchange="setVolume(this.value)"></input>
      </div>
      <audio id="audio">
        <source src="./static/audio/sasakure.UK - uzumakinoharu.mp3" type="audio/mp3"></source>
        Your browser does not support the audio element.
      </audio>
    </div>
    <script src="static\js\audio.js" rel="stylesheet"></script>
    </body>
</html>
