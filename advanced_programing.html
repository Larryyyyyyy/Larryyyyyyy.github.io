<!doctype html>
<html lang="en">
    <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Larry's garden</title>
	<link href="static\css\mainpage.css" rel="stylesheet"></link>
    <link href="static\plugins\bootstrap-5.3.3-dist\css\bootstrap.min.css" rel="stylesheet"></link>
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/all.min.css" rel="stylesheet"></link>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/github-markdown-css/5.1.0/github-markdown-dark.min.css">
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
	<script src="static\plugins\bootstrap-5.3.3-dist\js\bootstrap.bundle.min.js"></script>
    <style>
        @media (max-width: 767px) { body { padding: 15px; } }
        :root {
            --bs-body-bg: #1a1a1a;
            --bs-body-color: #e0e0e0;
            --bs-card-bg: #2d2d2d;
            --bs-border-color: #444;
        }
        body { 
            box-sizing: border-box;
            margin: 0 auto;
            color: black;
        }
        .text-muted {
            color: #bbb7b7 !important;
            opacity: 0.8;
        }
        ::placeholder {
            color: #918d8d !important;
        }
        :-ms-input-placeholder {
            color: #918d8d !important; /* IE兼容 */
        }
        ::-ms-input-placeholder {
            color: #918d8d !important; /* Edge兼容 */
        }
        html, body {
            background-color: #0d1117;
            color: #c9d1d9;
        }
        .markdown-body {
            background-color: transparent;
            min-width: 200px;
            max-width: 980px;
            padding: 40px;
            position: relative;
            left: 120px;
        }
        html {
            scroll-behavior: smooth;
        }
        #toc a:hover {
            color: #c9d1d9;
            font-weight: bold;
        }
        .content {
            margin-right: 280px;
        }
        #toc a {
            color: white;
        }
        #toc a:hover {
            color: #ffc107; /* 黄色悬停高亮 */
            font-weight: bold;
        }
        #toc .list-group-item {
            background-color: #333;
            border: none;
        }
        #toc .list-group-item:hover {
            background-color: #444;
        }
        .player {
            position: fixed;
            bottom: -100px;
            left: 0;
            width: 100%;
            background-color: #333;
            padding: 15px;
            border-radius: 10px;
            transition: bottom 0.3s ease;
        }
        .player.active {
            bottom: 0;
        }
        .player .control-button {
            color: white;
            border: none;
            background: transparent;
        }
        .player .control-button:hover {
            color: #f39c12;
        }
    </style>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']]
            },
            svg: {
                fontCache: 'global'
            }
        };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-svg.js" async></script>
    </head>
    <body>
        <div class="stars"></div>
        <nav class="navbar navbar-expand-lg bg-body-tertiary" data-bs-theme="dark" style="width: -100px;">
            <div class="container-fluid">
                <a class="navbar-brand" href="#">Larry的小花园</a>
                <button class="navbar-toggler" type="button" data-bs-toggle="collapse" data-bs-target="#navbarSupportedContent" aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
                    <span class="navbar-toggler-icon"></span>
                </button>
                <div class="collapse navbar-collapse justify-content-between" id="navbarSupportedContent">
                    <ul class="navbar-nav me-auto mb-2 mb-lg-0">
                        <li class="nav-item">
                            <a class="nav-link" aria-current="page" href="index.html">首页</a>
                        </li>
                    <li class="nav-item">
                        <a class="nav-link" href="chat.html">聊天</a>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle active" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">资源</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="advanced_programing.html">高等程序设计A</a></li>
                            <li><a class="dropdown-item" href="computer_basic.html">计算机系统基础</a></li>
                            <li><a class="dropdown-item" href="data_structure.html">数据结构A</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="more_resources.html">更多...</a></li>
                        </ul>
                    </li>
                    <li class="nav-item dropdown">
                        <a class="nav-link dropdown-toggle" href="#" role="button" data-bs-toggle="dropdown" aria-expanded="false">游戏</a>
                        <ul class="dropdown-menu">
                            <li><a class="dropdown-item" href="pac_man.html">吃豆人</a></li>
                            <li><a class="dropdown-item" href="2048.html">2048</a></li>
                            <li><hr class="dropdown-divider"></li>
                            <li><a class="dropdown-item" href="#">更多...</a></li>
                        </ul>
                    </li>
                    <li class="nav-item">
                        <a class="nav-link disabled" aria-disabled="true"></a>
                    </li>
                    </ul>
                </div>
            </div>
        </nav>
        <form class="d-flex ms-auto" role="search">
            <input class="form-control me-2" type="search" placeholder="搜索" aria-label="search" style="position: relative; left: 150px; width: 920px;"></input>
            <button class="btn btn-outline-success me-3" type="submit" style="position: relative; left: 150px;">
			    <img src="static\img\search.png" alt="Search" style="width: 20px; height: 20px; background-color: dark;">
			</button>
        </form>
        <script>
            const form = document.querySelector("form[role='search']");
            const input = form.querySelector("input[type='search']");
            form.addEventListener("submit", function (e) {
            e.preventDefault();
            const keyword = input.value.trim().toLowerCase();
            if (!keyword) return;
            const contentBlocks = document.querySelectorAll(".markdown-body p, .markdown-body h1, .markdown-body h2, .markdown-body h3, .markdown-body h4, .markdown-body h5, .markdown-body h6");
            let found = false;
            contentBlocks.forEach(block => {
                if (block.textContent.toLowerCase().includes(keyword)) {
                    block.scrollIntoView({ behavior: "smooth", block: "center" });
                    block.style.backgroundColor = "#fffa90";
                    setTimeout(() => block.style.backgroundColor = "", 2000);
                    found = true;
                }
            });
            if (!found) {
                alert("没有找到匹配的内容。");
            }
        });
        </script>
        <div id="toc" class="position-fixed border rounded shadow p-3" style="top: 100px; width: 350px; max-height: 70vh; overflow-y: auto; z-index: 1000; position: relative; right: 30px;">
            <strong class="mb-2 d-block">目录</strong>
            <ul class="list-group list-group-flush" id="toc-list"></ul>
        </div>
        <script>
            document.addEventListener("DOMContentLoaded", function () {
                const tocList = document.getElementById("toc-list");
                const headers = document.querySelectorAll("h1, h2, h3");
                let index = 0;
                headers.forEach(header => {
                    if (!header.id) {
                        header.id = "heading-" + index++;
                    }
                    const li = document.createElement("li");
                    li.className = "list-group-item px-2 py-1";
                    const indent = header.tagName === "H2" ? "ms-3" :
                    header.tagName === "H3" ? "ms-5" : "";
                    li.innerHTML = `<a class="${indent} text-decoration-none" href="#${header.id}">${header.innerText}</a>`;
                    tocList.appendChild(li);
                });
            });
        </script>
        <div id="$m" class="markdown-body"></div>
        <textarea id="$t" style="display:none">
# 第四章-类与对象

## 面向对象程序设计的基本特点

### 抽象

数据抽象: 描述某类对象的属性或状态。

```C++
string name,birth_date;
```

行为抽象: 描述某类对象的共同行为和功能特征。

```C++
map<int,string> nameList;//map是一种实现映射的stl数据结构，底层是红黑树，非常强大
map<string,string> birthDatelist;
string getname(int num){
    return nameList[num];
}
string getbirth_date(string name){
    return birthDatelist[name];
}
```

### 封装

将抽象得到的数据或行为相结合，形成一个有机的整体。

```C++
class point{
private:
    int x,y;
public:
    point(int x,int y):x(x),y(y){}//构造函数
    point(const point& p):x(p.x),y(p.y){}//委托构造函数
    ~point(){}//析构函数
};
```

### 继承

C++语言提供了类的继承机制，允许在保持原有类特性的基础上，进行更具体、更详细的说明。

```C++
class point{
private:
    int x,y;
public:
    point(int x,int y):x(x),y(y){}
    point(const point& p):x(p.x),y(p.y){}
    ~point(){}
    int getx(){return x;}
    int gety(){return y;}
    int definex(int pos){x=pos;}
};
class line :public point{
private:
    int x1,y1,x2,y2;
public:
    //如果不定义构造函数，c++会内置初始构造函数(包括析构函数)
    //但point类中定义了构造函数，这里不会内置默认构造函数
    //可见line类继承了point类的部分特性
    line(int a,int b,int c,int d):point(a,b),x1(a),y1(b),x2(c),y2(d){}
}
int main(){
    line x(1,1,4,5);
    cout<<x.getx()<<endl;//可以调用point类中public的函数,这个会在后面详细介绍
    x.define(114514);
    cout<<x.getx();//输出114514
    return 0;
}
```

### 多态

一段程序能够处理多种类型对象的能力。可以通过强制多态、重载多态、类型参数化多态、包含多态 4 种形式来实现。

## 类和对象

### 类的定义

```C++
class Clock{
public:
    //公有成员
    //外部只能访问类的公有成员
private:
    //私有成员
    //私有成员只能被本类的成员函数访问
    //不能被类外部访问
protected:
    //保护成员
    //与私有成员的区别在于:相比私有成员还可以被派生类访问
};
```

习惯: 一般将数据成员设为私有成员，函数成员设为公有成员，这样内部数据结构就不会对该类以外的其余部分造成影响，程序模块之间的相互作用就被降低到最小。

此外，通常按 `public`, `private`, `protected` 依次定义，以便于阅读。

### 对象

声明对象

```C++
Clock myClock;//具体可能根据需求进行初始化
```

访问数据成员和函数成员

```C++
class Clock{
public:
    int hour;
    void set_minute(int x){
        minute=x;
    }
private:
    int minute;
};
Clock myClock;
myClock.hour=114514;//直接调用公有数据成员
myClock.set_minute(114514);//通过调用公有函数成员调用私有数据成员
//此外还可以通过友元函数，友元类访问私有数据成员，但是会破坏了类的封装性。
//如果滥用友元类，可能导致代码难以维护，增加耦合度。
//还有指针和引用的方法，这个以后再说
```

### 类的成员函数

通常成员函数在类内部声明，在类外部实现，以下为例子:

```C++
class Clock{
public:
    void showtime();//类内声明
    void settime(int x1=114514){//可以提供默认形参值，为方便
        hour=x1;
    }
private:
    int hour,minute,second;
};
void Clock::showtime(){//类外实现
    printf("%d %d %d\n",hour,minute,second);
}
Clock x;
x.settime();//这样不输入值，settime函数也能正常执行
```

## 构造函数和析构函数

### 构造函数

在类对象被创建时利用特定的值构造对象，将对象初始化，

在没有显式定义构造函数时，系统会生成隐含的默认构造函数，确保参数的初始化(通常为垃圾值)

### 默认构造函数

通常需要定义默认构造函数，但是这不是必须的:

如果创建了一个类的对象数组或放在某些容器中(如 `vector`)，则需要调用默认构造函数。

许多标准库模板类（如 `map` 和 `vector`）要求元素类型有默认构造函数，以便在扩展容器或初始化时使用。

如果类 B 继承了类 A，并且 B 的构造函数没有显式调用 A 的其他构造函数，则编译器会尝试调用 A 的默认构造函数来初始化基类部分。

其它情况不一定要写默认构造函数。**但是，我们应当养成习惯写默认构造函数和其它构造函数的习惯**。

```C++
class point{
public:
    point(){}//<-定义默认构造函数
private:
    //...
};
```

### 委托构造函数

```C++
class point{
public:
    point(int a,int b):x(a),y(b){}
    point():point(2,3){}//<-委托构造函数，委托其它构造函数完成初始化，通常在派生类中使用
private:
    //...
};
```

### 复制构造函数

顾名思义，复制构造函数作用是依赖先前的类完成构造，

通常在以下情况下被调用:

1.**当用类的一个对象初始化该类的另一个对象时**。

2.**调用形参是类的对象的函数的函数时**。

3.**函数返回的是一个类的对象时。**

```C++
class point{
public:
    point(int a,int b):x(a),y(b){}
    point(point &p){//自定义的复制构造函数
        x=p.x,y=p.y;
    }
};
```

### 析构函数

用来完成对象被删除前的一些清理工作。

通常在对象的生存期即将结束的时刻被自动调用。

函数体本身不接受任何参数。

```C++
~point(){}
```

### 移动构造函数

基于右值引用的设定，类似于复制构造函数。但是不同于复制构造函数的是，它主要利用 move 函数将变量转化为右值使用，直到被引用的变量被重新赋值或销毁为止，**不再通过除 rr_n 右值引用以外的方式引用，避免了冗余复制对象的代价**。

```C++
class point{
public:
    string s;
    point(point&& str) noexcept:s(std::move(str.s)){}//其中noexcepe是编译器不抛出异常的命令
};
```

参考下列例子:

```c++
class point {
public:
    string s;
    point() = delete;
    point(string t):s(t){}
    point(point&& p):s(move(p.s)){
        puts("wtf");
    }
};
int main() {
    point x("114514"), y("1919810");
    point z = move(y);
    cout << z.s << " " << y.s << " " << x.s;
    return 0;
}
```

输出:

```
wtf
114514  1919810
```

## default 和 delete 函数

### default

default 函数可以使编译器自动生成默认或复制构造函数。

可以起到简化代码的作用。

```C++
//...
point()=default;
point(point &&p)=default;
//...
```

### delete

当不希望定义的类存在复制的时候，可以用 delete 函数将复制构造函数删除。

不同于 default，delete 可以把除了析构函数的所有构造函数删除。

```C++
//...
point()=default;
point(point &&p)=delete;
//...
```

## 类的组合

**当一个类的定义包含另一个类的时候，采取类似于栈的构造和析构顺序**

**当类之间采取循环依赖的时候，需要前向引用声明，类似于函数**

## 结构体，联合体和枚举类型

### 结构体(struct)

**结构体和类的唯一区别在于，结构体和类具有不同的默认访问控制属性：在类中，对于未指定访问控制属性的成员，其访问控制属性为私有类型(private)；在结构体中，对于未指定任何访问控制属性的成员，其访问控制属性为共有类型(public)**

```C++
struct name{
    public_member
protected
    protected_member
private
    private_member
};
```

引入结构体的意义是保持和 C 程序的兼容性。

### 联合体(union)

联合体是一种特殊形态的类，由 C 语言继承而来。

联合体的全部数据成员 **共享同一组内存单元**。

```C++
union name{
    public_member
protected
    protected_member
private
    private_member
};
```

因为联合体共用相同内存单元的特性：

**联合体的所有对象成员，不能有自定义的构造函数、析构函数和重载运算符。**

**联合体不能继承，也不支持包含多态**。

所以通常只用联合体存储一些公有的数据，而不为它定义函数成员。

**无名联合体：**

没有标记名，只是声明一个成员项的集合。

```C++
union {
    public_member
protected
    protected_member
private
    private_member
};
```

### 枚举类型(enum)

enum 类型的作用主要是为保证选用数据的合法性。枚举类型可以将一组整型常量组织在一起。

例如:

```C++
enum Weekday{SUN,MON,TUE,WED,THU,FRI,SAT};
enum class week1{a,b,c};
enum struct week2{a,b,c};
//或者
enum{a,b,c}week1,week2;
```

enum 也可以进行前向声明，但是必须指定其成员类型，例如:

```C++
enum unscopedEnum:long long;//不限定作用域的，必须指定成员类型
enum scopedEnum;//限定作用域的，可使用默认成员类型
```

# 第五章-数据的共享与保护

## 标识符与作用域

### 作用域

#### 函数原型作用域

在函数原型声明时形式参数的作用范围就是函数原型作用域。

#### 局部作用域

直观来说就是”大括号“里作用域。

#### 类作用域

类 `X` 的成员 `m` 具有类作用域，对 `m` 的访问方式包括：

1. 如果在类 X 中没有声明同名的局部作用域标识符，那么可以直接访问成员 `m`
2. 通过 `X.m` 或 `X::m` 访问
3. 通过指针，如 `ptr->m`

#### 文件作用域

不在前述各个作用域中出现的声明，具有文件作用域(可以理解为全局变量/函数)

#### 命名空间作用域

命名空间声明方式:

```C++
namespace namespace_name{
    //狠狠声明
}
```

使用某个命名空间的函数、变量，需要使用 **命名空间:: 实体名称** 或 **`using namespace namespace_name`** 方式。

#### 限定作用域的 enum 枚举类

如果以 `enum class{...}` 方式定义枚举类型，其在枚举类型的作用域外是不可访问的

### 可见性

- 标识符要声明在前，引用在后。
- 在同一作用域中，不能声明同名的标识符。
- 在没有互相包含关系的不同的作用域中声明的同名标识符，互不影响。
- 如果在两个或多个具有包含关系的作用域中声明了同名标识符，则外层标识符在内层不可见。

## 生存期

### 静态生存期

如果对象的生存期与程序的运行期相同，则认为对象具有静态生存期。

在文件作用域中声明的对象都具有静态生存期。

函数内部的对象需要具有静态生存期，需要使用关键字 **`static`**。

### 动态生存期

动态(局部)生存期对象诞生于生命点，结束于声明所在的块执行完毕之时。

## 类的静态成员

### 静态数据成员

类的静态数据成员具有 **静态生存期**，不属于任何一个对象，可以通过 **类名:: 标识符** 访问，当用常量表达式类型修饰(`constexpr` 或 `const`)的静态常量在类内初始化，此时仍可以在类外定义该静态成员，但不能做再次初始化操作。

```C++
class Point{
public:
    Point(int x=0,int y=0):x(x),y(y){
        ++count;
    }
    ~Point(){
        --count;
    }
private:
    int x,y;
    static int count;
    constexpr static int origin=0;//常量静态成员类内初始化
};
int Point::count=0;//定义和初始化使用类名限定
constexpr int Point::origin;//类外定义常量静态成员，但不可二次初始化
```

### 静态函数成员

输出静态成员 `count` 需要通过 `Point` 类的静态函数成员来调用 `showCount`，这个静态函数的访问不能通过对象。

通常用如下方式访问静态函数成员:

```C++
Point::showCount();
```

静态成员函数可以 **直接访问该类的静态数据和函数成员**，而访问非静态成员，**必须通过对象名**。

```C++
class A{
public:
    static void f(A a);
private:
    int x;
};
void A::f(A a){
    cout<<a.x;
}
```

## 类的友元

友元关系提供了不同类或对象的成员函数之间，类的成员函数与一般函数之间进行数据共享的机制。

### 友元函数

友元函数是在类中用关键字 `friend` 修饰的非成员函数。在该函数体中可以通过对象名访问类的私有和保护成员。

```C++
class Point{
public:
    Point(int x=0,int y=0):x(x),y(y){}
    friend float dist(Point &p1, Point &p2);
private:
    int x,y;
};
float dist(Point &p1, Point &p2){//类外函数
    double x=p1.x-p2.x;
    double y=p1.y-p2.y;
    return sqrt(x*x+y*y);
}
```

### 友元类

若 A 类为 B 类的友元类，则 A 类的所有成员函数都是 B 类的友元函数，都可以访问 B 类的私有和保护成员。

```C++
class B{
    friend class A;
    //...
};
```

## 共享数据的保护

### 常对象

常对象必须进行初始化，而且不能被更新，常对象声明语法:

```C++
const int x;
```

常对象 **既不能被对象名访问赋值**，**也不能在类的成员函数被当作数据成员改变**。

常整型对象可以用于指定数组内存。

### 常成员函数

使用 `const` 关键字修饰的函数，声明格式如下:

```C++
int f(...) const;
```

**如果将一个对象声明为常对象，则通过常对象只能调用它的常成员函数**。

**常成员函数不能更新数据成员，也不能调用未经 `const` 修饰的成员函数**。

**`const` 关键字可以用于对重载函数区分**。

### 常数据成员

类中的常数据成员不能被函数赋值，仅能通过构造函数的初始化列表进行初始化。

### 常引用

常饮用引用的对象不能被更新，包括普通对象和常对象，声明格式如下:

```C++
const int &x;
```

### mutable 关键字

**由 `mutable` 修饰的成员对象在任何时候都不会被视为常对象**。

这样常成员函数就可以更新该数据成员。

## 多文件结构和编译预处理命令

### 外部变量与外部函数

当一个变量既可以被所在文件使用，也可以被其它文件使用，则这个变量被称为 **外部变量**。

文件作用域中的变量通常都是外部变量，如需使用，需要用 `extern` 关键字声明。

所有类之外声明的函数都具有文件作用域。

若无特殊说明，只要在调用前进行引用性声明即可。

当然，也可以提前用 `extern` 关键字声明。

### 将变量和函数限制在编译单元内

出于 **安全** 和 **避免文字冲突** 的目的，可以采用 `static` 关键字使被修饰的对象不能被其它编译单元引用。

当然，也可以使用匿名空间:

```C++
namespace{
    int n;
    void f(){
        /*...*/
    }
}
```

### 标准 C++库

C++中加入了大量的预定义模板和类。

标准 C++类与组件在逻辑上分为如下 6 种类型:

- **输入输出类**
- **容器类与 `ADT`(抽象数据类型)**
- **存储管理类**
- **算法**
- **错误处理**
- **运行环境支持**

当包含了必要的头文件，就可以使用预定义的内容:

```C++
using namespace std;
```

通常使用这条将指定命名空间的名称引入当前作用域。

否则要使用 `std::` 标识。

### 编译预处理

#### #include

```C++
#include <cstdio>
#include "function.h"
```

第一种按标准方式搜索，文件位于系统目录 `include` 下。

第二种现在当前目录搜索，若没有，再按标准方式搜索。

可以嵌套使用。

#### #define 和#undef

`#define` 可以定义符号常量，带参数宏，也可以如下定义空符号:

```C++
#define MYHEAD_H
```

用以表示该头文件已经定义过。

```C++
#undef MYHEAD_H
```

用以删除由 `#define` 定义的宏。

#### 条件编译指令

可以限定程序中某些内容要在满足一定条件的情况下才参与编译。

常见有如下形式:

**1)**

```C++
#if /*常量表达式*/
    /*....*/
#endif
```

**2)**

```C++
#if /*常量表达式*/
    /*....*/
#else
    /*....*/
#endif
```

**3)**

```C++
#if /*常量表达式*/
    /*....*/
#elif /*常量表达式*/
    /*....*/
    .
    .
    .
#elif /*常量表达式*/
    /*....*/
#else
    /*....*/
#endif
```

**4)**

```C++
#ifdef /*常量表达式*/
    /*....*/
#endif
```

**5)**

```C++
#ifndef /*标识符*/
    /*....*/
#else
    /*....*/
#endif
```

#### defined 操作符

`defined` 是一个预处理操作符，不是指令，使用形式为:

defined(标识符)

若该标识符已由 `#define` 定义过，且未由 `#undef` 删除，则表达式为非 0，否则为 0

例如:

```C++
#ifndef MYHEAD_H
/*与*/
#if !defined(MYHEAD_H)
```

是等价的

**这种写法通常写在头文件开头，用以防止重复包含头文件**。

# 第六章-数组、指针与字符串

## 数组

### 声明与使用

略

### 存储与初始化

**数组元素在内存中是顺序、连续存储的**。

初始化方面值得注意的是:

```C++
int a[2][3]={1,1,4,5,1,4};
/*与*/
int a[][3]={1,1,4,5,1,4};
/*与*/
int a[2][3]={(1,1,4),(5,1,4)};
```

是完全等效的。

### 作为函数参数

**使用数组名传递数据时，传递的是地址**，因此形参数组和实参数组的首地址重合，进而对应元素使用相同的数据存储地址，因此实参数组的元素个数不应该少于形参数组的元素个数。

**所以被调函数中对形参数组元素值改变，主调函数中实参数组的相应元素值也会改变**。

传参格式如下:

```C++
void rowSum(int a[][4], int nRow){
    /*...*/
}
int main(){
    int table[3][4]={/*...*/};
    rowSum(table,3);
    return 0;
}
```

### 对象数组

声明一个一维对象数组的形式例为:

```C++
class location{
/*....*/
};
int main(){
    location a[2]={location(1,2)};
    return 0;
}
```

在这个例子中，会先调用带形参的构造函数初始化 `a[0]`，再调用默认构造函数初始化 `a[1]`。

## 指针

C++程序可以通过变量名和地址利用内存单元读取数据。

利用地址读取数据的优点是:

- **有时候变量名不够方便，或者无变量名可用，如此可以提高方便性**。
- **减小系统开销，提高效率**。
- **动态分配的内存单元没有名称，只能通过地址访问**。

指针就是专门用来存放内存单元地址的变量类型。

### 指针变量的声明

数据类型 `*` 标识符:

如:

```C++
int *ptr;
```

### 与地址相关的运算

`*` 是指针运算符，也称解析，表示获取指针所指向的变量的值。

`&` 是取地址运算符，用来得到一个对象的地址。

### 指针的赋值

通过将对象地址赋给指针变量完成赋值。

值得注意的是:

1. **数组名称实际上就是一个不能被赋值的指针，即指针常量**。

2. **可以声明指向常量的指针**。

3. **可以声明指针类型的常量，这时指针本身的值不能被改变**。
   例如:

   ```c++
   int* const p2=&a;
   p2=&b;//不合法
   ```

4. **`void` 类型指针可以存储任何类型对象地址，经过类型显式转换，`void` 类型指针可以访问任何类型数据**。

```C++
void* p;
int i=5;
p=&i;
int* pint=static_cast<int *>(p);
```

### 指针运算

**指针与整型的相加减即指针指向地址向前或向后移若干位**。

**其中 `0` 专用于表示空指针，也就是一个不指向任何有效地址的指针**。

在这里，`0` 也可以由 `NULL` 或 `nullptr` 代替。

### 用指针处理数组元素

```C++
int a[10]={1,1,4,5,1,4};
int* beg=begin(a);//返回数组a首元素的指针
int* last=end(a);//返回数组a尾元素下一位置的指针
```

### 指针数组

指针数组必须先赋值，后引用。

其中对于二维数组的使用如下:

```C++
int a[2][3]={(1,1,4),(5,1,4),(1,9,1)};
for(int i=0;i<3;++i){
    for(int j=0;j<3;++j)cout<<*(*(a+i)+j)<<" ";
    cout<<endl;
}
```

这里 `*(a+i)` 返回的是 `a[i]` 的首地址。

### 指针作为函数参数

形式上如下例:

```C++
void f(int* x,float* y){
    *x=114514;
    *y=1919810;
}
int main(){
    int x,y;
    f(&x,&y);
    return 0;
}
```

### 指针型函数

当一个函数的返回值是指针类型，这个函数就是指针型函数。

稍为复杂的就是 **函数返回数组指针**:

```C++
typedef int arr[10];//或using arr=int[10];
arr* foo(int i);//foo返回一个指向含有10个整数的数组的指针
```

或者

```C++
int (*foo(int i))[10];
//函数foo返回了一个数组指针但没有使用类型别名
```

或者

```C++
auto foo(int i)->int(*)[10];
//函数foo返回了一个指向10个int类型的数组的指针
```

如果知道函数返回的指针将指向哪个数组，那也可以用这种方法:

```C++
int a[]={0,1,2,3,4};
int b[]={5,6,7,8,9};
decltype(a) *func(int i){
    return (i%2)?&a:&b;
}
//decltype表示指针所指对象与a类型一致
//函数func返回了一个指向5个int类型的数组指针
```

### 指向函数的指针

函数指针就是专门用来存放函数代码首地址的变量。可以像使用函数名一样使用指向函数的指针来调用函数:

```C++
void f(int x){
    puts("114514");
}
void (*funcptr)(float);//一个有float形参，返回类型为void的函数的指针
typedef int (*dif)(double);
//这声明了dif为“有一个double形参，返回类型为int的函数的指针类型”
funcptr=f;
funcptr(114514);//调用f
```

### 对象指针

#### 对象指针的一般语法示例

```C++
Point *ptr;
Point p1;
ptr=&p1;
ptr->show();
```

对象指针在使用之前，一定要进行初始化。

#### this 指针

`this` 指针是一个隐含于每一个类懂得非静态成员函数中的特殊指针，用于指向正在被成员函数操作的对象。

例如:

```C++
return x;
/*其实是*/
return this->x;
```

成员函数对对象的数据成员操作时，就隐含使用了 `this` 指针。

#### 指向类的非静态成员的指针

```C++
int main(){
    Point a(4,5);
    Point *p1=&a;
    int Point::*dataPtr;
    //指向数据成员的指针
    int (Point::*funcPtr)(/*参数表*/)const=&Point::getx;
    //指向函数成员的指针
    cout<<(a.*funcPtr)()<<endl;
    cout<<(p1->*funcPtr)()<<endl;
    //两种调用方式
    return 0;
}
```

#### 指向类的静态成员的指针

因为对类的静态成员的访问不依赖于对象，可以用普通指针指向和访问静态成员。

## 动态内存分配

### new 和 delete

`new` 用于申请分配用于存放指定类型数据的内存空间，并根据初始化参数列表进行初始化。

若内存申请成功，`new` 运算便返回一个指向新分配内存首地址的类型的指针, 可以通过这个指针对堆对象进行访问。

若内存申请失败，会抛出异常。

使用例:

```C++
int *point;
point=new int(2);//动态分配了用于存放int类型数据的内存空间
//并把初值2存入该空间，再将首地址赋给point
int *point=new int;//不赋初值
int *point=new int();//以0作为初值
```

`delete` 用来删除由 `new` 建立的对象，释放指针所指向的内存空间:

```c++
delete point;
```

值得注意的是:

**如果被删除的是对象，则调用该对象的析构函数**。

**对同一内存空间多次使用 `delete` 将会导致运行错误**。

### assert

`assert` 是标准 C++的 <cassert> 头文件中定义的一个宏，用来判断表达式是否为 `true`，如果为 `false`，则程序终止，报告错误。其只在调试 `debug` 模式下生效。

## 深层复制与浅层复制

浅层复制只复制对象的基本成员（如值或指针地址），而不复制指针所指向的实际数据。这意味着多个对象共享相同的动态内存资源。

- **对象间共享动态内存资源**。
- **若一个对象释放了动态内存，其他对象会因为指针悬挂（dangling pointer）导致程序崩溃**。
- **默认的拷贝构造函数和赋值运算符都是浅层复制**。

深层复制会为每个对象单独分配一块新的动态内存，并复制指针所指向的数据内容。这样，两个对象互不干扰，能安全地管理各自的资源。

- **为每个对象独立分配资源**。
- **避免了共享资源导致的问题**。
- **需要手动实现拷贝构造函数和赋值运算符**。

## 字符串

熟能生巧~

## 指针和引用

| **特性**             | **指针**                                   | **引用**                       |
| -------------------- | ------------------------------------------ | ------------------------------ |
| **定义**             | 保存变量地址的变量，可以指向其他变量或内存 | 变量的别名，直接绑定到某个变量 |
| **是否必须初始化**   | 可以声明后初始化，未初始化指针为 `nullptr`  | 必须在定义时初始化             |
| **是否可以更改指向** | 可以更改指向的地址                         | 一旦绑定到变量，不能更改绑定   |
| **是否可以为空**     | 可以为空（`nullptr` 或未初始化）            | 不存在空引用                   |

## reinterpret_cast 和 const_cast

**`reinterpret_cast`** 是一种底层，具有很大危险性和不确定性的数据类型转换。

```C++
int i;
float *p=reinterpret_cast<float *>(&i);
```

通过 p 访问整型变量 `i`，所执行的操作只能是针对浮点型的。

会出大问题，少用。

**`const_cast`** 可以用来将数据类型中的 `const` 属性去除，可以将常指针转换为普通指针，将常引用转换为普通引用。

# 第七章-类的继承

**类的继承，是新的类从已有类那里得到已有的特性**。

**从已有类产生新类的过程就是类的派生**。

**原有的类成为基类或父类**。

**产生的类称为派生类或子类**。

## 基类与派生类

### 派生类的定义

```C++
class derived:public base1,private base2{
public:
    derived();
    ~derived();
};
```

一个派生类，可以同时有多个基类，这种情况称为 **多继承**。

一个派生类只有一个直接基类的情况，称为 **单继承**。

直接参与派生出某类的基类称为 **直接基类**。

基类的基类甚至更高层的基类称为 **间接基类**。

**继承方式** 规定了如何访问从基类继承的成员，如 public、protected、private。

**派生类成员** 是指除了从基类继承来的所有成员外，新增加的数据和函数成员。

### 派生类生成过程

- **吸收基类成员**

派生类包含全部基类中除构造和析构函数之外的所有成员。

- **改造基类成员**

一方面，依靠派生类定义时的继承方式来控制。

另一方面，进行对基类数据或函数成员的覆盖或隐藏。

如果派生类声明了一个和某基类成员同名的新成员，派生的新成员就隐藏了外层同名成员，这叫做 **同名隐藏**。

- **添加新的成员**

派生类要实现一些特别的初始化和扫尾清理工作，就需要在派生类中加入新的构造和析构函数。

## 访问控制

### 公有继承

基类的公有和保护成员的访问属性在派生类中不变，而基类的私有成员不可直接访问。

### 私有继承

基类的公有和保护成员的都以私有成员身份出现在派生类中，而基类的私有成员不可直接访问。

### 保护继承

基类的公有和保护成员都以保护成员的身份出现在派生类中，而基类的私有成员不可直接访问。

## 类型兼容规则

**类型兼容规则是指在需要基类对象的任何地方，都可以使用公有派生类的对象来替代**。

这个替代包括:

```C++
class B{/*...*/};
class D:public B{/*...*/};
B b,*bp;
D d;
```

- **派生类的对象可以隐含转换为基类对象**。

```C++
b=d;
```

- **派生类的对象可以初始化基类的引用**。

```C++
B &rb=d;
```

- **派生类的指针可以隐含转换为基类的指针**。

```C++
bp=&d;
```

在替代之后，派生类对象就可以作为基类的对象使用，但只能使用从基类继承的成员。

## 派生类的构造和析构函数

### 构造函数

派生类在创建过程中，就会调用基类的构造函数，以确保派生类构造函数执行时，基类已经被初始化。

如果需要调用基类的带有形参表的构造函数，派生类就必须声明构造函数。

派生类构造函数执行的一般顺序如下:

1. **调用基类构造函数，调用顺序按照它们被继承时声明的顺序(从左向右)**
2. **对派生类新增的成员初始化，初始化顺序按照它们在类中声明的顺序**
3. **执行派生类的构造函数体中的内容**

```C++
class base1{
public:
    base1(int x){cout<<"base1 constructed "<<x<<endl;}
};
class base2{
public:
    base2(int x){cout<<"base2 constructed "<<x<<endl;}
};
class base3{
public:
    base3(){cout<<"base3 constructed "<<"#"<<endl;}
};
class derived:public base2,public base1,public base3{
public:
    derived(int x,int y,int z,int w):base1(x),member2(y),member1(z),base2(w){}
    //事实上，这个构造顺序无关紧要
private:
    base1 member1;
    base2 member2;
    base3 member3;
};
int main(){
    derived obj(1,2,3,4);
    return 0;
}
```

输出结果将会是:

```C++
base2 constructed 4
base1 constructed 1
base3 constructed #
base1 constructed 3
base2 constructed 2
base3 constructed #
```

### 复制构造函数

派生类的复制构造函数，一般需要为基类相应的复制构造函数传递参数，例:

```C++
derived::derived(const derived&v):base(v){/*...*/}
```

### 析构函数

可以认为，析构函数执行的次序与构造函数执行时严格相反。

```C++
class base1{
public:
    base1(int x){cout<<"base1 constructed "<<x<<endl;}
    ~base1(){cout<<"base1 destructed"<<endl;}
};
class base2{
public:
    base2(int x){cout<<"base2 constructed "<<x<<endl;}
    ~base2(){cout<<"base2 destructed"<<endl;}
};
class base3{
public:
    base3(){cout<<"base3 constructed "<<"#"<<endl;}
    ~base3(){cout<<"base3 destructed"<<endl;}
};
class derived:public base2,public base1,public base3{
public:
    derived(int x,int y,int z,int w):base1(x),member2(y),member1(z),base2(w){}
    //事实上，这个构造顺序无关紧要
private:
    base1 member1;
    base2 member2;
    base3 member3;
};
int main(){
    derived obj(1,2,3,4);
    return 0;
}
```

输出结果将会是:

```C++
base2 constructed 4
base1 constructed 1
base3 constructed #
base1 constructed 3
base2 constructed 2
base3 constructed #
base3 destructed
base2 destructed
base1 destructed
base3 destructed
base1 destructed
base2 destructed
```

### 删除 delete 构造函数

如果基类中的默认构造函数、复制构造函数、移动构造函数是删除或者不可访问的，则派生类中对应的成员函数将是被删除的。

因为编译器无法执行派生类对象中基类部分的构造或赋值操作。

```C++
class base{
public:
    base()=default;
    base(string _info):info(move(_info)){}
    base(base &)=delete;
    base(base &&)=delete;
private:
    string info;
};
class derived:public base{
};
derived d;//可以
derived _d(d);//不行
derived __d(move(d));//不行
```

## 派生类成员的标识与访问

### 作用域分辨符

首先在不同的作用域声明的标识符，可见性原则是: 如果存在两个或多个具有包含关系的作用域，若内层声明了同名标识符，则外层标识符在内层不可见，实现了标识符之间的 **隐藏**。

因此:

**如果派生类中声明了与基类成员函数同名的新函数，即使函数的参数表不同，从基类继承的同名函数的所有重载形式也都会被隐藏**。

另一方面:

**如果派生类的多个基类拥有同名的成员，即使派生类没有同名成员，也不能访问基类成员**。

但是可以使用作用域分辨符 **`::`**

使用例:

```C++
class base1{
public:
    int var;
    void fun(){cout<<"m1"<<endl;}
};
class base2{
public:
    int var;
    void fun(){cout<<"m2"<<endl;}
};
class derived:public base1,public base2{
public:
    int var;
    void fun(){cout<<"d1"<<endl;}
};
int main(){
    derived d;
    derived *p=&d;
    d.var=1;
    d.fun();
    d.base1::var=2;
    d.base1::fun();
    p->base2::var=3;
    p->base2::fun();
    return 0;
}
```

如果，去掉 `derived` 中同名变量和函数的定义，会出现错误。

可以使用 `using` 关键字加以澄清。

例:

```C++
class base1{
public:
    int var;
    void fun(){cout<<"m1"<<endl;}
};
class base2{
public:
    int var;
    void fun(){cout<<"m2"<<endl;}
};
class derived:public base1,public base2{
public:
    using base1::var;
    using base1::fun;
};
int main(){
    derived d;
    derived *p=&d;
    d.var=1;//经过澄清
    d.fun();//可以访问
    p->base2::var=3;
    p->base2::fun();
    return 0;
}
```

### 虚基类

派生类从不同路径继承过来同名数据成员，这可能会导致冗余、冲突、甚至逻辑错误。

通过虚基类，可以确保最终的派生类只会有一个基类的副本。

```C++
class A{
public:
    A(){
        cout<<"A constructor"<<endl;
    }
    void show() {
        cout << "A class" << endl;
    }
};
class B:virtual public A{//声明虚基类 A
public:
    B(){
        cout<<"B constructor"<<endl;
    }
};
class C:virtual public A{//声明虚基类 A
public:
    C(){
        cout<<"C constructor"<<endl;
    }
};
class D:public B,public C{
public:
    D(){
        cout<<"D constructor"<<endl;
    }
};
int main() {
    D d;
    d.show();//调用A的成员函数
    return 0;
}
```

### 虚基类及其派生类构造函数

建立一个对象时，如果这个对象中含有从虚基类继承来的成员，则虚基类的成员是由最远派生类的构造函数通过调用虚基类的构造函数进行初始化的。而且，只有最远派生类的构造函数会调用虚基类的构造函数。

例如，如果上个代码中类 B，C，D 都调用 A 的构造函数，那么只有 D 会调用虚基类的构造函数。

## 派生类对象的内存布局

### 单继承

派生类继承基类的时候，派生类新增的数据成员放在基类数据成员之后，一起组成派生类对象:

<img src=".\pictures\image-20241228150139342.png">  

pd 赋给 pbb 的过程中，指针值不需要改变。

pba 和 pbb 指针，虽然指向不同类型，但是任何一个 Base 数据成员到该对象首地址都具有相同的偏移量。

所以二者可以采用相同的方式访问 Base 类中定义的数据成员。

#### 多继承

以下是 Derived 类依次继承 Base1 类，Base2 类:

<img src=".\pictures\image-20241228151453512.png">

#### 虚拟继承

以下是等同于上文介绍虚基类的代码中继承关系:

<img src=".\pictures\image-20241228151544510.png">

<img src=".\pictures\image-20241228151628612.png">

## 基类向派生类的转换及其安全性问题

派生类指针要想转换为基类指针，则转换一定要显示地进行，如:

```C++
Base* pb=new Derived();
Derived* pd=static_cast<Derived *>(pd);
```

同 `void` 指针与其它指针的关系一样，从一般指针转换到特殊指针是不安全的，只能显示地转换。

引用亦然:

```C++
Derived d;
Base& rb=d;
Derived& rb=static_cast<Derived &>(rb);
```

值得注意的是：

- **基类对象一般无法被显示转换为派生类对象**，因为这不涉及创建新的对象。
- 执行基类向派生类的转换时，一定要确保被转换的指针和引用所指向或引用的对象符合转换的目的类型。
- 在多重继承情况下，执行基类指针到派生类指针的显式转换时，通常需要将指针所存储的地址值进行调整后才能得到新指针的值。
- 如果转换中间涉及 void 指针，只要最初和最后的类型不完全相同，转换的结果就可能是不正确的。

# 第八章-类的多态

## 多态性概述

### 多态的类型

面向对象的多态性可分为 **重载多态**、**强制多态**、**包含多态**、**参数多态**。

前两者统称为专用多态，后两者统称为通用多态。

- **函数重载属于重载多态**。
- **强制类型转换属于强制多态**。
- **虚函数实现的不同类中同名成员函数的多态行为是包含多态**。
- **类模板涉及参数多态**。

### 多态的实现

**编译时多态**: 在编译时确定具体调用的函数版本，通常通过 **函数重载** 和 **运算符重载** 和 **静态绑定** 实现。

**运行时多态**: 在程序运行时根据实际对象的类型动态选择函数的实现，通常通过 **虚函数** 和 **动态绑定** 实现。

其中绑定是指计算机程序自身彼此关联的过程。

## 运算符重载

运算符重载是对已有的运算符赋予多重含义，使同一个运算符作用于不同类型的数据时导致不同的行为。

### 运算符重载的规则

1. 只能重载已经存在的运算符。
2. 运算符的优先级和结合性都不会改变。
3. 不能改变原运算符的操作对象个数，至少要有一个操作对象是自定义类型。
4. **`.` `.*` `::` `?:` `sizeof`** 不能重载。
5. 既可以重载为非成员函数，也可以重载为成员函数。

### 运算符重载为成员函数

```C++
class Complex{
private:
    int real, imag;
public:
    Complex(int r,int i):real(r),imag(i){}
    Complex operator +(const Complex& other){
        return Complex(real+other.real,imag+other.imag);
    }
    Complex& operator +=(const Complex& other){
        real+=other.real;
        imag+=other.imag;
        return *this;
    }
    Complex& operator++(){
        ++real;
        return *this;
    }
    Complex operator++(int){
        return ++(*this);
    }
    void display(){
        cout<<real<<" + "<<imag<<"i"<<endl;
    }
};

int main() {
    Complex c1(1,14),c2(5,14);
    Complex c3=c1+c2;
    c3+=c1;
    c3++;
    ++c3;
    c3.display();
    return 0;
}
```

### 运算符重载为非成员函数

运算符重载作为非成员函数时，可以像普通函数一样定义，并且可以通过参数来访问运算符的左侧和右侧对象。

不能重载 `=`，`->`，`[]`，`()`

非成员函数通常有两种情况:

**友元函数**: 将运算符重载函数声明为类的友元函数，使其可以访问类的私有成员。

**全局函数**: 在类外部定义的运算符重载函数。

非成员函数(如果不是友元函数)无法直接访问类的私有成员，因此需要通过公共接口(如 `getter`)来间接访问类成员。

```C++
class Complex {
private:
    double real,imag;
public:
    Complex(double r = 0, double i = 0) : real(r), imag(i) {}
    void display() const{
        cout<<real<<" + "<<imag<<"i"<<endl;
    }
    friend Complex operator+(const Complex& c1,const Complex& c2);
    friend ostream& operator<<(ostream& out,const Complex& c);
    friend istream& operator>>(istream& in,Complex& c);
};
Complex operator+(const Complex& c1,const Complex& c2) {
    return Complex(c1.real+c2.real,c1.imag+c2.imag);
}
ostream& operator<<(ostream& out,const Complex& c){
    out<<c.real<<" + "<<c.imag<<"i";
    return out;
}
istream& operator>>(istream& in,Complex& c){
    in>>c.real>>c.imag;
    return in;
}
int main() {
    Complex c1(11.0,4.0);
    Complex c2(5.0,14.0);
    Complex c3=c1+c2;
    c3.display();
    return 0;
}
```

## 虚函数

**虚函数声明只能出现在类定义中的函数原型声明中，而不能在成员函数实现的时候**。

### 虚函数的基本概念

- **虚函数** 是基类中声明的函数，允许在派生类中进行重写。
- 使用关键字 `virtual` 来声明虚函数。
- 虚函数实现了 **动态多态**，即程序在运行时决定调用哪个版本的函数。

### 虚函数的工作原理

- 当你使用基类的指针或引用来调用虚函数时，程序会根据实际指向的对象的类型来调用合适的函数，而不是在编译时决定。这个过程称为 **动态绑定** 或 **运行时多态**。
- 虚函数的调用通过 **虚函数表(`vtable`)** 实现。每个包含虚函数的类都有一个虚函数表，该表包含指向虚函数的指针。当你通过基类指针调用虚函数时，程序会查找该指针所指向对象的虚函数表，从而确定实际调用的函数。

### 一般虚成员函数

```C++
class Base {
public:
    virtual void show(){
        cout<<"Base class show function"<<endl;
    }
};
class Derived:public Base{
public:
    void show() override{
        cout<<"Derived class show function"<<endl;
    }
};
int main() {
    Base* basePtr;
    Derived derivedObj;
    basePtr=&derivedObj;
    basePtr->show();
    return 0;
}
```

上述代码将会调用派生类中的 `show` 函数。

其中 `override` 关键字用来说明派生类中的虚函数。

还存在 `final` 关键字可以标记某成员函数不能被覆盖，用法和 `override` 一样。

### 虚析构函数

基类的析构函数应该是虚函数，以确保当派生类对象通过基类指针删除时，派生类的析构函数能够被正确调用。如果没有虚析构函数，派生类的析构函数可能不会被调用，从而导致资源泄漏。

```C++
class Base {
public:
    virtual ~Base(){
        cout<<"Base Destructor"<<endl;
    }
};
class Derived:public Base {
public:
    ~Derived(){
        cout<<"Derived Destructor"<<endl;
    }
};
int main() {
    Base* basePtr=new Derived();
    delete basePtr;
    return 0;
}
```

## 纯虚函数与抽象类

### 纯虚函数

纯虚函数是在基类中声明的虚函数，但不提供函数的具体实现。纯虚函数以 `=0` 结尾，它的目的是强制派生类实现该函数。这使得基类成为一个抽象类。

声明为纯虚函数之后，基类中就可以不再给出函数的实现部分。

### 抽象类

抽象类是包含至少一个纯虚函数的类。抽象类不能被实例化。它的目的是为派生类提供一个共同的接口，而不需要具体实现。抽象类可以包含:

纯虚函数: 没有函数实现，强制派生类提供实现。

普通函数: 可以包含已实现的函数，供派生类使用或覆盖。

数据成员: 存储类的状态。

**抽象类的特点：**

1. **不能实例化**：抽象类不能直接创建对象，只能通过指向派生类的指针或引用来使用。派生类只有实现了基抽象类的所有纯虚函数才可以实例化。
2. **提供接口**：抽象类通常用于定义派生类必须实现的接口。
3. **可以包含已实现的函数**：虽然抽象类包含纯虚函数，但它也可以包含已实现的函数，供派生类继承或调用。

```C++
class Animal {
public:
    virtual void speak()=0;
    void sleep(){
        cout << "Animal is sleeping." << endl;
    }
};
class Dog:public Animal{
public:
    void speak()override{
        cout<<"Woof!"<<endl;
    }
};
class Cat:public Animal{
public:
    void speak()override{
        cout<<"Meow!"<<endl;
    }
};
int main() {
    Animal* dog=new Dog();
    Animal* cat=new Cat();
    dog->speak();
    dog->sleep();
    cat->speak();
    cat->sleep();
    delete dog;
    delete cat;
    return 0;
}
```

## 多态类型与非多态类型

多态类型是指有虚函数的类类型，非多态类型是指所有的其他类型。

**对非多态类的公有继承，应当慎重，而且一般没有太大必要**。

## 运行时类型识别

### 用 dynamic_cast 执行基类向派生类的转换

`dynamic_cast` 可以将基类的指针显式转换为派生类的指针，或将基类的引用转换为派生类的引用。

会检查前后类型是否兼容，若不兼容:

**指针类型：得到空指针**。

**引用类型：抛出异常**。

且转换前类型必须是指向多态类型的指针或引用。

```c++
Base* q=new Base;
Derived* p = dynamic_cast<Derived*>(q);
```

### 用 typeid 获取运行时类型信息

```C++
const type_info &p=typeid(114+514),&q=typeid(int)
```

通过 `typeid` 得到的是一个 `type_info` 类型的常引用。

其中 `type_info` 是定义在 <typeinfo> 头文件中的类类型。

### 虚函数动态绑定的实现原理

#### 虚函数的工作机制

当一个类声明了虚函数时，编译器会为该类创建一个虚表。虚表是一个函数指针数组，其中每个元素指向该类的虚函数的实现。对于派生类，它会继承基类的虚表，并且会替换虚表中的虚函数指针，以指向该派生类中重写的函数。

**虚表（`vtable`）**：每个类(包含虚函数的类)会有一个虚表，虚表是一个函数指针数组，每个指针指向类中的虚函数的实现。

**虚指针（`vptr`）**：每个对象(如果类中有虚函数)都会有一个指向虚表的指针，称为虚指针。每个对象在构造时会初始化该指针指向类的虚表。

#### 虚表的实现过程

**编译阶段**

编译器会为每个包含虚函数的类生成一个虚表。这个表中存储了类中虚函数的地址。

如果类中有虚函数，编译器会在该类的每个对象中添加一个虚指针(`vptr`)，指向该类的虚表。

**对象创建阶段**

当创建一个对象时，编译器会初始化该对象的 `vptr`，使它指向正确的虚表(根据对象的实际类型，可能是基类或派生类的虚表)。

**运行时阶段**

当通过基类指针或引用调用虚函数时，程序会通过该指针或引用中的 `vptr` 查找虚表。然后，虚表中的函数指针会指向相应的虚函数实现(基类或派生类的实现)。

# 第九章-模板与群体数据

## 函数模板与类模板

通过模板可以实现参数化多态性，即 **将程序所处理的对象的类型参数化，使得一段程序可以用于处理多种不同类型的对象**。

### 函数模板

```C++
template <typename T>
T abs(T x){
    return x<0?-x:x;
}
/*
typename也可以使用class标识符，接收类型可以是任意的
*/
```

在调用 abs()时，编译器会根据实参的类型推导出函数模板的类型参数，并根据函数模板生成一个函数并执行，这叫作 **函数模板的实例化**。

**注意:**

- 只有生成的示例会生成目标代码。
- 模板的函数体也应当放在头文件中。
- 函数指针只能指向模板生成的实例。

### 类模板

**使用类模板可以为类定义一种模式，使得类中的某些数据成员、某些成员函数的参数、返回值或局部变量能取不同类型**。

#### 类模板的定义

```C++
template <typename T>//或者使用class替代typename
class ClassName{
private:
    T data;
public:
    ClassName(T value):data(value){}//构造函数
    T getData(){return data;}//成员函数，返回模板类型的数据
};
```

1. `template <typename T>` 是模板声明，其中 `T` 是占位符，表示在使用该模板时将指定的具体类型替代它。
2. `ClassName` 是类模板的名字，`T` 是模板参数，可以在类中作为数据类型来使用。

类模板在定义时并没有生成具体的类，而是在实例化时根据传入的类型创建具体的类。

**实例化类模板** 时，可以传入不同的类型:

```C++
ClassName<int> obj1(114514);
ClassName<double> obj2(1919.810);
```

**类模板也可以支持多个类型参数**，比如 `STL` 模板里的 `pair`。

**默认模板参数**

```C++
template <typename T=int>
class Box{
private:
    T value;
public:
    Box(T val):value(val) {}
    T getValue(){return value;}
};
```

在这里，`T` 默认被定义为 `int`，如果在实例化时不指定类型参数，编译器会默认使用 `int` 类型。

**模板类中友元声明类型参数**

```C++
template <typename T>
class MyClass {
    friend T;//类型参数T是友元，可以访问私有成员
private:
    int data=42;
public:
    MyClass()=default;
};
class FriendClass{
public:
    void showPrivateData(const MyClass<FriendClass>& obj) {
        cout<<"Accessing private data: "<<obj.data<<endl;
    }
};
int main() {
    MyClass<FriendClass> obj;
    FriendClass friendObj;
    friendObj.showPrivateData(obj);//类型参数作为友元
    return 0;
}
```

使得 `T` 在被用来实例化模板类的基础上，拥有对 `ClassName` 的成员的访问权限。

**`typedef` 和 `using` 为模板类定义别名**

```C++
//为模板实例化定义别名
typedef ClassName<int>intClassName;
using intClassName=ClassName<int>;
//为模板非实例化定义别名
template <typename T>using AliasDemo=ClassName<T>;
template <typename T>using IntPair=pair<T,int>;
```

## 线性群体

对可直接访问的线性群体，可以直接访问群体中的任何一个元素。

对顺序访问的线性群体，只能按元素的排列顺序从头开始依次访问各个元素。

后简单，略。

## 为模板定义特殊的实现

### 完全特化

```C++
// 通用模板
template <typename T>
class MyClass{
public:
    void print(){
        cout<<"Generic Template"<<endl;
    }
};
// 完全特化：针对 int 类型的特化
template <>
class MyClass<int>{
public:
    void print(){
        cout<<"Specialized Template for int"<<endl;
    }
};
int main(){
    MyClass<float> obj1;
    obj1.print();//输出:Generic Template
    MyClass<int> obj2;
    obj2.print();//输出:Specialized Template for int
    return 0;
}
```

### 偏特化

```C++
// 通用模板
template <typename T>
class MyClass{
public:
    void print(){
        cout<<"Generic Template"<<endl;
    }
};
// 偏特化：当模板参数是指针类型时
template <typename T>
class MyClass<T*>{
public:
    void print(){
        cout<<"Specialized Template for Pointer"<<endl;
    }
};
int main(){
    MyClass<int> obj1;
    obj1.print();//输出:Generic Template
    MyClass<int*> obj2;
    obj2.print();//输出:Specialized Template for Pointer
    return 0;
}
```

### 函数模板重载

允许为不同参数类型定义多个函数模板，可以根据参数的不同类型来选择不同的重载版本。

```C++
//函数模板重载
template <typename T>
void print(T val){
    cout<<"Generic Template: "<<val<<endl;
}
//重载版本：针对const char*类型的特化
template <>
void print<const char*>(const char* val){
    cout<<"Specialized Template for const char*: "<<val<<endl;
}
int main(){
    print(10);//输出:Generic Template: 10
    print("Hello, World!");//输出:Specialized Template for const char*: Hello, World!
    return 0;
}
```

### 类模板的默认实参

类模板可以为模板参数提供默认值，调用时可以不显式指定模板参数。

```C++
template <typename T=int>
class MyClass{
public:
    T value;
    MyClass(T val):value(val){}
    void print(){
        cout<<"Value: "<<value<<endl;
    }
};
int main(){
    MyClass<> obj1(42);//使用默认模板参数int
    obj1.print();//输出:Value:42
    MyClass<double> obj2(3.14);//显式指定模板参数为double
    obj2.print();//输出:Value:3.14
    return 0;
}
```

### 函数模板的默认实参

函数模板也可以为模板参数提供默认值。若调用时未指定模板参数，则会使用默认值。

```C++
template <typename T=int>
T add(T a,T b){
    return a+b;
}
int main(){
    cout<<add(3,4)<<endl;//使用默认类型int,输出:7
    cout<<add<double>(3.14,2.71)<<endl;//显式指定模板类型double,输出:5.85
    return 0;
}
```

## 模板元编程

一种利用 C++模板机制在编译期间执行计算的编程技巧。它允许在编译时计算出常量值、生成类型和实现算法，而不是在程序运行时进行计算。通过模板递归、模板特化等技术，程序员可以编写高效的代码，并通过编译时计算提高性能。

```C++
template <int N>
struct Factorial{
    static const int value=N*Factorial<N-1>::value;
};
// 基本情况，阶乘0的结果是1
template <>
struct Factorial<0>{
    static const int value = 1;
};
int main(){
    cout<<"Factorial of 5: "<<Factorial<5>::value<<endl;//输出:120
    return 0;
}
```

`Factorial` 模板使用递归来计算阶乘。在编译时，`Factorial<5>::value` 会被替换为 `5 * Factorial<4>::value`，依此类推，直到递归到 `Factorial<0>::value`。

这个计算发生在编译阶段，因此可以避免在程序运行时进行计算。

## 可变参数模板

`C++11` 引入的一种特性，使得模板能够接受任意数量的模板参数。传统的模板只能接受固定数量的参数，而可变参数模板允许模板接受零个或多个参数，非常适合处理不定数量的参数。

语法:

```C++
template <typename...Args>
void func(Args...args);
```

**展开方式**

左折叠:

```c++
template<typename... Args>
void sum(Args... args) {
    cout<<"Sum: "<<(args+...)<<endl;//从左到右依次求和
}
int main(){
    sum(1,2,3,4);//输出：Sum:10
    return 0;
}
```

右折叠:

```c++
template<typename... Args>
void printInReverse(Args... args){
    (cout<<...<<args)<<endl;//从右到左展开
}
```

递归展开:

```C++
//基础情况：递归终止条件
void print(){
    cout<<endl;
}
//可变参数模板函数：递归打印每个参数
template <typename T,typename... Args>
void print(T first,Args...args) {
    cout<<first<<" ";
    print(args...);//递归调用，展开剩余的参数
}
int main(){
    print(1,2.5,"Hello",'A');//输出:1 2.5 Hello A
    return 0;
}
```

初始列表展开:

```c++
template<typename... Args>
void print(Args... args){
    initializer_list<int>{(cout<<args<<" ",0)...};//参数包展开到初始列表中
    cout<<endl;
}
int main(){
    print(1,2.5,"Hello",'A');//输出：1 2.5 Hello A
    return 0;
}
```

**解释**

`print` 是一个可变参数模板函数。`Args...` 表示一个参数包，可以匹配任意数量的参数。

在递归函数调用中，通过 `print(args...)` 展开参数包，并逐个打印每个参数。

**应用**

构造多参数类

```c++
template<typename... Args>
class MyClass{
public:
    MyClass(Args... args){
        print(args...);
    }
    void print(Args... args){
        (cout<<...<<args)<<endl;
    }
};
int main(){
    MyClass<int,double,string>obj(1,3.14,"Hello");
    return 0;
}

```

**转发参数到另一个函数**

```c++
template<typename... Args>
void wrapper(void (*func)(Args...),Args... args){
    func(args...);//参数转发
}
void printArgs(int a, double b, const char* c){
    cout<<a<<" "<<b<<" "<<c<<endl;
}
int main(){
    wrapper(printArgs,42,3.14,"Hello");
    return 0;
}
```

**可变参数模板与继承**

实现模板类的多层继承，类似于 `tuple` 的功能。

```c++
template<typename... Args>
class MyTuple;//前向声明
template<>
class MyTuple<>{};//空模板的特化，递归终止
template<typename T,typename... Rest>
class MyTuple<T,Rest...>:private MyTuple<Rest...>{
public:
    MyTuple(T first,Rest... rest):MyTuple<Rest...>(rest...),value(first){}
    T getValue()const{return value;}
private:
    T value;
};
int main(){
    MyTuple<int,double,string>tuple(42,3.14,"Hello");
    cout<<tuple.getValue()<<endl;//输出42（第一个元素的值）
    return 0;
}
```

**进一步理解**

**递归展开**: 在编译时，编译器通过递归展开参数包来处理每个参数。

**`sizeof...(Args)`**: 可以获取模板参数包中参数的数量。

**`std::forward<Args>(args)`**: 可以转发参数(通过完美转发传递到其他函数)。

# 第十章-泛型程序设计与 STL

## 基本概念

### 泛型程序设计

就是 **编写不依赖于具体数据类型的程序**。

主要思想是 **将算法从特定的数据结构中抽象出来，使算法成为通用的、可以作用于各种不同的数据结构**。

为什么需要泛型程序设计:

在软件的复用中，被复用和复用双方需要遵守一定的协议。

例如:

1. 调用函数时除了需要提供正确的函数名，也要提供正确的参数。
2. 模板中类型参数 T 需要具备相应的功能如能比较大小，大于号有相应的重载等。

### 概念

用概念来描述泛型程序设计中作为参数的数据类型所需具备的功能。

**其内涵是这些功能**。

**其外延是具备这些功能的所有数据类型**。

例如将可以比大小，具有公有的复制构造函数并可用 = 赋值的所有数据类型记作 `Sortable` 概念。

**概念之间存在包含与被包含的关系**。

### 模型

具备一个概念所需要功能的数据类型称为这一概念的一个模型。

例如 int 数据类型就是 Sortable 概念的一个模型。

## STL

伟大，无需多言!

### 容器(container)

容器是容纳、包含一组元素的对象。

例如: `priority_queue`。

### 迭代器(iterator)

迭代器提供了顺序访问容器中每个元素的方法:

```C++
vector<int> v;
vector<int>::iterator it=v.begin();
++it;//指向v第二个元素
*it=114514;//访问所指向的元素
--it;//指向v第一个元素
```

若迭代器指向的是类或结构体，还可以用-> 直接访问该元素的一个成员。

**迭代器是泛化的指针**

各种容器的迭代器与不同的迭代器将在后面介绍。

### 函数对象(function object)

一个行为类似函数的对象，对它可以像调用函数一样调用。

函数对象是泛化的函数。

### 算法(algorithm)

这些算法都具有统一性，可以广泛用于不同的对象和内置的数据类型。

## 迭代器

*`cin` 是输入流的一个实例，`cout` 是输出流的一个实例*。

### 输入流迭代器

输入流迭代器用来从一个输入流中连续地输入某种类型的数据，它是一个类模板，例如:

```C++
template <class T>istream_iterator<T>;
```

其中，`T` 类型要满足两个条件:

1. 有默认构造函数。
2. 可以用 `>>` 从输入流输入。

一个输入流迭代器的实例需要由下面的构造函数来构造:

```C++
istream_iterator(istream& in);
```

**其中 `in` 表示将数据输入到的输入流**。

`istream_iterator` 类模板有一个默认构造函数，该函数构造出的迭代器指向的就是输入流的结束位置。

### 输出流迭代器

输出流迭代器用来向一个输出流中连续地输出某种类型的数据，它是一个类模板，例如:

```C++
template <class T>ostream_iterator<T>;
```

其中，`T` 需要具有一个功能：可以用 `<<` 向输出流输出。

一个输出流迭代器可以用下面两个构造函数来构造:

```C++
ostream_iterator(ostream& out);
ostream_iterator(ostream& out,const char* delimiter);
```

**其中 `out` 表示将数据输出到的输出流**。

**`delimiter` 表示两个输出数据之间的分隔符**。

输出流迭代器可以使用 *，* it = x 相当于 `out<<x` 或 `out<<x<<delimiter`。

输出流迭代器可以使用++但意义不大。

总使用例:

```C++
transform(istream_iterator<double>(cin),istream_iterator<double>(),ostream_iterator<double>(cout,"\t"),a_function);
```

### 迭代器的分类

<img src=".\pictures\image-20241228151815560.png"> 

接下来所有概念都是 `Assignable` 概念的子概念:

即都有公有的复制构造函数和赋值运算符。

`++p` 为使迭代器 `p` 指向下一个元素，返回 `p` 自身的引用。

`p++` 为使迭代器 `p` 指向下一个元素，根据 `p` 的类型不同，返回不同。

#### 输入迭代器

输入迭代器可以用来从序列中读取数据，但是不一定能够向其中写入数据。

输入迭代器支持对序列进行不可重复的单向遍历。

值得注意的是: 即使 `p==q`，`++p==++q` 和 `(++p)==(++q)` 是不一定成立的，具体原因有些复杂，涉及每个 `range` 对应迭代器唯一性问题。

#### 输出迭代器

输出迭代器允许向序列中写入数据，但是并不保证可以从其中读取数据。

输出迭代器支持对序列进行单向遍历。

使用输出迭代器，写入元素操作和 `++` 自增操作需要交替进行，否则行为不确定(就是可能会出现难以理解的 bug)。

#### 前向迭代器

前向迭代器是输入迭代器和输出迭代器的子概念，既支持数据读取，也支持数据写入，支持对序列进行可重复的单向遍历。

前向迭代器的操作是确定的，不受输出迭代器的限制。

#### 双向迭代器

双向迭代器是单向迭代器的子概念，额外支持迭代器反向移动，即如对应 `++` 的 `--` 操作。

#### 随机访问迭代器

随机访问迭代器是双向迭代器的子概念，额外支持将迭代器向前或向后移动 `n` 个元素，几乎和指针一样。

### 迭代器的区间

`STL` 算法的形参中常包括一对输入迭代器，它们构成的区间表示输入数据的序列。

设 `p1`，`p2` 是两个输入迭代器，当且仅当对 `p1` 执行 `n` 次 `++` 运算后，表达式 `p1==p2` 为真，则 `[p1,p2)` 是一个合法的区间。

```C++
template <class T,class InputIt,class OutputIt>
void mySort(InputIt first,InputIt last,OutputIt result){
    vector<T>s;
    for(;first!=last;++first)s.push_back(*first);
    sort(s.begin(),s.end());
    copy(s.begin(),s.end(),result);
}
int main(){
    double a[5]={1.1,4.5,1.4,19.19,8.10};
    mySort<double>(a,a+5,ostream_iterator<double>(cout," "));
    puts("");
    return 0;
}
```

### 迭代器的辅助函数

`STL` 为迭代器提供了两个辅助函数模板。

#### advance

```C++
template <class InputIt, class Distance>
void advance(InputIt& iter,Distance n);
```

它用来使迭代器 `iter` 前进 `n` 个元素。

对于双向迭代器或随机访问迭代器，`n` 可以取负值，表示让 `iter` 后退 `n` 个元素。

#### distance

```C++
template <class InputIt>
unsigned distance(InputIt first, InputIt last);
```

用来计算 `first` 经过多少次 `++` 运算可以到达 `last`。

## 容器的基本功能与分类

每种容器都支持的基本功能有下，以 `set` 为例:

```C++
set<int> s,t;
s=t,s>t,s<t;
s.begin();
s.end();
s.clear();
s.empty();
s.size();
s.swap(t);
```

不同类型相关的迭代器有不同表示:

```C++
set<int>::iterator
set<int>::const_iterator
```

对于常迭代器，指向元素的类型为 `const T`，只能通过迭代器读取元素，不能改写元素。

<img src=".\pictures\image-20241228152239826.png">

一般 `STL` 标准容器都至少是可逆容器，其 `begin()` 或 `end()` 成员函数所得到的通常是双向迭代器。

也可以使用逆向迭代器:

容器的 `rbegin()` 或 `rend()` 成员函数返回的是逆向迭代器，它的表示如下:

```C++
set<int>::iterator s1;
set<int>::reverse_iterator p1=set<int>::reverse_iterator(s1);
//得到与s1对应的逆向迭代器，p1指向s1-1所指向的元素
p1.base();
//返回的是s1
set<int>::const_reverse_iterator p2;
```

事实上:

```C++
s1.rbegin()==set<int>::reverse_iterator(s1.end()),s1.rbegin().base()==s1.end();
s1.rend()==set<int>::reverse_iterator(s1.begin()),s1.rend().base()==s1.begin();
```

随机访问容器提供的迭代器是随机访问迭代器，可以直接通过一个整数来访问容器中的指定元素:

```C++
vector<int> v;
v[114514];
```

<img src=".\pictures\image-20241228152349038.png">

## 顺序容器

每种类型的容器都是一个类模板，都具有一个模板参数，表示容器的元素类型，该类型必须符合 `Assignable` 概念，即具有公有的复制构造函数并可以用 `=` 赋值。

### 基本功能

#### 构造函数

<img src=".\pictures\image-20241228152418078.png">

#### 赋值函数

<img src=".\pictures\image-20241228152452239.png">

#### 元素插入

<img src=".\pictures\image-20241228152517152.png">

#### 元素删除

<img src=".\pictures\image-20241228152538874.png">

#### 改变容器的大小

<img src=".\pictures\image-20241228152605189.png">

#### 首尾元素的直接访问

<img src=".\pictures\image-20241228152626321.png">

#### 在容器尾部插入、删除元素

<img src=".\pictures\image-20241228152651053.png">

#### 在容器头部插入、删除元素

`list` 或 `deque` 能支持的操作，具有前插顺序容器这一概念的容器可以完成操作。

<img src=".\pictures\image-20241228152719427.png">

#### 容器的列表初始化

示例如下:

<img src=".\pictures\image-20241228152749517.png">

### 5 种顺序容器的特性

####  向量(vector)

主要介绍动态内存分配:

当数组的空间不够时，`vector` 会自动用 `new` 分配一块更大的空间，将原有的数据分别复制到新的空间中，再将原有的空间释放，向量的容量为申请的空间总数。

<img src=".\pictures\image-20241228152820650.png">

值得注意的是:

**如果插入操作引起了向量容量的扩展，那么在执行插入之前所获得的一切迭代器、指针和引用都会失效**。

**如果插入操作未引起了向量容量的扩展，那么在执行插入位置之后的一切迭代器、指针和引用都会失效**。

标准库提供了 `shrink_to_fit` 函数实现将 `vector` 中未使用的元素空间回收的功能。

#### 双端队列(deque)

<img src=".\pictures\image-20241228152850098.png">

1. 当向 `deque` 两端加入元素时，会使所有迭代器失效，但是不会使已有的指针，引用失效，

   前者是因为插入新元素可能会引起索引数组中已有元素位置的改变，

   后者是因为元素在分段数组中位置不变。

2. 当删除 `deque` 两端元素时，`O(1)` 效率，只会使被删除元素的迭代器、指针或引用失效，而不会影响其他元素的迭代器、指针或引用。

3. 当在 `deque` 中间插入新元素时，类似 `vector` 中头部插入元素，效率偏低，且所有迭代器、指针和引用失效。

4. 删除情况类似 3。

#### 列表(list)

基本原理按指针链表理解即可。

列表之间支持接合操作:

<img src=".\pictures\image-20241228152912430.png">

#### 单向链表(forward_list)和数组(array)

`forward_list` 的设计目标是达到与手写的单向链表数据结构相当的性能。

`array` 提供了更安全，更方便地使用数组的方式。

#### 5 种顺序容器的比较

<img src=".\pictures\image-20241228153006886.png">

<img src=".\pictures\image-20241228153028707.png">

### 顺序容器的插入迭代器 **(Insertion Iterator)**

插入迭代器是 `STL` 中的一种特殊迭代器，它允许我们在容器的特定位置插入元素，而不仅仅是替换已有的元素。插入迭代器通常用于需要在容器中动态插入元素的场景。

插入迭代器通常与 `STL` 容器的 `insert()` 操作配合使用，它允许我们通过迭代器将一个值插入到容器中。

##### 1. `insert_iterator`

- **作用**: 它允许在容器的指定位置插入元素。可以在容器中的任意位置插入元素，而不仅限于容器的末尾。
- **用法**: 通过 `insert_iterator` 插入元素时，我们通常使用 `insert()` 方法，它会将元素插入到指定位置。

```C++
int main() {
    vector<int> v={1,2,3,4};
    insert_iterator<vector<int>> insert_it(v,v.begin()+2);
    *insert_it=114514;//在位置2插入114514
    v.insert(v.begin()+2,88);//可以直接使用insert
    for(int i:v){
        cout<<i<<" ";
    }
    return 0;
}
```

##### 2.`front_insert_iterator`

- **作用**: 它仅适用于支持在容器前端插入元素的容器(例如 `deque` 或 `list`)。通过它插入元素会将元素插入到容器的开头。
- **用法**: 用于将元素插入容器的前端。例如，当我们使用 `front_insert_iterator` 时，元素会被插入到容器的开头(即使我们在容器的迭代器上前进)。

```C++
int main(){
    deque<int> dq={1,2,3,4};
    front_insert_iterator<deque<int>> front_it(dq);
    *front_it=99;//在deque前端插入99
    for(int i:dq){
        cout<<i<<" ";
    }
    return 0;
}
```

##### 3.`back_insert_iterator`

- **作用**: 它专门用于容器的尾部插入元素。它支持将元素插入到容器的末尾。`back_insert_iterator` 是最常用的插入迭代器，因为许多容器（如 `vector`, `deque` 和 `list`）都支持尾部插入。
- **用法**: 通过 `back_insert_iterator` 进行插入时，元素会自动被追加到容器的末尾。

```C++
int main(){
    vector<int> v={1,2,3,4};
    back_insert_iterator<vector<int>> back_it(v);
    *back_it=99;//在vector末尾插入99
    for(int i:v){
        cout<<i<<" ";
    }
    return 0;
}
```

### 顺序容器的适配器

#### 容器适配器(Container Adapters)

容器适配器本质上是对底层容器的包装，它提供了一种不同的接口来操作容器。`C++` 标准库中有三种容器适配器:

- **栈(stack)**
- **队列(queue)**
- **优先队列(priority_queue)**

#### 功能适配器(Function Adapters)

功能适配器提供了一些函数对象(`functors`)来封装操作，使得容器操作更加灵活和简洁。

**`greater` 和 `less`**

`greater` 和 `less` 是两种常用的比较函数对象，分别用于表示“大于”关系和“小于”关系。

```C++
#include <iostream>
#include <queue>
#include <functional>//for greater,less
using namespace std;
int main(){
    priority_queue<int,vector<int>,greater<int> > pq;
    //使用greater使优先队列变成最小堆
    pq.push(10);
    pq.push(20);
    pq.push(5);
    cout<<"Top element: "<<pq.top()<<endl;//输出5
    pq.pop();
    cout<<"Top element after pop: "<<pq.top()<<endl;//输出10
    return 0;
}
```

## 关联容器

关联容器的每个元素都有一个键 `key`，容器中元素的顺序不能被随意决定，而是按照键的取值升序排列。

**关联容器可分为单重关联容器和多重关联容器**:

#### 单重关联容器

键值唯一，不允许重复。

#### 多重关联容器

相同的键值允许重复出现。

**关联容器也可分为简单关联容器和二元关联容器**:

#### 简单关联容器

以元素本身作为键。

#### 二元关联容器

由键和某种类型的附加数据共同构成。

<img src=".\pictures\image-20241228153111346.png">

- **简单关联容器只有一个类型参数**。
- **二元关联容器有两个类型参数，前一个是键类型，后一个是附加数据的类型**。
- **后者的组合类型可以用 `pair` 表示**。
- **关联容器的键之间必须能够使用 `<` 比较大小，否则需要重载 `<` 运算符**。

### 关联容器支持的操作

#### 构造函数

<img src=".\pictures\image-20241228153136591.png">

#### 元素的插入

<img src=".\pictures\image-20241228153200232.png">

#### 元素的删除

<img src=".\pictures\image-20241228153222281.png">

#### 基于键的查找和计数

<img src=".\pictures\image-20241228153243310.png">

#### 关联容器的列表初始化

<img src=".\pictures\image-20241228153317856.png">

### 8 种关联容器的特性

#### 集合(set)

几乎是数学上的集合，只是元素个数有限。

集合的第一个元素一定是最小的元素。

集合的最后一个元素一定是最大的元素。

#### 映射(map)

底层是红黑树。

伟大，无需多言。

#### 多重集合(multiset)和多重映射(multimap)

相比 `set` 和 `map`，一个键可以对应多个元素。

*使用 `find()` 将得到某一个不确定的元素位置*。

通常使用 `equal_range()` 和 `count()`。

使用例:

```C++
multimap<string,string>courses;
/*...*/
auto range=courses.equal_range("math");
for(multimap<string,string>::iterator it=range.first;it!=range.second;++iter)
    cout<<iter->second<<" ";
```

#### 无序容器

包括 `unordered_set`，`unordered_map`，`unordered_multiset`，`unordered_multimap`。

它们是通过哈希函数和键类型的 `==` 运算符组织元素的。

在不考虑序的情况下，无序函数非常有用。

哈希函数的使用能够获得更好的平均性能。

## 函数对象

**函数对象是一个行为类似函数的对象，对参数数目没有要求，功能是获取一个值，或者改变操作的状态**。

**任何普通的函数、函数指针、`lambda` 表达式和任何重载了调用运算符 `operator()` 的类的对象都满足函数对象的特征**。

<img src=".\pictures\image-20241228153355192.png">

#### 自定义函数对象

使用例:

```C++
bool cmp(int x,int y)return x>y;
int main(){
    sort(a,a+n+1,cmp);
    return 0;
}
```

### 标准的函数对象

#### 产生器(generator)、一元函数(unary function)和二元函数(binary function)

分别是具有 0 个、1 个和 2 个传入参数的函数对象:

<img src=".\pictures\image-20241228153418170.png">

需要调用 <functional>，标准函数对象是内联函数。

使用例:

```C++
int a[]={1,1,4,5,1,4},n=6;
accumulate(a,a+n,1,multiplies<int>())
```

#### 一元谓词(unary predicate)和二元谓词(binary predicate)函数对象

要求返回为 `bool` 型，并具有一个或两个参数。

<img src=".\pictures\image-20241228153440976.png">

使用例:

```C++
int a[]={1,1,4,5,1,4};
sort(a,a+6,greater<int>() );
```

### lambda 表达式

可以理解为一个未命名的内联函数，包含一个返回类型，一个参数列表和一个函数体，可能定义在函数内部。

**基本语法**

```C++
[capture](parameter_list)->return_type{function_body}
```

其中:

- **capture:** 捕获外部变量的方式(可以是值捕获、引用捕获等)。
- **parameter_list:** 与普通函数相同，可以定义输入参数。
- **return_type:** 返回值类型(可以省略，编译器自动推断)。
- **function_body:** 函数的具体实现。

#### 捕获的方式: capture

**按值捕获(默认捕获方式):** 通过 `[]` 括号捕获外部变量的副本:

```C++
int x=10;
auto lambda=[x](){return x*2;};
cout<<lambda()<<endl;//输出20
```

**按引用捕获:** 通过 `[&]` 捕获外部变量的引用。这样，Lambda 内部可以修改外部变量:

```C++
int x=10;
auto lambda=[&x](){x*=2;};
lambda();
cout<<x<<endl;//输出20
```

**指定捕获:** 可以指定捕获哪些变量，以及是按值还是按引用捕获:

```C++
int x=10,y=20;
auto lambda=[x,&y](){return x+y;};
y=50;
cout<<lambda()<<endl;//输出60(x按值捕获，y按引用捕获)
```

**捕获所有变量:**

1. `[=]` 按值捕获所有外部变量。
2. `[&]` 按引用捕获所有外部变量。
3. `[this]` 捕获当前对象的指针，可以在 `Lambda` 中使用类成员:

```C++
auto lambda1=[=](){return x+y;};//按值捕获所有外部变量
auto lambda2=[&](){return x+y;};//按引用捕获所有外部变量
```

**捕获列表与 this 指针:**

```C++
class MyClass{
public:
    int x;
    MyClass():x(10){}
    void foo(){
        auto lambda=[this](){return this->x;};
        cout<<lambda()<<endl;//输出10
    }
};
```

#### 参数列表: parameter_list

参数列表与普通函数一样，可以定义 `Lambda` 的输入参数。`Lambda` 参数可以省略，也可以显式地定义。

#### 返回类型: return_type

`Lambda` 表达式的返回类型可以显式指定，也可以由编译器自动推断。如果没有返回类型，则返回类型会默认推导为 `void`，或者由返回语句自动推导。

- **显式返回类型**:

```C++
auto lambda=[](int a,int b)->int{return a+b;};
cout<<lambda(3,4)<<endl;//输出7
```

- **隐式返回类型**: 编译器会根据返回值类型推导出 `Lambda` 的返回类型

```C++
auto lambda=[](int a,int b){return a+b;};//返回类型会自动推导为int
cout<<lambda(3,4)<<endl;//输出7
```

`Lambda` 表达式还可以作为 `STL` 中的回调函数，如:

```C++
vector<int> vec={1,2,3,4,5};
for_each(vec.begin(),vec.end(),[](int x){cout<<x<<" ";});
```

由于 `Lambda` 能捕获外部变量，它还可以充当闭包(`Closure`)，可以将外部数据封装在内部的函数中。

### 函数对象参数绑定

指将一个函数对象的某些参数与固定的值绑定，使得生成一个新的函数对象，该函数对象具有固定的参数。

使用例:

```C++
auto p=find_if(a.begin(),a.end(),bind(greater<>(),placeholders::_1,40));
```

这里 `bind<>` 相当于一个函数，占位符 `_1` 接收了 `find_if` 提供的参数。

## 算法

**算法本身就是一种函数模板**。

`STL` 算法可以分为 4 大类:

### 不可变序列算法(Non-mutating algorithms)

指不直接修改所操作的容器内容的算法，包括:

1. 在序列中查找元素的算法。
2. 执行相等检查的算法。
3. 对序列元素进行计数的算法。

<img src=".\pictures\image-20241228153508601.png">

### 可变序列算法(Mutating algorithms)

可以修改它们所操作的容器的元素，包括:

复制(`copy`)，生成(`generate`)，删除(`remove`)，替换(`replace`)，倒序(`reverse`)，旋转(`rotate`)，交换(`swap`)，变换(`transform`)，分割(`partition`)，去重(`unique`)，填充(`fill`)，洗牌(`shuffle`)

<img src=".\pictures\image-20241228153532001.png">

<img src=".\pictures\image-20241228153557784.png">

### 排序和搜索算法

<img src=".\pictures\image-20241228153626961.png">

<img src=".\pictures\image-20241228153706798.png">

### 数值算法

需要包含头文件 <numeric>

<img src=".\pictures\image-20241228153732024.png">

## 9.迭代器的类型特征

<img src=".\pictures\image-20241228153800753.png">

## Boost

喜欢可以去玩玩这个库 i

# 第十一章-流类库与输入输出

`C++` 标准库中一个面向对象的输入输出软件包

## 基本概念

### 流

**流是一种抽象，它负责在数据的生产者和数据的消费者之间建立联系，并管理数据的流动**。

程序操作流对象，流对象通过文件系统对所连接的文件对象产生作用。

**程序将流对象看作是文件对象的化身**。

### I/O 流类库

I/O 流类库的基础是一组类模板，类模板提供了库中的大多数功能，而且可以作用于不同类型的元素。

流的基本单位的数据类型就是模板的参数。

<iostream> 中声明了 4 个预定义的流对象用来完成在标准设备上的输入输出操作: `cin`、`cout`、`cerr`、`clog`。

<img src=".\pictures\image-20241228153955467.png">

<img src=".\pictures\image-20241228154120072.png">

## 输出流

最重要的 3 个输出流是 **`ostream`**、**`ofstream`**、**`ostringstream`**。

预先定义的 **`ostream`** 类对象用来完成向标准设备的输出:

- `cout` 是标准输出流。
- `cerr` 是标准错误输出流，没有缓冲，发送给它的内容立即被输出。
- `clog` 类似于 `cerr`，但是有缓冲，缓冲区满时被输出。

**`ofstream`** 类支持磁盘文件输出。

如果在构造函数中指定一个文件名，当构造这个文件时该文件是自动打开的。

### 构造输出流对象

如果要使用文件流将信息输出到文件，需要使用构造函数来建立流对象:

使用默认构造函数，调用 `open` 成员函数

```C++
ofstream myFile;
myFile.open("114514.txt");
```

在调用构造函数时指定文件名

```C++
ofstream myFile("114514.txt");
```

使用同一个流先后打开不同的文件

```C++
ofstream myFile("114514.txt");
myFile.open("1919810.txt");
```

可以用字符串作为文件名。

### 使用插入运算符和操纵符

很多操纵符定义在 <iomanip>

#### 输出宽度

```C++
cout.width(10);//设定以至少10个字符宽按右对齐方式输出
cout.fill('*');//设定以*填充
cout<<setw(10)<< /*...*/;//指定宽度
```

#### 对齐方式

```C++
cout<<setiosflags(ios_base::left)<< /*...*/ <<resetiosflags(ios_base::left);
//设置左对齐和解除左对齐
```

<img src=".\pictures\image-20241228154149865.png">

#### 精度

```C++
cout<<setprecision(1)<<114.514;
//输出1e+002
cout<<setiosflags(ios_base::fixed)<<setprecision(1)<<114.514;
//输出114.5
cout<<setiosflags(ios_base::scientific)<<setprecision(1)<<114.514;
//输出1.1e+002
```

#### 进制

```C++
cout<<dec<<114514;//输出337522
cout<<oct<<114514;//输出114514
cout<<hex<<114514;//输出1BF52
cout<<setbase(16)<<114514;//输出1BF52
```

### 文件输出流成员函数

<img src=".\pictures\image-20241228154220513.png">

#### 输出流的 open 函数

```C++
ofstream file("filename",ios_base::out | ios_base::binary);
```

<img src=".\pictures\image-20241228154238123.png">

*对于 `ios_base:app`，若文件不存在，则新建一个同名文件。*

#### 输出流的 close 函数

如果需要在同一流对象上打开另外的文件，需要使用 `close` 函数。

#### put 函数

```C++
cout.put('A');//精确输出一个字符
cout<<'A';//同上，但是此前设置的宽度和填充方式在此起作用
```

#### write 函数

`write` 函数把一个内存中的一块内容写到一个文件输出流中，长度参数指出写的字节数。

```C++
struct date{
    int a,b,c;
}
int main(){
    date x={11,45,14};
    ofstream file("date.dat",ios_base::binary);
    file.write(reinterpret_cast<char *>(&x),sizeof(x));
    file.close();
    return 0;
}
```

`write` 函数带两个参数: 一个 `char` 指针(指向内存数据的起始地址)和一个所写的字节数。

#### seekp 和 tellp 函数

一个文件输出流保存一个内部指针指出下一次写数据的位置。

`seekp` 函数设置这个指针，因此可以以随机方式向磁盘文件输出。

`tellp` 函数返回该文件位置指针值。

```
file.seekp(20,ios::beg);//从文件头开始计算偏移量，这里是读取第21个字节
file.seekp(-1,ios::end);//从文件末尾开始计算偏移量，这里是读取最后一个字节
file.seekp(20,ios::cur);//从当前位置开始计算偏移量
streampos sp=in.tellp();//指示当前指针位置
```



#### 错误处理函数

<img src=".\pictures\image-20241228154258486.png">

### 二进制输出文件

在以文本模式输出时，没输出一个换行符 `\n` 都会将当前操作系统下的行分隔符写入文件中，这意味着在 `Windows` 下输出换行符后还会被自动扩充一个回车符。

想要避免这一问题，就要采用二进制模式输出到文件。

```C++
ofstream os("test.dat",ios_base::out|ios_base::binary);
```

### 字符串输出流

字符串输出流可以用于生成字符串。

`ostringstream` 类就用来表示一个字符串输出流。

`ostringstream` 具有 `ofstream` 类大部分功能，还具有一个特有函数 `str()`，返回 `string` 对象。

需要头文件 `<sstream>`

```C++
template<class T>
inline string toString(const T &v){
    ostringstream os;
    os<<v;
    return os.str();
}
int main(){
    cout<<toString(114.514);
    return 0;
}
```

## 输入流

最重要的 3 个输入流是 **`istream`**、**`ifstream`**、**`istringstream`**。

- `istream` 类最适合用于顺序文本模式输入。
- `ifstream` 类支持磁盘文件输入。
- `istream` 的所有功能都包括在 ifstream 中。

### 构造输入流对象

如果要使用文件流从文件中读取数据，就必须构造一个输入流对象:

使用默认构造函数，调用 `open` 成员函数:

```C++
ifstream myFile;
myFile.open("114514.txt");
```

在调用构造函数时指定文件名:

```C++
ifstream myFile("114514.txt");
```

使用同一个流先后打开不同的文件:

```C++
ifstream myFile("114514.txt");
myFile.open("1919810.txt");
```

可以用字符串作为文件名。

### 使用提取运算符

提取运算符(`>>`)对于所有标准 `C++` 数据类型都预先设计好，是从一个输入流对象获取字节最容易方法。

### 输入流操纵符

<img src=".\pictures\image-20241228154341485.png">

### 输入流相关函数

#### 输入流的 open 函数

```C++
ifstream file("filename",ios_base::in | ios_base::binary);
```

<img src=".\pictures\image-20241228154325154.png">

#### 输入流的 close 函数

如果需要在同一流对象上打开另外的文件，需要使用 `close` 函数。

#### get 函数

相比 `>>` 还接受空白字符。

```C++
char ch;
while((ch=cin.get())!=EOF)cout.put(ch);
```

#### getline 函数

`getline` 函数允许从输入流中读取多个字符，并且允许指定输入终止字符。

```C++
string line;
getline(cin,line,'t');//属于string流
char line_[10];
cin.getline(line_,5,'t');//属于istream流
```

#### read 函数

`read` 函数从一个文件读字节到一个指定的存储器区域，由长度参数确定要读的字节数。

```C++
ifstream file("filename",ios_base::in | ios_base::binary);
file.read(reinterpret_cast<char *>(&file),sizeof(file));
```

#### seekg 和 tellg 函数

一个文件输入流保存一个内部指针指向文件中下一个将读数据的位置。

`seekg` 函数设置这个指针。

`tellp` 函数返回该文件位置指针值，是 `streampos` 类型。

使用例:

```c++
file.seekg(20,ios::beg);//从文件头开始计算偏移量，这里是读取第21个字节
file.seekg(-1,ios::end);//从文件末尾开始计算偏移量，这里是读取最后一个字节
file.seekg(20,ios::cur);//从当前位置开始计算偏移量
streampos sp=in.tellg();//指示当前指针位置
```

#### 错误处理函数

<img src=".\pictures\image-20241228154403471.png">

### 字符串输入流

字符串输入流可以用于从一个字符串中读取数据:

`istringstream` 类就用来表示一个字符串输入流。

`istringstream` 具有 `ifstream` 类大部分功能，只有专用于文件操作的 `open` 函数和 `close` 函数不具有。

需要头文件 `<sstream>`

```C++
template<class T>
inline T fromString(const string &str){
    istringstream is(str);
    T v;
    is>>v;
    return v;
}
int main(){
    cout<<fromString("114.514");
    return 0;
}
```

## 宽字符、宽字符串与宽流

### 普通字符和字符串的缺陷

计算机需要处理的字符有些是在 `ASCII` 码表之外。

一个汉字需要用两个连续的 `char` 数据来表示。

字符串处理汉字就会存在相关问题:

- 字符串长度将会比汉字数目多。
- 截取子串的时候，会出现问题。
- 查找子串也会有问题。

### 宽字符

列宽字符(`WideCharacter`)是指用于表示较大字符集的字符类型，通常比传统的字符类型(如 `char`)占用更多的内存空间。`C++` 中的宽字符类型为 `wchar_t`，它通常用于存储 `Unicode` 字符:

- `wchar_t` 类型用于表示宽字符。
- 它的大小通常为 2 或 4 字节(取决于平台和编译器)，以支持表示多字节字符集(如 `UTF-16` 或 `UTF-32`)。
- 在 `Windows` 上，`wchar_t` 是 2 字节，而在一些 `Unix` 系统上，`wchar_t` 是 4 字节。
- `wchar_t` 支持 `Unicode` 字符集，使其能够表示几乎所有语言的字符。

```C++
int main(){
    wchar_t wide_char=L'你';//使用L前缀表示宽字符
    wcout<<L"Wide character:"<<wide_char<<endl;
    return 0;
}
```

### 宽字符串

宽字符串是由宽字符(`wchar_t`)构成的字符串，通常用 `wchar_t` 数组或 `std::wstring` 类型表示。宽字符串用于存储由多个 `Unicode` 字符组成的字符串:

- 宽字符串使用 `wchar_t` 数组或 `wstring` 来存储。
- `wstring` 是 `C++` 标准库中专门为宽字符串设计的容器类，具有与 `string` 类似的接口。
- 宽字符串使用 `L` 前缀，例如 `L"hello"`。

```C++
int main(){
    wstring wide_str=L"你好，世界！";//宽字符串
    wcout<<L"Wide string: "<<wide_str<<endl;
    return 0;
}
```

### 宽流

宽流是用于处理宽字符(`wchar_t`)的流类型。C++提供了宽流 `wcin`、`wcout`、`wcerr` 和 `wclog`，分别用于标准输入、标准输出、标准错误输出和日志输出:

- 宽流基于 `C++` 的流机制，支持宽字符类型的数据输入和输出。
- `wcin` 是宽字符版的 `cin`，用于从标准输入读取宽字符。
- `wcout` 是宽字符版的 `cout`，用于向标准输出写入宽字符。
- `wclog` 和 `wcerr` 类似于 `wcout` 和 `wcerr`，但用于日志输出和错误输出。

```C++
int main(){
    wcout<<L"请输入一个宽字符字符串："<<endl;
    wstring input;
    wcin>>input;//从标准输入读取宽字符字符串
    wcout<<L"你输入的字符串是："<<input<<endl;
    return 0;
}
```

### C++ 中的宽字符与多字节字符转换

`C++` 标准库提供了一些工具来进行宽字符和多字节字符(如 `char`)之间的转换。常用的转换函数包括:

- `mbstowcs()`: 将多字节字符数组转换为宽字符数组。
- `wcstombs()`: 将宽字符数组转换为多字节字符数组。
- `wstring_convert`: `C++11` 提供的类，用于在宽字符和多字节字符之间进行转换。

## 对象的串行化

对象的串行化(或序列化)是指将对象的状态转换为一种可存储或传输的格式，通常是字节流。这使得对象可以在不同的程序、不同的计算机或不同的进程间进行传递，并且可以在稍后的时间反序列化(`deserialize`)为原始对象。

对象串行化的常见用途包括:

- 存储对象(如将对象保存到文件或数据库中)。
- 在网络上传输对象(如通过 `HTTP`、`TCP/IP` 协议传输数据)。
- 跨平台传输(确保对象在不同的操作系统或硬件架构间传递时能够正确还原)。

### 序列化的常见方法

1. 使用 `ostream` 和 `istream` 进行流序列化
   最常见的对象串行化方式是通过 C++标准流(`ostream` 和 `istream`)来操作数据。可以将对象的每个成员变量按顺序写入输出流，再通过输入流读取并还原对象

2. 手动序列化与反序列化

   在简单情况下，可以手动编写函数，将对象的每个成员变量以一种特定的格式(如二进制格式或文本格式)写入流中。反序列化时，再从流中读取数据并恢复成原对象



# 第十二章-异常处理

## 异常处理的基本思想

<img src=".\pictures\image-20241228154507354.png">

## C++异常处理的实现

### 异常处理的语法

`try` 语句块用于包围可能抛出异常的代码。如果代码中的某个部分发生了异常，控制流会跳到相应的 `catch` 语句中。

`catch` 用于捕获并处理 `try` 语句块抛出的异常。每个 `catch` 语句块都可以指定一个特定的异常类型，程序会依照异常类型跳转到相应的 `catch` 语句块中进行处理。

```C++
try{
    //可能发生异常的代码
    //例如:除数为零、数组越界、空指针解引用等
}catch(exception_type1 &e){
    //处理exception_type1类型的异常
}catch(exception_type2 &e){
    //处理exception_type2类型的异常
}
```

`throw` 用于抛出一个异常。当程序检测到错误或特殊情况时，可以通过 `throw` 语句将异常抛出，并跳转到与之匹配的 `catch` 语句。

```C++
throw SomeException("An error occurred");
```

在 `C++` 中，异常通常是通过类对象传递的，因此大多数异常对象都是 `exception` 类或其派生类的实例。通过继承 `exception` 类，可以创建自定义异常类型。

```C++
class MyException:public exception{
public:
    const char* what() const noexcept override{
        return "My custom exception";
    }
};
try{
    throw MyException();
}catch(const MyException &e){
    cout<<e.what()<<endl;//输出:My custom exception
}
```

### 异常接口声明

使用 `noexcept` 声明一个函数时，表示该函数不会抛出异常。`noexcept` 还可以用于表达式。

`exception` 类定义了一个 `what()` 成员函数，它返回异常的描述信息。

可以通过 `is_nothrow_invocable` 来检查一个函数是否会抛出异常。

```C++
void func() noexcept;//函数不抛出异常
void func2() noexcept(false){//函数可能抛出异常
    throw runtime_error("An error occurred");
}
int main(){
    f();
    try{
        g();//可能抛出异常
    }catch(const exception& e){
        cout<<e.what()<<endl;
    }
    cout<<is_nothrow_invocable_v<decltype(func)><<endl;//输出1
    cout<<is_nothrow_invocable_v<decltype(func2)><<endl;//输出0
    return 0;
}
```

可以通过继承 `exception` 类来自定义异常类型。在自定义的异常类中，可以重载 `what()` 函数以提供更多的信息。

```C++
class MyException:public exception{
public:
    const char* what()const noexcept override{
        return "My custom exception";
    }
};
try{
    throw MyException();
}catch(const MyException& e){
    cout<<"Caught custom exception: "<<e.what()<<endl;
}
```

<img src=".\pictures\image-20241228154622058.png">

## 异常处理中的构造与析构

找到一个匹配的 `catch` 异常处理后:

- 如果 `catch` 子句的异常声明是一个值参数，则其初始化方式是复制被抛出的异常对象。
- 如果 `catch` 子句的异常声明是一个引用，则其初始化方式是使该引用指向异常对象。

异常被抛出后，栈的展开过程开始。

从进入 `try` 块(与截获异常的 `catch` 子句相对应的那个 `try` 块)起，到异常被抛出前，这期间在栈上构造(且尚未析构)的所有对象都会被自动析构，析构的顺序与构造的顺序相反。
        </textarea>
        <script>
            $m.innerHTML = marked.parse($t.value);
            window.MathJax && MathJax.typeset();
        </script>
        <!-- 评论展示容器 -->
        <div class="container" style="max-width: 900px; padding: 20px; transform: translateX(-150px);">
            <div id="comments-container"></div>
            <!-- 评论输入框 -->
            <div class="card mb-4">
                <div class="card-body">
                    <h5 class="card-title">发表评论</h5>
                    <form id="comment-form">
                        <input type="text" id="comment-username" class="form-control mb-2" placeholder="您的昵称" required></input>
                        <div class="mb-3">
                            <textarea id="comment-text" class="form-control" rows="3" placeholder="写下您的评论..." required></textarea>
                        </div>
                        <button type="submit" class="btn btn-secondary me-2">发送</button>
                    </form>
                </div>
            </div>
            <!-- 引入 Supabase -->
            <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
            <script>
                const SUPABASE_URL = 'https://iuywungpuuxkdjlnkhge.supabase.co';
                const SUPABASE_KEY = 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6Iml1eXd1bmdwdXV4a2RqbG5raGdlIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDg4NzMwNjAsImV4cCI6MjA2NDQ0OTA2MH0.m7Sm50pXOYFB9vgHz0XlBhzu75HvT7kLX64UUD6C6Ts';
                const supabaseClient = supabase.createClient(SUPABASE_URL, SUPABASE_KEY);
                // 提交评论
                document.getElementById('comment-form').addEventListener('submit', async (e) => {
                    e.preventDefault();
                    const text = document.getElementById('comment-text').value.trim();
                    const username = document.getElementById('comment-username').value.trim();
                    if (!text || !username) return;
                    const { error } = await supabaseClient
                    .from('Comments')
                    .insert([{ username, message: text, page: 'advanced_programing'}]);
                    if (error) {
                        alert('提交失败！');
                        console.error(error);
                    }
                    else {
                        document.getElementById('comment-form').reset();
                        loadComments();
                    }
                });
                // 加载评论并展示
                async function loadComments() {
                    const { data, error } = await supabaseClient
                    .from('Comments')
                    .select('*')
                    .order('created_at', { ascending: false });
                    if (error) return console.error('加载失败', error);
                    const container = document.getElementById('comments-container');
                    container.innerHTML = '';
                    data.forEach(({ username, message, created_at, page}) => {
                        const date = new Date(created_at)
                        const timeAgo = new Date(date.getTime() + 8 * 60 * 60 * 1000).toLocaleString(); // 北京时间
                        const rand = Math.floor(Math.random() * 21) + 1;
                        const commentHtml = `
                        <div class="card mb-4 rounded-3 shadow-sm">
                            <div class="card-body d-flex">
                                <img src="./static/img/${rand}.jpg" class="rounded-circle me-3" width="40" height="40" alt="用户头像">
                                <div>
                                    <h6 class="mb-1">${username} <small class="text-muted">· ${timeAgo}</small></h6>
                                    <p class="mb-1">${message}</p>
                                </div>
                            </div>
                        </div>
                        `;
                        if (page == 'advanced_programing') container.innerHTML += commentHtml;
                    });
                }
                // 初次加载
                loadComments();
            </script>
        </div>
        <br></br>
        <br></br>
        <div class="player" id="audioPlayer">
      <div class="d-flex justify-content-between align-items-center">
        <div class="d-flex align-items-center">
          <button class="control-button" id="previousBtn">
            <i class="fas fa-backward"></i>
          </button>
          <button class="control-button" id="playPauseBtn">
            <i class="fas fa-play"></i>
          </button>
          <button class="control-button" id="nextBtn">
            <i class="fas fa-forward"></i>
          </button>
          <span id="currentSong" class="ml-3">sasakure.UK - uzumakinoharu.mp3</span>
        </div>
      </div>
	    <div id="progressBarControl">
        <img class="music_img" src="static\img\music.ico" width="30" height="30" alt="" id="music_img"></img>
        <input id="progressBar" type="range" min="0" max="100" step="0.1" value="0"></input>
	    </div>
      <div id="volumeControl">
        <img class="volume_img" src="static\img\volume-up.svg" width="30" height="30" alt="" id="volume_img"></img>
        <input id="progressBar_volume" type="range" id="volume" min="0" max="1" step="0.01" value="1" onchange="setVolume(this.value)"></input>
      </div>
      <audio id="audio">
        <source src="./static/audio/sasakure.UK - uzumakinoharu.mp3" type="audio/mp3"></source>
        Your browser does not support the audio element.
      </audio>
    </div>
    <script src="static\js\audio.js" rel="stylesheet"></script>
    </body>
</html>
